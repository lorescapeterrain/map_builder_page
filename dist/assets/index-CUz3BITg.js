(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function t(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=t(i);fetch(i.href,s)}})();const qh=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"})),$h="modulepreload",Xh=function(r){return"/"+r},$l={},jh=function(e,t,n){let i=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),o=(a==null?void 0:a.nonce)||(a==null?void 0:a.getAttribute("nonce"));i=Promise.allSettled(t.map(l=>{if(l=Xh(l),l in $l)return;$l[l]=!0;const c=l.endsWith(".css"),d=c?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${l}"]${d}`))return;const u=document.createElement("link");if(u.rel=c?"stylesheet":$h,c||(u.as="script"),u.crossOrigin="",u.href=l,o&&u.setAttribute("nonce",o),document.head.appendChild(u),c)return new Promise((h,m)=>{u.addEventListener("load",h),u.addEventListener("error",()=>m(new Error(`Unable to preload CSS for ${l}`)))})}))}function s(a){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=a,window.dispatchEvent(o),!o.defaultPrevented)throw a}return i.then(a=>{for(const o of a||[])o.status==="rejected"&&s(o.reason);return e().catch(s)})};/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Id="128",Wi={ROTATE:0,DOLLY:1,PAN:2},qi={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Yh=0,Xl=1,Zh=2,Pd=1,Dd=2,er=3,xr=0,Pt=1,yi=2,Nd=1,ui=0,sr=1,jl=2,Yl=3,Zl=4,Kh=5,ps=100,Jh=101,Qh=102,Kl=103,Jl=104,ef=200,tf=201,nf=202,sf=203,Fd=204,Bd=205,rf=206,af=207,of=208,lf=209,cf=210,df=0,uf=1,hf=2,Po=3,ff=4,pf=5,mf=6,gf=7,ga=0,yf=1,_f=2,Ii=0,vf=1,xf=2,bf=3,kd=4,wf=5,Od=300,$o=301,Xo=302,Ql=303,ec=304,ya=306,jo=307,_i=1e3,tn=1001,da=1002,Ft=1003,Do=1004,No=1005,nn=1006,zd=1007,br=1008,wr=1009,Mf=1010,Sf=1011,ua=1012,Tf=1013,ca=1014,di=1015,ha=1016,Ef=1017,Af=1018,Lf=1019,rr=1020,Rf=1021,hi=1022,pn=1023,Cf=1024,If=1025,Pf=pn,vs=1026,dr=1027,Df=1028,Nf=1029,Ff=1030,Bf=1031,kf=1032,Of=1033,tc=33776,nc=33777,ic=33778,sc=33779,rc=35840,ac=35841,oc=35842,lc=35843,zf=36196,cc=37492,dc=37496,Uf=37808,Hf=37809,Gf=37810,Vf=37811,Wf=37812,qf=37813,$f=37814,Xf=37815,jf=37816,Yf=37817,Zf=37818,Kf=37819,Jf=37820,Qf=37821,ep=36492,tp=37840,np=37841,ip=37842,sp=37843,rp=37844,ap=37845,op=37846,lp=37847,cp=37848,dp=37849,up=37850,hp=37851,fp=37852,pp=37853,mp=2200,gp=2201,yp=2202,ur=2300,Ss=2301,qa=2302,ms=2400,gs=2401,fa=2402,Yo=2500,Ud=2501,_p=0,vp=1,Hd=2,sn=3e3,jn=3001,Zo=3007,Ko=3002,xp=3003,Gd=3004,Vd=3005,Wd=3006,bp=3200,wp=3201,Ni=0,Mp=1,$a=7680,Sp=519,hr=35044,pa=35048,uc="300 es";class xi{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const s=i.indexOf(t);s!==-1&&i.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,e);e.target=null}}}const zt=[];for(let r=0;r<256;r++)zt[r]=(r<16?"0":"")+r.toString(16);let Ir=1234567;const ar=Math.PI/180,fr=180/Math.PI;function mn(){const r=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(zt[r&255]+zt[r>>8&255]+zt[r>>16&255]+zt[r>>24&255]+"-"+zt[e&255]+zt[e>>8&255]+"-"+zt[e>>16&15|64]+zt[e>>24&255]+"-"+zt[t&63|128]+zt[t>>8&255]+"-"+zt[t>>16&255]+zt[t>>24&255]+zt[n&255]+zt[n>>8&255]+zt[n>>16&255]+zt[n>>24&255]).toUpperCase()}function Kt(r,e,t){return Math.max(e,Math.min(t,r))}function Jo(r,e){return(r%e+e)%e}function Tp(r,e,t,n,i){return n+(r-e)*(i-n)/(t-e)}function Ep(r,e,t){return r!==e?(t-r)/(e-r):0}function or(r,e,t){return(1-t)*r+t*e}function Ap(r,e,t,n){return or(r,e,1-Math.exp(-t*n))}function Lp(r,e=1){return e-Math.abs(Jo(r,e*2)-e)}function Rp(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*(3-2*r))}function Cp(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*r*(r*(r*6-15)+10))}function Ip(r,e){return r+Math.floor(Math.random()*(e-r+1))}function Pp(r,e){return r+Math.random()*(e-r)}function Dp(r){return r*(.5-Math.random())}function Np(r){return r!==void 0&&(Ir=r%2147483647),Ir=Ir*16807%2147483647,(Ir-1)/2147483646}function Fp(r){return r*ar}function Bp(r){return r*fr}function Fo(r){return(r&r-1)===0&&r!==0}function qd(r){return Math.pow(2,Math.ceil(Math.log(r)/Math.LN2))}function $d(r){return Math.pow(2,Math.floor(Math.log(r)/Math.LN2))}function kp(r,e,t,n,i){const s=Math.cos,a=Math.sin,o=s(t/2),l=a(t/2),c=s((e+n)/2),d=a((e+n)/2),u=s((e-n)/2),h=a((e-n)/2),m=s((n-e)/2),_=a((n-e)/2);switch(i){case"XYX":r.set(o*d,l*u,l*h,o*c);break;case"YZY":r.set(l*h,o*d,l*u,o*c);break;case"ZXZ":r.set(l*u,l*h,o*d,o*c);break;case"XZX":r.set(o*d,l*_,l*m,o*c);break;case"YXY":r.set(l*m,o*d,l*_,o*c);break;case"ZYZ":r.set(l*_,l*m,o*d,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}var tr=Object.freeze({__proto__:null,DEG2RAD:ar,RAD2DEG:fr,generateUUID:mn,clamp:Kt,euclideanModulo:Jo,mapLinear:Tp,inverseLerp:Ep,lerp:or,damp:Ap,pingpong:Lp,smoothstep:Rp,smootherstep:Cp,randInt:Ip,randFloat:Pp,randFloatSpread:Dp,seededRandom:Np,degToRad:Fp,radToDeg:Bp,isPowerOfTwo:Fo,ceilPowerOfTwo:qd,floorPowerOfTwo:$d,setQuaternionFromProperEuler:kp});class Ae{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),s=this.x-e.x,a=this.y-e.y;return this.x=s*n-a*i+e.x,this.y=s*i+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}Ae.prototype.isVector2=!0;class Ut{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,s,a,o,l,c){const d=this.elements;return d[0]=e,d[1]=i,d[2]=o,d[3]=t,d[4]=s,d[5]=l,d[6]=n,d[7]=a,d[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,s=this.elements,a=n[0],o=n[3],l=n[6],c=n[1],d=n[4],u=n[7],h=n[2],m=n[5],_=n[8],v=i[0],y=i[3],p=i[6],f=i[1],b=i[4],M=i[7],S=i[2],x=i[5],I=i[8];return s[0]=a*v+o*f+l*S,s[3]=a*y+o*b+l*x,s[6]=a*p+o*M+l*I,s[1]=c*v+d*f+u*S,s[4]=c*y+d*b+u*x,s[7]=c*p+d*M+u*I,s[2]=h*v+m*f+_*S,s[5]=h*y+m*b+_*x,s[8]=h*p+m*M+_*I,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],a=e[4],o=e[5],l=e[6],c=e[7],d=e[8];return t*a*d-t*o*c-n*s*d+n*o*l+i*s*c-i*a*l}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],a=e[4],o=e[5],l=e[6],c=e[7],d=e[8],u=d*a-o*c,h=o*l-d*s,m=c*s-a*l,_=t*u+n*h+i*m;if(_===0)return this.set(0,0,0,0,0,0,0,0,0);const v=1/_;return e[0]=u*v,e[1]=(i*c-d*n)*v,e[2]=(o*n-i*a)*v,e[3]=h*v,e[4]=(d*t-i*l)*v,e[5]=(i*s-o*t)*v,e[6]=m*v,e[7]=(n*l-c*t)*v,e[8]=(a*t-n*s)*v,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,s,a,o){const l=Math.cos(s),c=Math.sin(s);return this.set(n*l,n*c,-n*(l*a+c*o)+a+e,-i*c,i*l,-i*(-c*a+l*o)+o+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),i=this.elements,s=i[0],a=i[3],o=i[6],l=i[1],c=i[4],d=i[7];return i[0]=t*s+n*l,i[3]=t*a+n*c,i[6]=t*o+n*d,i[1]=-n*s+t*l,i[4]=-n*a+t*c,i[7]=-n*o+t*d,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}Ut.prototype.isMatrix3=!0;let $i;class Rs{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{$i===void 0&&($i=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),$i.width=e.width,$i.height=e.height;const n=$i.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=$i}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let Op=0;class Bt extends xi{constructor(e=Bt.DEFAULT_IMAGE,t=Bt.DEFAULT_MAPPING,n=tn,i=tn,s=nn,a=br,o=pn,l=wr,c=1,d=sn){super(),Object.defineProperty(this,"id",{value:Op++}),this.uuid=mn(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=a,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new Ae(0,0),this.repeat=new Ae(1,1),this.center=new Ae(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ut,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=d,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=mn()),!t&&e.images[i.uuid]===void 0){let s;if(Array.isArray(i)){s=[];for(let a=0,o=i.length;a<o;a++)i[a].isDataTexture?s.push(Xa(i[a].image)):s.push(Xa(i[a]))}else s=Xa(i);e.images[i.uuid]={uuid:i.uuid,url:s}}n.image=i.uuid}return t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Od)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case _i:e.x=e.x-Math.floor(e.x);break;case tn:e.x=e.x<0?0:1;break;case da:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case _i:e.y=e.y-Math.floor(e.y);break;case tn:e.y=e.y<0?0:1;break;case da:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&this.version++}}Bt.DEFAULT_IMAGE=void 0;Bt.DEFAULT_MAPPING=Od;Bt.prototype.isTexture=!0;function Xa(r){return typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&r instanceof ImageBitmap?Rs.getDataURL(r):r.data?{data:Array.prototype.slice.call(r.data),width:r.width,height:r.height,type:r.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class gt{constructor(e=0,t=0,n=0,i=1){this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,s=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*i+a[12]*s,this.y=a[1]*t+a[5]*n+a[9]*i+a[13]*s,this.z=a[2]*t+a[6]*n+a[10]*i+a[14]*s,this.w=a[3]*t+a[7]*n+a[11]*i+a[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,s;const l=e.elements,c=l[0],d=l[4],u=l[8],h=l[1],m=l[5],_=l[9],v=l[2],y=l[6],p=l[10];if(Math.abs(d-h)<.01&&Math.abs(u-v)<.01&&Math.abs(_-y)<.01){if(Math.abs(d+h)<.1&&Math.abs(u+v)<.1&&Math.abs(_+y)<.1&&Math.abs(c+m+p-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const b=(c+1)/2,M=(m+1)/2,S=(p+1)/2,x=(d+h)/4,I=(u+v)/4,V=(_+y)/4;return b>M&&b>S?b<.01?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(b),i=x/n,s=I/n):M>S?M<.01?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(M),n=x/i,s=V/i):S<.01?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(S),n=I/s,i=V/s),this.set(n,i,s,t),this}let f=Math.sqrt((y-_)*(y-_)+(u-v)*(u-v)+(h-d)*(h-d));return Math.abs(f)<.001&&(f=1),this.x=(y-_)/f,this.y=(u-v)/f,this.z=(h-d)/f,this.w=Math.acos((c+m+p-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}gt.prototype.isVector4=!0;class fi extends xi{constructor(e,t,n){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new gt(0,0,e,t),this.scissorTest=!1,this.viewport=new gt(0,0,e,t),n=n||{},this.texture=new Bt(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:nn,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}fi.prototype.isWebGLRenderTarget=!0;class zp extends fi{constructor(e,t,n){super(e,t,n),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}zp.prototype.isWebGLMultisampleRenderTarget=!0;class Ht{constructor(e=0,t=0,n=0,i=1){this._x=e,this._y=t,this._z=n,this._w=i}static slerp(e,t,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,i)}static slerpFlat(e,t,n,i,s,a,o){let l=n[i+0],c=n[i+1],d=n[i+2],u=n[i+3];const h=s[a+0],m=s[a+1],_=s[a+2],v=s[a+3];if(o===0){e[t+0]=l,e[t+1]=c,e[t+2]=d,e[t+3]=u;return}if(o===1){e[t+0]=h,e[t+1]=m,e[t+2]=_,e[t+3]=v;return}if(u!==v||l!==h||c!==m||d!==_){let y=1-o;const p=l*h+c*m+d*_+u*v,f=p>=0?1:-1,b=1-p*p;if(b>Number.EPSILON){const S=Math.sqrt(b),x=Math.atan2(S,p*f);y=Math.sin(y*x)/S,o=Math.sin(o*x)/S}const M=o*f;if(l=l*y+h*M,c=c*y+m*M,d=d*y+_*M,u=u*y+v*M,y===1-o){const S=1/Math.sqrt(l*l+c*c+d*d+u*u);l*=S,c*=S,d*=S,u*=S}}e[t]=l,e[t+1]=c,e[t+2]=d,e[t+3]=u}static multiplyQuaternionsFlat(e,t,n,i,s,a){const o=n[i],l=n[i+1],c=n[i+2],d=n[i+3],u=s[a],h=s[a+1],m=s[a+2],_=s[a+3];return e[t]=o*_+d*u+l*m-c*h,e[t+1]=l*_+d*h+c*u-o*m,e[t+2]=c*_+d*m+o*h-l*u,e[t+3]=d*_-o*u-l*h-c*m,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,i=e._y,s=e._z,a=e._order,o=Math.cos,l=Math.sin,c=o(n/2),d=o(i/2),u=o(s/2),h=l(n/2),m=l(i/2),_=l(s/2);switch(a){case"XYZ":this._x=h*d*u+c*m*_,this._y=c*m*u-h*d*_,this._z=c*d*_+h*m*u,this._w=c*d*u-h*m*_;break;case"YXZ":this._x=h*d*u+c*m*_,this._y=c*m*u-h*d*_,this._z=c*d*_-h*m*u,this._w=c*d*u+h*m*_;break;case"ZXY":this._x=h*d*u-c*m*_,this._y=c*m*u+h*d*_,this._z=c*d*_+h*m*u,this._w=c*d*u-h*m*_;break;case"ZYX":this._x=h*d*u-c*m*_,this._y=c*m*u+h*d*_,this._z=c*d*_-h*m*u,this._w=c*d*u+h*m*_;break;case"YZX":this._x=h*d*u+c*m*_,this._y=c*m*u+h*d*_,this._z=c*d*_-h*m*u,this._w=c*d*u-h*m*_;break;case"XZY":this._x=h*d*u-c*m*_,this._y=c*m*u-h*d*_,this._z=c*d*_+h*m*u,this._w=c*d*u+h*m*_;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],s=t[8],a=t[1],o=t[5],l=t[9],c=t[2],d=t[6],u=t[10],h=n+o+u;if(h>0){const m=.5/Math.sqrt(h+1);this._w=.25/m,this._x=(d-l)*m,this._y=(s-c)*m,this._z=(a-i)*m}else if(n>o&&n>u){const m=2*Math.sqrt(1+n-o-u);this._w=(d-l)/m,this._x=.25*m,this._y=(i+a)/m,this._z=(s+c)/m}else if(o>u){const m=2*Math.sqrt(1+o-n-u);this._w=(s-c)/m,this._x=(i+a)/m,this._y=.25*m,this._z=(l+d)/m}else{const m=2*Math.sqrt(1+u-n-o);this._w=(a-i)/m,this._x=(s+c)/m,this._y=(l+d)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Kt(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,s=e._z,a=e._w,o=t._x,l=t._y,c=t._z,d=t._w;return this._x=n*d+a*o+i*c-s*l,this._y=i*d+a*l+s*o-n*c,this._z=s*d+a*c+n*l-i*o,this._w=a*d-n*o-i*l-s*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,s=this._z,a=this._w;let o=a*e._w+n*e._x+i*e._y+s*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=a,this._x=n,this._y=i,this._z=s,this;const l=1-o*o;if(l<=Number.EPSILON){const m=1-t;return this._w=m*a+t*this._w,this._x=m*n+t*this._x,this._y=m*i+t*this._y,this._z=m*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),d=Math.atan2(c,o),u=Math.sin((1-t)*d)/c,h=Math.sin(t*d)/c;return this._w=a*u+this._w*h,this._x=n*u+this._x*h,this._y=i*u+this._y*h,this._z=s*u+this._z*h,this._onChangeCallback(),this}slerpQuaternions(e,t,n){this.copy(e).slerp(t,n)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Ht.prototype.isQuaternion=!0;class P{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(hc.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(hc.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[3]*n+s[6]*i,this.y=s[1]*t+s[4]*n+s[7]*i,this.z=s[2]*t+s[5]*n+s[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,s=e.elements,a=1/(s[3]*t+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*t+s[4]*n+s[8]*i+s[12])*a,this.y=(s[1]*t+s[5]*n+s[9]*i+s[13])*a,this.z=(s[2]*t+s[6]*n+s[10]*i+s[14])*a,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,s=e.x,a=e.y,o=e.z,l=e.w,c=l*t+a*i-o*n,d=l*n+o*t-s*i,u=l*i+s*n-a*t,h=-s*t-a*n-o*i;return this.x=c*l+h*-s+d*-o-u*-a,this.y=d*l+h*-a+u*-s-c*-o,this.z=u*l+h*-o+c*-a-d*-s,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*i,this.y=s[1]*t+s[5]*n+s[9]*i,this.z=s[2]*t+s[6]*n+s[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,s=e.z,a=t.x,o=t.y,l=t.z;return this.x=i*l-s*o,this.y=s*a-n*l,this.z=n*o-i*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return ja.copy(this).projectOnVector(e),this.sub(ja)}reflect(e){return this.sub(ja.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Kt(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}P.prototype.isVector3=!0;const ja=new P,hc=new Ht;class on{constructor(e=new P(1/0,1/0,1/0),t=new P(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,i=1/0,s=-1/0,a=-1/0,o=-1/0;for(let l=0,c=e.length;l<c;l+=3){const d=e[l],u=e[l+1],h=e[l+2];d<t&&(t=d),u<n&&(n=u),h<i&&(i=h),d>s&&(s=d),u>a&&(a=u),h>o&&(o=h)}return this.min.set(t,n,i),this.max.set(s,a,o),this}setFromBufferAttribute(e){let t=1/0,n=1/0,i=1/0,s=-1/0,a=-1/0,o=-1/0;for(let l=0,c=e.count;l<c;l++){const d=e.getX(l),u=e.getY(l),h=e.getZ(l);d<t&&(t=d),u<n&&(n=u),h<i&&(i=h),d>s&&(s=d),u>a&&(a=u),h>o&&(o=h)}return this.min.set(t,n,i),this.max.set(s,a,o),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Hs.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return e===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new P),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new P),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),Ya.copy(t.boundingBox),Ya.applyMatrix4(e.matrixWorld),this.union(Ya));const n=e.children;for(let i=0,s=n.length;i<s;i++)this.expandByObject(n[i]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new P),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Hs),Hs.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Gs),Pr.subVectors(this.max,Gs),Xi.subVectors(e.a,Gs),ji.subVectors(e.b,Gs),Yi.subVectors(e.c,Gs),ei.subVectors(ji,Xi),ti.subVectors(Yi,ji),Ei.subVectors(Xi,Yi);let t=[0,-ei.z,ei.y,0,-ti.z,ti.y,0,-Ei.z,Ei.y,ei.z,0,-ei.x,ti.z,0,-ti.x,Ei.z,0,-Ei.x,-ei.y,ei.x,0,-ti.y,ti.x,0,-Ei.y,Ei.x,0];return!Za(t,Xi,ji,Yi,Pr)||(t=[1,0,0,0,1,0,0,0,1],!Za(t,Xi,ji,Yi,Pr))?!1:(Dr.crossVectors(ei,ti),t=[Dr.x,Dr.y,Dr.z],Za(t,Xi,ji,Yi,Pr))}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new P),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Hs.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return e===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=this.getSize(Hs).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(zn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),zn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),zn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),zn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),zn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),zn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),zn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),zn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(zn),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}on.prototype.isBox3=!0;const zn=[new P,new P,new P,new P,new P,new P,new P,new P],Hs=new P,Ya=new on,Xi=new P,ji=new P,Yi=new P,ei=new P,ti=new P,Ei=new P,Gs=new P,Pr=new P,Dr=new P,Ai=new P;function Za(r,e,t,n,i){for(let s=0,a=r.length-3;s<=a;s+=3){Ai.fromArray(r,s);const o=i.x*Math.abs(Ai.x)+i.y*Math.abs(Ai.y)+i.z*Math.abs(Ai.z),l=e.dot(Ai),c=t.dot(Ai),d=n.dot(Ai);if(Math.max(-Math.max(l,c,d),Math.min(l,c,d))>o)return!1}return!0}const Up=new on,fc=new P,Ka=new P,Ja=new P;class Fi{constructor(e=new P,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):Up.setFromPoints(e).getCenter(n);let i=0;for(let s=0,a=e.length;s<a;s++)i=Math.max(i,n.distanceToSquared(e[s]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new P),t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return e===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new on),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){Ja.subVectors(e,this.center);const t=Ja.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=(n-this.radius)*.5;this.center.add(Ja.multiplyScalar(i/n)),this.radius+=i}return this}union(e){return Ka.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(fc.copy(e.center).add(Ka)),this.expandByPoint(fc.copy(e.center).sub(Ka)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Un=new P,Qa=new P,Nr=new P,ni=new P,eo=new P,Fr=new P,to=new P;class Bi{constructor(e=new P,t=new P(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t===void 0&&(console.warn("THREE.Ray: .at() target is now required"),t=new P),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Un)),this}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new P),t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Un.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Un.copy(this.direction).multiplyScalar(t).add(this.origin),Un.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){Qa.copy(e).add(t).multiplyScalar(.5),Nr.copy(t).sub(e).normalize(),ni.copy(this.origin).sub(Qa);const s=e.distanceTo(t)*.5,a=-this.direction.dot(Nr),o=ni.dot(this.direction),l=-ni.dot(Nr),c=ni.lengthSq(),d=Math.abs(1-a*a);let u,h,m,_;if(d>0)if(u=a*l-o,h=a*o-l,_=s*d,u>=0)if(h>=-_)if(h<=_){const v=1/d;u*=v,h*=v,m=u*(u+a*h+2*o)+h*(a*u+h+2*l)+c}else h=s,u=Math.max(0,-(a*h+o)),m=-u*u+h*(h+2*l)+c;else h=-s,u=Math.max(0,-(a*h+o)),m=-u*u+h*(h+2*l)+c;else h<=-_?(u=Math.max(0,-(-a*s+o)),h=u>0?-s:Math.min(Math.max(-s,-l),s),m=-u*u+h*(h+2*l)+c):h<=_?(u=0,h=Math.min(Math.max(-s,-l),s),m=h*(h+2*l)+c):(u=Math.max(0,-(a*s+o)),h=u>0?s:Math.min(Math.max(-s,-l),s),m=-u*u+h*(h+2*l)+c);else h=a>0?-s:s,u=Math.max(0,-(a*h+o)),m=-u*u+h*(h+2*l)+c;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),i&&i.copy(Nr).multiplyScalar(h).add(Qa),m}intersectSphere(e,t){Un.subVectors(e.center,this.origin);const n=Un.dot(this.direction),i=Un.dot(Un)-n*n,s=e.radius*e.radius;if(i>s)return null;const a=Math.sqrt(s-i),o=n-a,l=n+a;return o<0&&l<0?null:o<0?this.at(l,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,s,a,o,l;const c=1/this.direction.x,d=1/this.direction.y,u=1/this.direction.z,h=this.origin;return c>=0?(n=(e.min.x-h.x)*c,i=(e.max.x-h.x)*c):(n=(e.max.x-h.x)*c,i=(e.min.x-h.x)*c),d>=0?(s=(e.min.y-h.y)*d,a=(e.max.y-h.y)*d):(s=(e.max.y-h.y)*d,a=(e.min.y-h.y)*d),n>a||s>i||((s>n||n!==n)&&(n=s),(a<i||i!==i)&&(i=a),u>=0?(o=(e.min.z-h.z)*u,l=(e.max.z-h.z)*u):(o=(e.max.z-h.z)*u,l=(e.min.z-h.z)*u),n>l||o>i)||((o>n||n!==n)&&(n=o),(l<i||i!==i)&&(i=l),i<0)?null:this.at(n>=0?n:i,t)}intersectsBox(e){return this.intersectBox(e,Un)!==null}intersectTriangle(e,t,n,i,s){eo.subVectors(t,e),Fr.subVectors(n,e),to.crossVectors(eo,Fr);let a=this.direction.dot(to),o;if(a>0){if(i)return null;o=1}else if(a<0)o=-1,a=-a;else return null;ni.subVectors(this.origin,e);const l=o*this.direction.dot(Fr.crossVectors(ni,Fr));if(l<0)return null;const c=o*this.direction.dot(eo.cross(ni));if(c<0||l+c>a)return null;const d=-o*ni.dot(to);return d<0?null:this.at(d/a,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Ve{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,s,a,o,l,c,d,u,h,m,_,v,y){const p=this.elements;return p[0]=e,p[4]=t,p[8]=n,p[12]=i,p[1]=s,p[5]=a,p[9]=o,p[13]=l,p[2]=c,p[6]=d,p[10]=u,p[14]=h,p[3]=m,p[7]=_,p[11]=v,p[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Ve().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/Zi.setFromMatrixColumn(e,0).length(),s=1/Zi.setFromMatrixColumn(e,1).length(),a=1/Zi.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*s,t[5]=n[5]*s,t[6]=n[6]*s,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,i=e.y,s=e.z,a=Math.cos(n),o=Math.sin(n),l=Math.cos(i),c=Math.sin(i),d=Math.cos(s),u=Math.sin(s);if(e.order==="XYZ"){const h=a*d,m=a*u,_=o*d,v=o*u;t[0]=l*d,t[4]=-l*u,t[8]=c,t[1]=m+_*c,t[5]=h-v*c,t[9]=-o*l,t[2]=v-h*c,t[6]=_+m*c,t[10]=a*l}else if(e.order==="YXZ"){const h=l*d,m=l*u,_=c*d,v=c*u;t[0]=h+v*o,t[4]=_*o-m,t[8]=a*c,t[1]=a*u,t[5]=a*d,t[9]=-o,t[2]=m*o-_,t[6]=v+h*o,t[10]=a*l}else if(e.order==="ZXY"){const h=l*d,m=l*u,_=c*d,v=c*u;t[0]=h-v*o,t[4]=-a*u,t[8]=_+m*o,t[1]=m+_*o,t[5]=a*d,t[9]=v-h*o,t[2]=-a*c,t[6]=o,t[10]=a*l}else if(e.order==="ZYX"){const h=a*d,m=a*u,_=o*d,v=o*u;t[0]=l*d,t[4]=_*c-m,t[8]=h*c+v,t[1]=l*u,t[5]=v*c+h,t[9]=m*c-_,t[2]=-c,t[6]=o*l,t[10]=a*l}else if(e.order==="YZX"){const h=a*l,m=a*c,_=o*l,v=o*c;t[0]=l*d,t[4]=v-h*u,t[8]=_*u+m,t[1]=u,t[5]=a*d,t[9]=-o*d,t[2]=-c*d,t[6]=m*u+_,t[10]=h-v*u}else if(e.order==="XZY"){const h=a*l,m=a*c,_=o*l,v=o*c;t[0]=l*d,t[4]=-u,t[8]=c*d,t[1]=h*u+v,t[5]=a*d,t[9]=m*u-_,t[2]=_*u-m,t[6]=o*d,t[10]=v*u+h}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Hp,e,Gp)}lookAt(e,t,n){const i=this.elements;return rn.subVectors(e,t),rn.lengthSq()===0&&(rn.z=1),rn.normalize(),ii.crossVectors(n,rn),ii.lengthSq()===0&&(Math.abs(n.z)===1?rn.x+=1e-4:rn.z+=1e-4,rn.normalize(),ii.crossVectors(n,rn)),ii.normalize(),Br.crossVectors(rn,ii),i[0]=ii.x,i[4]=Br.x,i[8]=rn.x,i[1]=ii.y,i[5]=Br.y,i[9]=rn.y,i[2]=ii.z,i[6]=Br.z,i[10]=rn.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,s=this.elements,a=n[0],o=n[4],l=n[8],c=n[12],d=n[1],u=n[5],h=n[9],m=n[13],_=n[2],v=n[6],y=n[10],p=n[14],f=n[3],b=n[7],M=n[11],S=n[15],x=i[0],I=i[4],V=i[8],Y=i[12],j=i[1],G=i[5],q=i[9],C=i[13],W=i[2],z=i[6],E=i[10],N=i[14],K=i[3],J=i[7],T=i[11],O=i[15];return s[0]=a*x+o*j+l*W+c*K,s[4]=a*I+o*G+l*z+c*J,s[8]=a*V+o*q+l*E+c*T,s[12]=a*Y+o*C+l*N+c*O,s[1]=d*x+u*j+h*W+m*K,s[5]=d*I+u*G+h*z+m*J,s[9]=d*V+u*q+h*E+m*T,s[13]=d*Y+u*C+h*N+m*O,s[2]=_*x+v*j+y*W+p*K,s[6]=_*I+v*G+y*z+p*J,s[10]=_*V+v*q+y*E+p*T,s[14]=_*Y+v*C+y*N+p*O,s[3]=f*x+b*j+M*W+S*K,s[7]=f*I+b*G+M*z+S*J,s[11]=f*V+b*q+M*E+S*T,s[15]=f*Y+b*C+M*N+S*O,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],s=e[12],a=e[1],o=e[5],l=e[9],c=e[13],d=e[2],u=e[6],h=e[10],m=e[14],_=e[3],v=e[7],y=e[11],p=e[15];return _*(+s*l*u-i*c*u-s*o*h+n*c*h+i*o*m-n*l*m)+v*(+t*l*m-t*c*h+s*a*h-i*a*m+i*c*d-s*l*d)+y*(+t*c*u-t*o*m-s*a*u+n*a*m+s*o*d-n*c*d)+p*(-i*o*d-t*l*u+t*o*h+i*a*u-n*a*h+n*l*d)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],a=e[4],o=e[5],l=e[6],c=e[7],d=e[8],u=e[9],h=e[10],m=e[11],_=e[12],v=e[13],y=e[14],p=e[15],f=u*y*c-v*h*c+v*l*m-o*y*m-u*l*p+o*h*p,b=_*h*c-d*y*c-_*l*m+a*y*m+d*l*p-a*h*p,M=d*v*c-_*u*c+_*o*m-a*v*m-d*o*p+a*u*p,S=_*u*l-d*v*l-_*o*h+a*v*h+d*o*y-a*u*y,x=t*f+n*b+i*M+s*S;if(x===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const I=1/x;return e[0]=f*I,e[1]=(v*h*s-u*y*s-v*i*m+n*y*m+u*i*p-n*h*p)*I,e[2]=(o*y*s-v*l*s+v*i*c-n*y*c-o*i*p+n*l*p)*I,e[3]=(u*l*s-o*h*s-u*i*c+n*h*c+o*i*m-n*l*m)*I,e[4]=b*I,e[5]=(d*y*s-_*h*s+_*i*m-t*y*m-d*i*p+t*h*p)*I,e[6]=(_*l*s-a*y*s-_*i*c+t*y*c+a*i*p-t*l*p)*I,e[7]=(a*h*s-d*l*s+d*i*c-t*h*c-a*i*m+t*l*m)*I,e[8]=M*I,e[9]=(_*u*s-d*v*s-_*n*m+t*v*m+d*n*p-t*u*p)*I,e[10]=(a*v*s-_*o*s+_*n*c-t*v*c-a*n*p+t*o*p)*I,e[11]=(d*o*s-a*u*s-d*n*c+t*u*c+a*n*m-t*o*m)*I,e[12]=S*I,e[13]=(d*v*i-_*u*i+_*n*h-t*v*h-d*n*y+t*u*y)*I,e[14]=(_*o*i-a*v*i-_*n*l+t*v*l+a*n*y-t*o*y)*I,e[15]=(a*u*i-d*o*i+d*n*l-t*u*l-a*n*h+t*o*h)*I,this}scale(e){const t=this.elements,n=e.x,i=e.y,s=e.z;return t[0]*=n,t[4]*=i,t[8]*=s,t[1]*=n,t[5]*=i,t[9]*=s,t[2]*=n,t[6]*=i,t[10]*=s,t[3]*=n,t[7]*=i,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),s=1-n,a=e.x,o=e.y,l=e.z,c=s*a,d=s*o;return this.set(c*a+n,c*o-i*l,c*l+i*o,0,c*o+i*l,d*o+n,d*l-i*a,0,c*l-i*o,d*l+i*a,s*l*l+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n){return this.set(1,t,n,0,e,1,n,0,e,t,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,s=t._x,a=t._y,o=t._z,l=t._w,c=s+s,d=a+a,u=o+o,h=s*c,m=s*d,_=s*u,v=a*d,y=a*u,p=o*u,f=l*c,b=l*d,M=l*u,S=n.x,x=n.y,I=n.z;return i[0]=(1-(v+p))*S,i[1]=(m+M)*S,i[2]=(_-b)*S,i[3]=0,i[4]=(m-M)*x,i[5]=(1-(h+p))*x,i[6]=(y+f)*x,i[7]=0,i[8]=(_+b)*I,i[9]=(y-f)*I,i[10]=(1-(h+v))*I,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let s=Zi.set(i[0],i[1],i[2]).length();const a=Zi.set(i[4],i[5],i[6]).length(),o=Zi.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),e.x=i[12],e.y=i[13],e.z=i[14],_n.copy(this);const c=1/s,d=1/a,u=1/o;return _n.elements[0]*=c,_n.elements[1]*=c,_n.elements[2]*=c,_n.elements[4]*=d,_n.elements[5]*=d,_n.elements[6]*=d,_n.elements[8]*=u,_n.elements[9]*=u,_n.elements[10]*=u,t.setFromRotationMatrix(_n),n.x=s,n.y=a,n.z=o,this}makePerspective(e,t,n,i,s,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,l=2*s/(t-e),c=2*s/(n-i),d=(t+e)/(t-e),u=(n+i)/(n-i),h=-(a+s)/(a-s),m=-2*a*s/(a-s);return o[0]=l,o[4]=0,o[8]=d,o[12]=0,o[1]=0,o[5]=c,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=h,o[14]=m,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(e,t,n,i,s,a){const o=this.elements,l=1/(t-e),c=1/(n-i),d=1/(a-s),u=(t+e)*l,h=(n+i)*c,m=(a+s)*d;return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*c,o[9]=0,o[13]=-h,o[2]=0,o[6]=0,o[10]=-2*d,o[14]=-m,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}Ve.prototype.isMatrix4=!0;const Zi=new P,_n=new Ve,Hp=new P(0,0,0),Gp=new P(1,1,1),ii=new P,Br=new P,rn=new P,pc=new Ve,mc=new Ht;class ki{constructor(e=0,t=0,n=0,i=ki.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._order=i||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,n){const i=e.elements,s=i[0],a=i[4],o=i[8],l=i[1],c=i[5],d=i[9],u=i[2],h=i[6],m=i[10];switch(t=t||this._order,t){case"XYZ":this._y=Math.asin(Kt(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-d,m),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(h,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Kt(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(o,m),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-u,s),this._z=0);break;case"ZXY":this._x=Math.asin(Kt(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-u,m),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-Kt(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(h,m),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(Kt(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-d,c),this._y=Math.atan2(-u,s)):(this._x=0,this._y=Math.atan2(o,m));break;case"XZY":this._z=Math.asin(-Kt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(h,c),this._y=Math.atan2(o,s)):(this._x=Math.atan2(-d,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n!==!1&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return pc.makeRotationFromQuaternion(e),this.setFromRotationMatrix(pc,t,n)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return mc.setFromEuler(this),this.setFromQuaternion(mc,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new P(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}ki.prototype.isEuler=!0;ki.DefaultOrder="XYZ";ki.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Xd{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}}let Vp=0;const gc=new P,Ki=new Ht,Hn=new Ve,kr=new P,Vs=new P,Wp=new P,qp=new Ht,yc=new P(1,0,0),_c=new P(0,1,0),vc=new P(0,0,1),$p={type:"added"},xc={type:"removed"};class ht extends xi{constructor(){super(),Object.defineProperty(this,"id",{value:Vp++}),this.uuid=mn(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ht.DefaultUp.clone();const e=new P,t=new ki,n=new Ht,i=new P(1,1,1);function s(){n.setFromEuler(t,!1)}function a(){t.setFromQuaternion(n,void 0,!1)}t._onChange(s),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Ve},normalMatrix:{value:new Ut}}),this.matrix=new Ve,this.matrixWorld=new Ve,this.matrixAutoUpdate=ht.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Xd,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Ki.setFromAxisAngle(e,t),this.quaternion.multiply(Ki),this}rotateOnWorldAxis(e,t){return Ki.setFromAxisAngle(e,t),this.quaternion.premultiply(Ki),this}rotateX(e){return this.rotateOnAxis(yc,e)}rotateY(e){return this.rotateOnAxis(_c,e)}rotateZ(e){return this.rotateOnAxis(vc,e)}translateOnAxis(e,t){return gc.copy(e).applyQuaternion(this.quaternion),this.position.add(gc.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(yc,e)}translateY(e){return this.translateOnAxis(_c,e)}translateZ(e){return this.translateOnAxis(vc,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(Hn.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?kr.copy(e):kr.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Vs.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Hn.lookAt(Vs,kr,this.up):Hn.lookAt(kr,Vs,this.up),this.quaternion.setFromRotationMatrix(Hn),i&&(Hn.extractRotation(i.matrixWorld),Ki.setFromRotationMatrix(Hn),this.quaternion.premultiply(Ki.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent($p)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(xc)),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(xc)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),Hn.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Hn.multiply(e.parent.matrixWorld)),e.applyMatrix4(Hn),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(e,t);if(a!==void 0)return a}}getWorldPosition(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new P),this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new Ht),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Vs,e,Wp),e}getWorldScale(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new P),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Vs,qp,e),e}getWorldDirection(e){e===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new P),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function s(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(e)),l.uuid}if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let c=0,d=l.length;c<d;c++){const u=l[c];s(e.shapes,u)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,c=this.material.length;l<c;l++)o.push(s(e.materials,this.material[l]));i.material=o}else i.material=s(e.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];i.animations.push(s(e.animations,l))}}if(t){const o=a(e.geometries),l=a(e.materials),c=a(e.textures),d=a(e.images),u=a(e.shapes),h=a(e.skeletons),m=a(e.animations);o.length>0&&(n.geometries=o),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),d.length>0&&(n.images=d),u.length>0&&(n.shapes=u),h.length>0&&(n.skeletons=h),m.length>0&&(n.animations=m)}return n.object=i,n;function a(o){const l=[];for(const c in o){const d=o[c];delete d.metadata,l.push(d)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}}ht.DefaultUp=new P(0,1,0);ht.DefaultMatrixAutoUpdate=!0;ht.prototype.isObject3D=!0;const no=new P,Xp=new P,jp=new Ut;class Dn{constructor(e=new P(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=no.subVectors(n,t).cross(Xp.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new P),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){t===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new P);const n=e.delta(no),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:t.copy(n).multiplyScalar(s).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new P),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||jp.getNormalMatrix(e),i=this.coplanarPoint(no).applyMatrix4(e),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}Dn.prototype.isPlane=!0;const vn=new P,Gn=new P,io=new P,Vn=new P,Ji=new P,Qi=new P,bc=new P,so=new P,ro=new P,ao=new P;class Dt{constructor(e=new P,t=new P,n=new P){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),i=new P),i.subVectors(n,t),vn.subVectors(e,t),i.cross(vn);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(e,t,n,i,s){vn.subVectors(i,t),Gn.subVectors(n,t),io.subVectors(e,t);const a=vn.dot(vn),o=vn.dot(Gn),l=vn.dot(io),c=Gn.dot(Gn),d=Gn.dot(io),u=a*c-o*o;if(s===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),s=new P),u===0)return s.set(-2,-1,-1);const h=1/u,m=(c*l-o*d)*h,_=(a*d-o*l)*h;return s.set(1-m-_,_,m)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,Vn),Vn.x>=0&&Vn.y>=0&&Vn.x+Vn.y<=1}static getUV(e,t,n,i,s,a,o,l){return this.getBarycoord(e,t,n,i,Vn),l.set(0,0),l.addScaledVector(s,Vn.x),l.addScaledVector(a,Vn.y),l.addScaledVector(o,Vn.z),l}static isFrontFacing(e,t,n,i){return vn.subVectors(n,t),Gn.subVectors(e,t),vn.cross(Gn).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return vn.subVectors(this.c,this.b),Gn.subVectors(this.a,this.b),vn.cross(Gn).length()*.5}getMidpoint(e){return e===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new P),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Dt.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new Dn),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Dt.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,s){return Dt.getUV(e,this.a,this.b,this.c,t,n,i,s)}containsPoint(e){return Dt.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Dt.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new P);const n=this.a,i=this.b,s=this.c;let a,o;Ji.subVectors(i,n),Qi.subVectors(s,n),so.subVectors(e,n);const l=Ji.dot(so),c=Qi.dot(so);if(l<=0&&c<=0)return t.copy(n);ro.subVectors(e,i);const d=Ji.dot(ro),u=Qi.dot(ro);if(d>=0&&u<=d)return t.copy(i);const h=l*u-d*c;if(h<=0&&l>=0&&d<=0)return a=l/(l-d),t.copy(n).addScaledVector(Ji,a);ao.subVectors(e,s);const m=Ji.dot(ao),_=Qi.dot(ao);if(_>=0&&m<=_)return t.copy(s);const v=m*c-l*_;if(v<=0&&c>=0&&_<=0)return o=c/(c-_),t.copy(n).addScaledVector(Qi,o);const y=d*_-m*u;if(y<=0&&u-d>=0&&m-_>=0)return bc.subVectors(s,i),o=(u-d)/(u-d+(m-_)),t.copy(i).addScaledVector(bc,o);const p=1/(y+v+h);return a=v*p,o=h*p,t.copy(n).addScaledVector(Ji,a).addScaledVector(Qi,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let Yp=0;function Ct(){Object.defineProperty(this,"id",{value:Yp++}),this.uuid=mn(),this.name="",this.type="Material",this.fog=!0,this.blending=sr,this.side=xr,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=Fd,this.blendDst=Bd,this.blendEquation=ps,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Po,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Sp,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=$a,this.stencilZFail=$a,this.stencilZPass=$a,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}Ct.prototype=Object.assign(Object.create(xi.prototype),{constructor:Ct,isMaterial:!0,onBuild:function(){},onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(r){if(r!==void 0)for(const e in r){const t=r[e];if(t===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=t===Nd;continue}const n=this[e];if(n===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}n&&n.isColor?n.set(t):n&&n.isVector3&&t&&t.isVector3?n.copy(t):this[e]=t}},toJSON:function(r){const e=r===void 0||typeof r=="string";e&&(r={textures:{},images:{}});const t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),this.roughness!==void 0&&(t.roughness=this.roughness),this.metalness!==void 0&&(t.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(t.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),this.shininess!==void 0&&(t.shininess=this.shininess),this.clearcoat!==void 0&&(t.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(r).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(r).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(r).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(r).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(r).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(r).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(r).uuid,t.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(r).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(r).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(r).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(r).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(r).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(r).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(r).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(r).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(r).uuid,this.combine!==void 0&&(t.combine=this.combine)),this.envMapIntensity!==void 0&&(t.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(t.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(t.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(r).uuid),this.size!==void 0&&(t.size=this.size),this.shadowSide!==null&&(t.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==sr&&(t.blending=this.blending),this.side!==xr&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),this.transparent===!0&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.colorWrite=this.colorWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(t.rotation=this.rotation),this.polygonOffset===!0&&(t.polygonOffset=!0),this.polygonOffsetFactor!==0&&(t.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(t.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(t.linewidth=this.linewidth),this.dashSize!==void 0&&(t.dashSize=this.dashSize),this.gapSize!==void 0&&(t.gapSize=this.gapSize),this.scale!==void 0&&(t.scale=this.scale),this.dithering===!0&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(t.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(t.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(t.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(t.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(t.morphTargets=!0),this.morphNormals===!0&&(t.morphNormals=!0),this.skinning===!0&&(t.skinning=!0),this.flatShading===!0&&(t.flatShading=this.flatShading),this.visible===!1&&(t.visible=!1),this.toneMapped===!1&&(t.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(t.userData=this.userData);function n(i){const s=[];for(const a in i){const o=i[a];delete o.metadata,s.push(o)}return s}if(e){const i=n(r.textures),s=n(r.images);i.length>0&&(t.textures=i),s.length>0&&(t.images=s)}return t},clone:function(){return new this.constructor().copy(this)},copy:function(r){this.name=r.name,this.fog=r.fog,this.blending=r.blending,this.side=r.side,this.vertexColors=r.vertexColors,this.opacity=r.opacity,this.transparent=r.transparent,this.blendSrc=r.blendSrc,this.blendDst=r.blendDst,this.blendEquation=r.blendEquation,this.blendSrcAlpha=r.blendSrcAlpha,this.blendDstAlpha=r.blendDstAlpha,this.blendEquationAlpha=r.blendEquationAlpha,this.depthFunc=r.depthFunc,this.depthTest=r.depthTest,this.depthWrite=r.depthWrite,this.stencilWriteMask=r.stencilWriteMask,this.stencilFunc=r.stencilFunc,this.stencilRef=r.stencilRef,this.stencilFuncMask=r.stencilFuncMask,this.stencilFail=r.stencilFail,this.stencilZFail=r.stencilZFail,this.stencilZPass=r.stencilZPass,this.stencilWrite=r.stencilWrite;const e=r.clippingPlanes;let t=null;if(e!==null){const n=e.length;t=new Array(n);for(let i=0;i!==n;++i)t[i]=e[i].clone()}return this.clippingPlanes=t,this.clipIntersection=r.clipIntersection,this.clipShadows=r.clipShadows,this.shadowSide=r.shadowSide,this.colorWrite=r.colorWrite,this.precision=r.precision,this.polygonOffset=r.polygonOffset,this.polygonOffsetFactor=r.polygonOffsetFactor,this.polygonOffsetUnits=r.polygonOffsetUnits,this.dithering=r.dithering,this.alphaTest=r.alphaTest,this.alphaToCoverage=r.alphaToCoverage,this.premultipliedAlpha=r.premultipliedAlpha,this.visible=r.visible,this.toneMapped=r.toneMapped,this.userData=JSON.parse(JSON.stringify(r.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(Ct.prototype,"needsUpdate",{set:function(r){r===!0&&this.version++}});const jd={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},xn={h:0,s:0,l:0},Or={h:0,s:0,l:0};function oo(r,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?r+(e-r)*6*t:t<1/2?e:t<2/3?r+(e-r)*6*(2/3-t):r}function lo(r){return r<.04045?r*.0773993808:Math.pow(r*.9478672986+.0521327014,2.4)}function co(r){return r<.0031308?r*12.92:1.055*Math.pow(r,.41666)-.055}class ke{constructor(e,t,n){return t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=Jo(e,1),t=Kt(t,0,1),n=Kt(n,0,1),t===0)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+t):n+t-n*t,s=2*n-i;this.r=oo(s,i,e+1/3),this.g=oo(s,i,e),this.b=oo(s,i,e-1/3)}return this}setStyle(e){function t(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let i;const s=n[1],a=n[2];switch(s){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,t(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,t(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const o=parseFloat(i[1])/360,l=parseInt(i[2],10)/100,c=parseInt(i[3],10)/100;return t(i[4]),this.setHSL(o,l,c)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(e)){const i=n[1],s=i.length;if(s===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=jd[e.toLowerCase()];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=lo(e.r),this.g=lo(e.g),this.b=lo(e.b),this}copyLinearToSRGB(e){return this.r=co(e.r),this.g=co(e.g),this.b=co(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){e===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,n=this.g,i=this.b,s=Math.max(t,n,i),a=Math.min(t,n,i);let o,l;const c=(a+s)/2;if(a===s)o=0,l=0;else{const d=s-a;switch(l=c<=.5?d/(s+a):d/(2-s-a),s){case t:o=(n-i)/d+(n<i?6:0);break;case n:o=(i-t)/d+2;break;case i:o=(t-n)/d+4;break}o/=6}return e.h=o,e.s=l,e.l=c,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,n){return this.getHSL(xn),xn.h+=e,xn.s+=t,xn.l+=n,this.setHSL(xn.h,xn.s,xn.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(xn),e.getHSL(Or);const n=or(xn.h,Or.h,t),i=or(xn.s,Or.s,t),s=or(xn.l,Or.l,t);return this.setHSL(n,i,s),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}ke.NAMES=jd;ke.prototype.isColor=!0;ke.prototype.r=1;ke.prototype.g=1;ke.prototype.b=1;class wn extends Ct{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new ke(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ga,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this}}wn.prototype.isMeshBasicMaterial=!0;const xt=new P,zr=new Ae;class Tt{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=hr,this.updateRange={offset:0,count:-1},this.version=0,this.onUploadCallback=function(){}}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let i=0,s=e.length;i<s;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),a=new ke),t[n++]=a.r,t[n++]=a.g,t[n++]=a.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let i=0,s=e.length;i<s;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),a=new Ae),t[n++]=a.x,t[n++]=a.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let i=0,s=e.length;i<s;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),a=new P),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let i=0,s=e.length;i<s;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),a=new gt),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z,t[n++]=a.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)zr.fromBufferAttribute(this,t),zr.applyMatrix3(e),this.setXY(t,zr.x,zr.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)xt.fromBufferAttribute(this,t),xt.applyMatrix3(e),this.setXYZ(t,xt.x,xt.y,xt.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)xt.x=this.getX(t),xt.y=this.getY(t),xt.z=this.getZ(t),xt.applyMatrix4(e),this.setXYZ(t,xt.x,xt.y,xt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)xt.x=this.getX(t),xt.y=this.getY(t),xt.z=this.getZ(t),xt.applyNormalMatrix(e),this.setXYZ(t,xt.x,xt.y,xt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)xt.x=this.getX(t),xt.y=this.getY(t),xt.z=this.getZ(t),xt.transformDirection(e),this.setXYZ(t,xt.x,xt.y,xt.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,s){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==hr&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}Tt.prototype.isBufferAttribute=!0;class Yd extends Tt{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class Zd extends Tt{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class Zp extends Tt{constructor(e,t,n){super(new Uint16Array(e),t,n)}}Zp.prototype.isFloat16BufferAttribute=!0;class Rt extends Tt{constructor(e,t,n){super(new Float32Array(e),t,n)}}function Kd(r){if(r.length===0)return-1/0;let e=r[0];for(let t=1,n=r.length;t<n;++t)r[t]>e&&(e=r[t]);return e}let Kp=0;const Cn=new Ve,uo=new ht,es=new P,an=new on,Ws=new on,Nt=new P;class pt extends xi{constructor(){super(),Object.defineProperty(this,"id",{value:Kp++}),this.uuid=mn(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(Kd(e)>65535?Zd:Yd)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new Ut().getNormalMatrix(e);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}rotateX(e){return Cn.makeRotationX(e),this.applyMatrix4(Cn),this}rotateY(e){return Cn.makeRotationY(e),this.applyMatrix4(Cn),this}rotateZ(e){return Cn.makeRotationZ(e),this.applyMatrix4(Cn),this}translate(e,t,n){return Cn.makeTranslation(e,t,n),this.applyMatrix4(Cn),this}scale(e,t,n){return Cn.makeScale(e,t,n),this.applyMatrix4(Cn),this}lookAt(e){return uo.lookAt(e),uo.updateMatrix(),this.applyMatrix4(uo.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(es).negate(),this.translate(es.x,es.y,es.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const s=e[n];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new Rt(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new on);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new P(-1/0,-1/0,-1/0),new P(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const s=t[n];an.setFromBufferAttribute(s),this.morphTargetsRelative?(Nt.addVectors(this.boundingBox.min,an.min),this.boundingBox.expandByPoint(Nt),Nt.addVectors(this.boundingBox.max,an.max),this.boundingBox.expandByPoint(Nt)):(this.boundingBox.expandByPoint(an.min),this.boundingBox.expandByPoint(an.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Fi);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new P,1/0);return}if(e){const n=this.boundingSphere.center;if(an.setFromBufferAttribute(e),t)for(let s=0,a=t.length;s<a;s++){const o=t[s];Ws.setFromBufferAttribute(o),this.morphTargetsRelative?(Nt.addVectors(an.min,Ws.min),an.expandByPoint(Nt),Nt.addVectors(an.max,Ws.max),an.expandByPoint(Nt)):(an.expandByPoint(Ws.min),an.expandByPoint(Ws.max))}an.getCenter(n);let i=0;for(let s=0,a=e.count;s<a;s++)Nt.fromBufferAttribute(e,s),i=Math.max(i,n.distanceToSquared(Nt));if(t)for(let s=0,a=t.length;s<a;s++){const o=t[s],l=this.morphTargetsRelative;for(let c=0,d=o.count;c<d;c++)Nt.fromBufferAttribute(o,c),l&&(es.fromBufferAttribute(e,c),Nt.add(es)),i=Math.max(i,n.distanceToSquared(Nt))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeFaceNormals(){}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array,i=t.position.array,s=t.normal.array,a=t.uv.array,o=i.length/3;t.tangent===void 0&&this.setAttribute("tangent",new Tt(new Float32Array(4*o),4));const l=t.tangent.array,c=[],d=[];for(let j=0;j<o;j++)c[j]=new P,d[j]=new P;const u=new P,h=new P,m=new P,_=new Ae,v=new Ae,y=new Ae,p=new P,f=new P;function b(j,G,q){u.fromArray(i,j*3),h.fromArray(i,G*3),m.fromArray(i,q*3),_.fromArray(a,j*2),v.fromArray(a,G*2),y.fromArray(a,q*2),h.sub(u),m.sub(u),v.sub(_),y.sub(_);const C=1/(v.x*y.y-y.x*v.y);isFinite(C)&&(p.copy(h).multiplyScalar(y.y).addScaledVector(m,-v.y).multiplyScalar(C),f.copy(m).multiplyScalar(v.x).addScaledVector(h,-y.x).multiplyScalar(C),c[j].add(p),c[G].add(p),c[q].add(p),d[j].add(f),d[G].add(f),d[q].add(f))}let M=this.groups;M.length===0&&(M=[{start:0,count:n.length}]);for(let j=0,G=M.length;j<G;++j){const q=M[j],C=q.start,W=q.count;for(let z=C,E=C+W;z<E;z+=3)b(n[z+0],n[z+1],n[z+2])}const S=new P,x=new P,I=new P,V=new P;function Y(j){I.fromArray(s,j*3),V.copy(I);const G=c[j];S.copy(G),S.sub(I.multiplyScalar(I.dot(G))).normalize(),x.crossVectors(V,G);const C=x.dot(d[j])<0?-1:1;l[j*4]=S.x,l[j*4+1]=S.y,l[j*4+2]=S.z,l[j*4+3]=C}for(let j=0,G=M.length;j<G;++j){const q=M[j],C=q.start,W=q.count;for(let z=C,E=C+W;z<E;z+=3)Y(n[z+0]),Y(n[z+1]),Y(n[z+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Tt(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let h=0,m=n.count;h<m;h++)n.setXYZ(h,0,0,0);const i=new P,s=new P,a=new P,o=new P,l=new P,c=new P,d=new P,u=new P;if(e)for(let h=0,m=e.count;h<m;h+=3){const _=e.getX(h+0),v=e.getX(h+1),y=e.getX(h+2);i.fromBufferAttribute(t,_),s.fromBufferAttribute(t,v),a.fromBufferAttribute(t,y),d.subVectors(a,s),u.subVectors(i,s),d.cross(u),o.fromBufferAttribute(n,_),l.fromBufferAttribute(n,v),c.fromBufferAttribute(n,y),o.add(d),l.add(d),c.add(d),n.setXYZ(_,o.x,o.y,o.z),n.setXYZ(v,l.x,l.y,l.z),n.setXYZ(y,c.x,c.y,c.z)}else for(let h=0,m=t.count;h<m;h+=3)i.fromBufferAttribute(t,h+0),s.fromBufferAttribute(t,h+1),a.fromBufferAttribute(t,h+2),d.subVectors(a,s),u.subVectors(i,s),d.cross(u),n.setXYZ(h+0,d.x,d.y,d.z),n.setXYZ(h+1,d.x,d.y,d.z),n.setXYZ(h+2,d.x,d.y,d.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(e.attributes[i]===void 0)continue;const a=n[i].array,o=e.attributes[i],l=o.array,c=o.itemSize*t,d=Math.min(l.length,a.length-c);for(let u=0,h=c;u<d;u++,h++)a[h]=l[u]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Nt.fromBufferAttribute(e,t),Nt.normalize(),e.setXYZ(t,Nt.x,Nt.y,Nt.z)}toNonIndexed(){function e(o,l){const c=o.array,d=o.itemSize,u=o.normalized,h=new c.constructor(l.length*d);let m=0,_=0;for(let v=0,y=l.length;v<y;v++){m=l[v]*d;for(let p=0;p<d;p++)h[_++]=c[m++]}return new Tt(h,d,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new pt,n=this.index.array,i=this.attributes;for(const o in i){const l=i[o],c=e(l,n);t.setAttribute(o,c)}const s=this.morphAttributes;for(const o in s){const l=[],c=s[o];for(let d=0,u=c.length;d<u;d++){const h=c[d],m=e(h,n);l.push(m)}t.morphAttributes[o]=l}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,l=a.length;o<l;o++){const c=a[o];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const l in n){const c=n[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let s=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],d=[];for(let u=0,h=c.length;u<h;u++){const m=c[u];d.push(m.toJSON(e.data))}d.length>0&&(i[l]=d,s=!0)}s&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new pt().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const c in i){const d=i[c];this.setAttribute(c,d.clone(t))}const s=e.morphAttributes;for(const c in s){const d=[],u=s[c];for(let h=0,m=u.length;h<m;h++)d.push(u[h].clone(t));this.morphAttributes[c]=d}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let c=0,d=a.length;c<d;c++){const u=a[c];this.addGroup(u.start,u.count,u.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}pt.prototype.isBufferGeometry=!0;const wc=new Ve,ts=new Bi,ho=new Fi,si=new P,ri=new P,ai=new P,fo=new P,po=new P,mo=new P,Ur=new P,Hr=new P,Gr=new P,Vr=new Ae,Wr=new Ae,qr=new Ae,go=new P,$r=new P;class dt extends ht{constructor(e=new pt,t=new wn){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const n=this.geometry,i=this.material,s=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),ho.copy(n.boundingSphere),ho.applyMatrix4(s),e.ray.intersectsSphere(ho)===!1)||(wc.copy(s).invert(),ts.copy(e.ray).applyMatrix4(wc),n.boundingBox!==null&&ts.intersectsBox(n.boundingBox)===!1))return;let a;if(n.isBufferGeometry){const o=n.index,l=n.attributes.position,c=n.morphAttributes.position,d=n.morphTargetsRelative,u=n.attributes.uv,h=n.attributes.uv2,m=n.groups,_=n.drawRange;if(o!==null)if(Array.isArray(i))for(let v=0,y=m.length;v<y;v++){const p=m[v],f=i[p.materialIndex],b=Math.max(p.start,_.start),M=Math.min(p.start+p.count,_.start+_.count);for(let S=b,x=M;S<x;S+=3){const I=o.getX(S),V=o.getX(S+1),Y=o.getX(S+2);a=Xr(this,f,e,ts,l,c,d,u,h,I,V,Y),a&&(a.faceIndex=Math.floor(S/3),a.face.materialIndex=p.materialIndex,t.push(a))}}else{const v=Math.max(0,_.start),y=Math.min(o.count,_.start+_.count);for(let p=v,f=y;p<f;p+=3){const b=o.getX(p),M=o.getX(p+1),S=o.getX(p+2);a=Xr(this,i,e,ts,l,c,d,u,h,b,M,S),a&&(a.faceIndex=Math.floor(p/3),t.push(a))}}else if(l!==void 0)if(Array.isArray(i))for(let v=0,y=m.length;v<y;v++){const p=m[v],f=i[p.materialIndex],b=Math.max(p.start,_.start),M=Math.min(p.start+p.count,_.start+_.count);for(let S=b,x=M;S<x;S+=3){const I=S,V=S+1,Y=S+2;a=Xr(this,f,e,ts,l,c,d,u,h,I,V,Y),a&&(a.faceIndex=Math.floor(S/3),a.face.materialIndex=p.materialIndex,t.push(a))}}else{const v=Math.max(0,_.start),y=Math.min(l.count,_.start+_.count);for(let p=v,f=y;p<f;p+=3){const b=p,M=p+1,S=p+2;a=Xr(this,i,e,ts,l,c,d,u,h,b,M,S),a&&(a.faceIndex=Math.floor(p/3),t.push(a))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}dt.prototype.isMesh=!0;function Jp(r,e,t,n,i,s,a,o){let l;if(e.side===Pt?l=n.intersectTriangle(a,s,i,!0,o):l=n.intersectTriangle(i,s,a,e.side!==yi,o),l===null)return null;$r.copy(o),$r.applyMatrix4(r.matrixWorld);const c=t.ray.origin.distanceTo($r);return c<t.near||c>t.far?null:{distance:c,point:$r.clone(),object:r}}function Xr(r,e,t,n,i,s,a,o,l,c,d,u){si.fromBufferAttribute(i,c),ri.fromBufferAttribute(i,d),ai.fromBufferAttribute(i,u);const h=r.morphTargetInfluences;if(e.morphTargets&&s&&h){Ur.set(0,0,0),Hr.set(0,0,0),Gr.set(0,0,0);for(let _=0,v=s.length;_<v;_++){const y=h[_],p=s[_];y!==0&&(fo.fromBufferAttribute(p,c),po.fromBufferAttribute(p,d),mo.fromBufferAttribute(p,u),a?(Ur.addScaledVector(fo,y),Hr.addScaledVector(po,y),Gr.addScaledVector(mo,y)):(Ur.addScaledVector(fo.sub(si),y),Hr.addScaledVector(po.sub(ri),y),Gr.addScaledVector(mo.sub(ai),y)))}si.add(Ur),ri.add(Hr),ai.add(Gr)}r.isSkinnedMesh&&e.skinning&&(r.boneTransform(c,si),r.boneTransform(d,ri),r.boneTransform(u,ai));const m=Jp(r,e,t,n,si,ri,ai,go);if(m){o&&(Vr.fromBufferAttribute(o,c),Wr.fromBufferAttribute(o,d),qr.fromBufferAttribute(o,u),m.uv=Dt.getUV(go,si,ri,ai,Vr,Wr,qr,new Ae)),l&&(Vr.fromBufferAttribute(l,c),Wr.fromBufferAttribute(l,d),qr.fromBufferAttribute(l,u),m.uv2=Dt.getUV(go,si,ri,ai,Vr,Wr,qr,new Ae));const _={a:c,b:d,c:u,normal:new P,materialIndex:0};Dt.getNormal(si,ri,ai,_.normal),m.face=_}return m}class _a extends pt{constructor(e=1,t=1,n=1,i=1,s=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:s,depthSegments:a};const o=this;i=Math.floor(i),s=Math.floor(s),a=Math.floor(a);const l=[],c=[],d=[],u=[];let h=0,m=0;_("z","y","x",-1,-1,n,t,e,a,s,0),_("z","y","x",1,-1,n,t,-e,a,s,1),_("x","z","y",1,1,e,n,t,i,a,2),_("x","z","y",1,-1,e,n,-t,i,a,3),_("x","y","z",1,-1,e,t,n,i,s,4),_("x","y","z",-1,-1,e,t,-n,i,s,5),this.setIndex(l),this.setAttribute("position",new Rt(c,3)),this.setAttribute("normal",new Rt(d,3)),this.setAttribute("uv",new Rt(u,2));function _(v,y,p,f,b,M,S,x,I,V,Y){const j=M/I,G=S/V,q=M/2,C=S/2,W=x/2,z=I+1,E=V+1;let N=0,K=0;const J=new P;for(let T=0;T<E;T++){const O=T*G-C;for(let H=0;H<z;H++){const ee=H*j-q;J[v]=ee*f,J[y]=O*b,J[p]=W,c.push(J.x,J.y,J.z),J[v]=0,J[y]=0,J[p]=x>0?1:-1,d.push(J.x,J.y,J.z),u.push(H/I),u.push(1-T/V),N+=1}}for(let T=0;T<V;T++)for(let O=0;O<I;O++){const H=h+O+z*T,ee=h+O+z*(T+1),B=h+(O+1)+z*(T+1),ne=h+(O+1)+z*T;l.push(H,ee,ne),l.push(ee,B,ne),K+=6}o.addGroup(m,K,Y),m+=K,h+=N}}}function Ts(r){const e={};for(const t in r){e[t]={};for(const n in r[t]){const i=r[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function qt(r){const e={};for(let t=0;t<r.length;t++){const n=Ts(r[t]);for(const i in n)e[i]=n[i]}return e}const Qp={clone:Ts,merge:qt};var em=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,tm=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Di extends Ct{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=em,this.fragmentShader=tm,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Ts(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?t.uniforms[i]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[i]={type:"m4",value:a.toArray()}:t.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}Di.prototype.isShaderMaterial=!0;class Qo extends ht{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Ve,this.projectionMatrix=new Ve,this.projectionMatrixInverse=new Ve}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){e===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new P),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Qo.prototype.isCamera=!0;class $t extends Qo{constructor(e=50,t=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=fr*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(ar*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return fr*2*Math.atan(Math.tan(ar*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,i,s,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(ar*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,s=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,c=a.fullHeight;s+=a.offsetX*i/l,t-=a.offsetY*n/c,i*=a.width/l,n*=a.height/c}const o=this.filmOffset;o!==0&&(s+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}$t.prototype.isPerspectiveCamera=!0;const ns=90,is=1;class el extends ht{constructor(e,t,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const i=new $t(ns,is,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new P(1,0,0)),this.add(i);const s=new $t(ns,is,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new P(-1,0,0)),this.add(s);const a=new $t(ns,is,e,t);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new P(0,1,0)),this.add(a);const o=new $t(ns,is,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new P(0,-1,0)),this.add(o);const l=new $t(ns,is,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new P(0,0,1)),this.add(l);const c=new $t(ns,is,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new P(0,0,-1)),this.add(c)}update(e,t){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,s,a,o,l,c]=this.children,d=e.xr.enabled,u=e.getRenderTarget();e.xr.enabled=!1;const h=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,i),e.setRenderTarget(n,1),e.render(t,s),e.setRenderTarget(n,2),e.render(t,a),e.setRenderTarget(n,3),e.render(t,o),e.setRenderTarget(n,4),e.render(t,l),n.texture.generateMipmaps=h,e.setRenderTarget(n,5),e.render(t,c),e.setRenderTarget(u),e.xr.enabled=d}}class va extends Bt{constructor(e,t,n,i,s,a,o,l,c,d){e=e!==void 0?e:[],t=t!==void 0?t:$o,o=o!==void 0?o:hi,super(e,t,n,i,s,a,o,l,c,d),this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}va.prototype.isCubeTexture=!0;class Jd extends fi{constructor(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),super(e,e,t),t=t||{},this.texture=new va(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:nn,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=pn,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new _a(5,5,5),s=new Di({name:"CubemapFromEquirect",uniforms:Ts(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:Pt,blending:ui});s.uniforms.tEquirect.value=t;const a=new dt(i,s),o=t.minFilter;return t.minFilter===br&&(t.minFilter=nn),new el(1,10,this).update(e,a),t.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,n,i){const s=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,n,i);e.setRenderTarget(s)}}Jd.prototype.isWebGLCubeRenderTarget=!0;class Qd extends Bt{constructor(e,t,n,i,s,a,o,l,c,d,u,h){super(null,a,o,l,c,d,i,s,u,h),this.image={data:e||null,width:t||1,height:n||1},this.magFilter=c!==void 0?c:Ft,this.minFilter=d!==void 0?d:Ft,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Qd.prototype.isDataTexture=!0;const ss=new Fi,jr=new P;class xa{constructor(e=new Dn,t=new Dn,n=new Dn,i=new Dn,s=new Dn,a=new Dn){this.planes=[e,t,n,i,s,a]}set(e,t,n,i,s,a){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(n),o[3].copy(i),o[4].copy(s),o[5].copy(a),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,i=n[0],s=n[1],a=n[2],o=n[3],l=n[4],c=n[5],d=n[6],u=n[7],h=n[8],m=n[9],_=n[10],v=n[11],y=n[12],p=n[13],f=n[14],b=n[15];return t[0].setComponents(o-i,u-l,v-h,b-y).normalize(),t[1].setComponents(o+i,u+l,v+h,b+y).normalize(),t[2].setComponents(o+s,u+c,v+m,b+p).normalize(),t[3].setComponents(o-s,u-c,v-m,b-p).normalize(),t[4].setComponents(o-a,u-d,v-_,b-f).normalize(),t[5].setComponents(o+a,u+d,v+_,b+f).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),ss.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(ss)}intersectsSprite(e){return ss.center.set(0,0,0),ss.radius=.7071067811865476,ss.applyMatrix4(e.matrixWorld),this.intersectsSphere(ss)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(jr.x=i.normal.x>0?e.max.x:e.min.x,jr.y=i.normal.y>0?e.max.y:e.min.y,jr.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(jr)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function eu(){let r=null,e=!1,t=null,n=null;function i(s,a){t(s,a),n=r.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=r.requestAnimationFrame(i),e=!0)},stop:function(){r.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){r=s}}}function nm(r,e){const t=e.isWebGL2,n=new WeakMap;function i(c,d){const u=c.array,h=c.usage,m=r.createBuffer();r.bindBuffer(d,m),r.bufferData(d,u,h),c.onUploadCallback();let _=5126;return u instanceof Float32Array?_=5126:u instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):u instanceof Uint16Array?c.isFloat16BufferAttribute?t?_=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):_=5123:u instanceof Int16Array?_=5122:u instanceof Uint32Array?_=5125:u instanceof Int32Array?_=5124:u instanceof Int8Array?_=5120:u instanceof Uint8Array&&(_=5121),{buffer:m,type:_,bytesPerElement:u.BYTES_PER_ELEMENT,version:c.version}}function s(c,d,u){const h=d.array,m=d.updateRange;r.bindBuffer(u,c),m.count===-1?r.bufferSubData(u,0,h):(t?r.bufferSubData(u,m.offset*h.BYTES_PER_ELEMENT,h,m.offset,m.count):r.bufferSubData(u,m.offset*h.BYTES_PER_ELEMENT,h.subarray(m.offset,m.offset+m.count)),m.count=-1)}function a(c){return c.isInterleavedBufferAttribute&&(c=c.data),n.get(c)}function o(c){c.isInterleavedBufferAttribute&&(c=c.data);const d=n.get(c);d&&(r.deleteBuffer(d.buffer),n.delete(c))}function l(c,d){if(c.isGLBufferAttribute){const h=n.get(c);(!h||h.version<c.version)&&n.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const u=n.get(c);u===void 0?n.set(c,i(c,d)):u.version<c.version&&(s(u.buffer,c,d),u.version=c.version)}return{get:a,remove:o,update:l}}class tl extends pt{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const s=e/2,a=t/2,o=Math.floor(n),l=Math.floor(i),c=o+1,d=l+1,u=e/o,h=t/l,m=[],_=[],v=[],y=[];for(let p=0;p<d;p++){const f=p*h-a;for(let b=0;b<c;b++){const M=b*u-s;_.push(M,-f,0),v.push(0,0,1),y.push(b/o),y.push(1-p/l)}}for(let p=0;p<l;p++)for(let f=0;f<o;f++){const b=f+c*p,M=f+c*(p+1),S=f+1+c*(p+1),x=f+1+c*p;m.push(b,M,x),m.push(M,S,x)}this.setIndex(m),this.setAttribute("position",new Rt(_,3)),this.setAttribute("normal",new Rt(v,3)),this.setAttribute("uv",new Rt(y,2))}}var im=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,sm=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,rm=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,am=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,om=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,lm="vec3 transformed = vec3( position );",cm=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,dm=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,um=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,hm=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,fm=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,pm=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,mm=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,gm=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,ym=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,_m=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,vm=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,xm=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,bm=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,wm=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Mm=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Sm=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Tm=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Em=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Am="gl_FragColor = linearToOutputTexel( gl_FragColor );",Lm=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,Rm=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Cm=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Im=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Pm=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Dm=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Nm=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,Fm=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,Bm=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,km=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Om=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,zm=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,Um=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Hm=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,Gm=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,Vm=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,Wm=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,qm=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,$m=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Xm=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,jm=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,Ym=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Zm=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,Km=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,Jm=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,Qm=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,eg=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,tg=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,ng=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,ig=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,sg=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,rg=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,ag=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,og=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,lg=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,cg=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,dg=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,ug=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,hg=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,fg=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,pg=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,mg=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,gg=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,yg=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,_g=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,vg=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,xg=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,bg=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,wg=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Mg=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Sg=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Tg=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Eg=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Ag=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Lg=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Rg=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Cg=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,Ig=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Pg=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Dg=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Ng=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Fg=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Bg=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,kg=`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,Og=`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,zg=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,Ug=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,Hg=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,Gg=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,Vg=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,Wg=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,qg=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,$g=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Xg=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,jg=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Yg=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Zg=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,Kg=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Jg=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Qg=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,ey=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,ty=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,ny=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,iy=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,sy=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,ry=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,ay=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,oy=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,ly=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,cy=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,dy=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,uy=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,hy=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,fy=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,py=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,my=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,gy=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,yy=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,_y=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vy=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,xy=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,by=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,wy=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,My=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const nt={alphamap_fragment:im,alphamap_pars_fragment:sm,alphatest_fragment:rm,aomap_fragment:am,aomap_pars_fragment:om,begin_vertex:lm,beginnormal_vertex:cm,bsdfs:dm,bumpmap_pars_fragment:um,clipping_planes_fragment:hm,clipping_planes_pars_fragment:fm,clipping_planes_pars_vertex:pm,clipping_planes_vertex:mm,color_fragment:gm,color_pars_fragment:ym,color_pars_vertex:_m,color_vertex:vm,common:xm,cube_uv_reflection_fragment:bm,defaultnormal_vertex:wm,displacementmap_pars_vertex:Mm,displacementmap_vertex:Sm,emissivemap_fragment:Tm,emissivemap_pars_fragment:Em,encodings_fragment:Am,encodings_pars_fragment:Lm,envmap_fragment:Rm,envmap_common_pars_fragment:Cm,envmap_pars_fragment:Im,envmap_pars_vertex:Pm,envmap_physical_pars_fragment:Vm,envmap_vertex:Dm,fog_vertex:Nm,fog_pars_vertex:Fm,fog_fragment:Bm,fog_pars_fragment:km,gradientmap_pars_fragment:Om,lightmap_fragment:zm,lightmap_pars_fragment:Um,lights_lambert_vertex:Hm,lights_pars_begin:Gm,lights_toon_fragment:Wm,lights_toon_pars_fragment:qm,lights_phong_fragment:$m,lights_phong_pars_fragment:Xm,lights_physical_fragment:jm,lights_physical_pars_fragment:Ym,lights_fragment_begin:Zm,lights_fragment_maps:Km,lights_fragment_end:Jm,logdepthbuf_fragment:Qm,logdepthbuf_pars_fragment:eg,logdepthbuf_pars_vertex:tg,logdepthbuf_vertex:ng,map_fragment:ig,map_pars_fragment:sg,map_particle_fragment:rg,map_particle_pars_fragment:ag,metalnessmap_fragment:og,metalnessmap_pars_fragment:lg,morphnormal_vertex:cg,morphtarget_pars_vertex:dg,morphtarget_vertex:ug,normal_fragment_begin:hg,normal_fragment_maps:fg,normalmap_pars_fragment:pg,clearcoat_normal_fragment_begin:mg,clearcoat_normal_fragment_maps:gg,clearcoat_pars_fragment:yg,packing:_g,premultiplied_alpha_fragment:vg,project_vertex:xg,dithering_fragment:bg,dithering_pars_fragment:wg,roughnessmap_fragment:Mg,roughnessmap_pars_fragment:Sg,shadowmap_pars_fragment:Tg,shadowmap_pars_vertex:Eg,shadowmap_vertex:Ag,shadowmask_pars_fragment:Lg,skinbase_vertex:Rg,skinning_pars_vertex:Cg,skinning_vertex:Ig,skinnormal_vertex:Pg,specularmap_fragment:Dg,specularmap_pars_fragment:Ng,tonemapping_fragment:Fg,tonemapping_pars_fragment:Bg,transmissionmap_fragment:kg,transmissionmap_pars_fragment:Og,uv_pars_fragment:zg,uv_pars_vertex:Ug,uv_vertex:Hg,uv2_pars_fragment:Gg,uv2_pars_vertex:Vg,uv2_vertex:Wg,worldpos_vertex:qg,background_frag:$g,background_vert:Xg,cube_frag:jg,cube_vert:Yg,depth_frag:Zg,depth_vert:Kg,distanceRGBA_frag:Jg,distanceRGBA_vert:Qg,equirect_frag:ey,equirect_vert:ty,linedashed_frag:ny,linedashed_vert:iy,meshbasic_frag:sy,meshbasic_vert:ry,meshlambert_frag:ay,meshlambert_vert:oy,meshmatcap_frag:ly,meshmatcap_vert:cy,meshtoon_frag:dy,meshtoon_vert:uy,meshphong_frag:hy,meshphong_vert:fy,meshphysical_frag:py,meshphysical_vert:my,normal_frag:gy,normal_vert:yy,points_frag:_y,points_vert:vy,shadow_frag:xy,shadow_vert:by,sprite_frag:wy,sprite_vert:My},Ie={common:{diffuse:{value:new ke(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Ut},uv2Transform:{value:new Ut},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Ae(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ke(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ke(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Ut}},sprite:{diffuse:{value:new ke(15658734)},opacity:{value:1},center:{value:new Ae(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Ut}}},Nn={basic:{uniforms:qt([Ie.common,Ie.specularmap,Ie.envmap,Ie.aomap,Ie.lightmap,Ie.fog]),vertexShader:nt.meshbasic_vert,fragmentShader:nt.meshbasic_frag},lambert:{uniforms:qt([Ie.common,Ie.specularmap,Ie.envmap,Ie.aomap,Ie.lightmap,Ie.emissivemap,Ie.fog,Ie.lights,{emissive:{value:new ke(0)}}]),vertexShader:nt.meshlambert_vert,fragmentShader:nt.meshlambert_frag},phong:{uniforms:qt([Ie.common,Ie.specularmap,Ie.envmap,Ie.aomap,Ie.lightmap,Ie.emissivemap,Ie.bumpmap,Ie.normalmap,Ie.displacementmap,Ie.fog,Ie.lights,{emissive:{value:new ke(0)},specular:{value:new ke(1118481)},shininess:{value:30}}]),vertexShader:nt.meshphong_vert,fragmentShader:nt.meshphong_frag},standard:{uniforms:qt([Ie.common,Ie.envmap,Ie.aomap,Ie.lightmap,Ie.emissivemap,Ie.bumpmap,Ie.normalmap,Ie.displacementmap,Ie.roughnessmap,Ie.metalnessmap,Ie.fog,Ie.lights,{emissive:{value:new ke(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:nt.meshphysical_vert,fragmentShader:nt.meshphysical_frag},toon:{uniforms:qt([Ie.common,Ie.aomap,Ie.lightmap,Ie.emissivemap,Ie.bumpmap,Ie.normalmap,Ie.displacementmap,Ie.gradientmap,Ie.fog,Ie.lights,{emissive:{value:new ke(0)}}]),vertexShader:nt.meshtoon_vert,fragmentShader:nt.meshtoon_frag},matcap:{uniforms:qt([Ie.common,Ie.bumpmap,Ie.normalmap,Ie.displacementmap,Ie.fog,{matcap:{value:null}}]),vertexShader:nt.meshmatcap_vert,fragmentShader:nt.meshmatcap_frag},points:{uniforms:qt([Ie.points,Ie.fog]),vertexShader:nt.points_vert,fragmentShader:nt.points_frag},dashed:{uniforms:qt([Ie.common,Ie.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:nt.linedashed_vert,fragmentShader:nt.linedashed_frag},depth:{uniforms:qt([Ie.common,Ie.displacementmap]),vertexShader:nt.depth_vert,fragmentShader:nt.depth_frag},normal:{uniforms:qt([Ie.common,Ie.bumpmap,Ie.normalmap,Ie.displacementmap,{opacity:{value:1}}]),vertexShader:nt.normal_vert,fragmentShader:nt.normal_frag},sprite:{uniforms:qt([Ie.sprite,Ie.fog]),vertexShader:nt.sprite_vert,fragmentShader:nt.sprite_frag},background:{uniforms:{uvTransform:{value:new Ut},t2D:{value:null}},vertexShader:nt.background_vert,fragmentShader:nt.background_frag},cube:{uniforms:qt([Ie.envmap,{opacity:{value:1}}]),vertexShader:nt.cube_vert,fragmentShader:nt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:nt.equirect_vert,fragmentShader:nt.equirect_frag},distanceRGBA:{uniforms:qt([Ie.common,Ie.displacementmap,{referencePosition:{value:new P},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:nt.distanceRGBA_vert,fragmentShader:nt.distanceRGBA_frag},shadow:{uniforms:qt([Ie.lights,Ie.fog,{color:{value:new ke(0)},opacity:{value:1}}]),vertexShader:nt.shadow_vert,fragmentShader:nt.shadow_frag}};Nn.physical={uniforms:qt([Nn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Ae(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new ke(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:nt.meshphysical_vert,fragmentShader:nt.meshphysical_frag};function Sy(r,e,t,n,i){const s=new ke(0);let a=0,o,l,c=null,d=0,u=null;function h(_,v,y,p){let f=v.isScene===!0?v.background:null;f&&f.isTexture&&(f=e.get(f));const b=r.xr,M=b.getSession&&b.getSession();M&&M.environmentBlendMode==="additive"&&(f=null),f===null?m(s,a):f&&f.isColor&&(m(f,1),p=!0),(r.autoClear||p)&&r.clear(r.autoClearColor,r.autoClearDepth,r.autoClearStencil),f&&(f.isCubeTexture||f.mapping===ya)?(l===void 0&&(l=new dt(new _a(1,1,1),new Di({name:"BackgroundCubeMaterial",uniforms:Ts(Nn.cube.uniforms),vertexShader:Nn.cube.vertexShader,fragmentShader:Nn.cube.fragmentShader,side:Pt,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(S,x,I){this.matrixWorld.copyPosition(I.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(l)),l.material.uniforms.envMap.value=f,l.material.uniforms.flipEnvMap.value=f.isCubeTexture&&f._needsFlipEnvMap?-1:1,(c!==f||d!==f.version||u!==r.toneMapping)&&(l.material.needsUpdate=!0,c=f,d=f.version,u=r.toneMapping),_.unshift(l,l.geometry,l.material,0,0,null)):f&&f.isTexture&&(o===void 0&&(o=new dt(new tl(2,2),new Di({name:"BackgroundMaterial",uniforms:Ts(Nn.background.uniforms),vertexShader:Nn.background.vertexShader,fragmentShader:Nn.background.fragmentShader,side:xr,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(o)),o.material.uniforms.t2D.value=f,f.matrixAutoUpdate===!0&&f.updateMatrix(),o.material.uniforms.uvTransform.value.copy(f.matrix),(c!==f||d!==f.version||u!==r.toneMapping)&&(o.material.needsUpdate=!0,c=f,d=f.version,u=r.toneMapping),_.unshift(o,o.geometry,o.material,0,0,null))}function m(_,v){t.buffers.color.setClear(_.r,_.g,_.b,v,i)}return{getClearColor:function(){return s},setClearColor:function(_,v=1){s.set(_),a=v,m(s,a)},getClearAlpha:function(){return a},setClearAlpha:function(_){a=_,m(s,a)},render:h}}function Ty(r,e,t,n){const i=r.getParameter(34921),s=n.isWebGL2?null:e.get("OES_vertex_array_object"),a=n.isWebGL2||s!==null,o={},l=v(null);let c=l;function d(C,W,z,E,N){let K=!1;if(a){const J=_(E,z,W);c!==J&&(c=J,h(c.object)),K=y(E,N),K&&p(E,N)}else{const J=W.wireframe===!0;(c.geometry!==E.id||c.program!==z.id||c.wireframe!==J)&&(c.geometry=E.id,c.program=z.id,c.wireframe=J,K=!0)}C.isInstancedMesh===!0&&(K=!0),N!==null&&t.update(N,34963),K&&(I(C,W,z,E),N!==null&&r.bindBuffer(34963,t.get(N).buffer))}function u(){return n.isWebGL2?r.createVertexArray():s.createVertexArrayOES()}function h(C){return n.isWebGL2?r.bindVertexArray(C):s.bindVertexArrayOES(C)}function m(C){return n.isWebGL2?r.deleteVertexArray(C):s.deleteVertexArrayOES(C)}function _(C,W,z){const E=z.wireframe===!0;let N=o[C.id];N===void 0&&(N={},o[C.id]=N);let K=N[W.id];K===void 0&&(K={},N[W.id]=K);let J=K[E];return J===void 0&&(J=v(u()),K[E]=J),J}function v(C){const W=[],z=[],E=[];for(let N=0;N<i;N++)W[N]=0,z[N]=0,E[N]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:W,enabledAttributes:z,attributeDivisors:E,object:C,attributes:{},index:null}}function y(C,W){const z=c.attributes,E=C.attributes;let N=0;for(const K in E){const J=z[K],T=E[K];if(J===void 0||J.attribute!==T||J.data!==T.data)return!0;N++}return c.attributesNum!==N||c.index!==W}function p(C,W){const z={},E=C.attributes;let N=0;for(const K in E){const J=E[K],T={};T.attribute=J,J.data&&(T.data=J.data),z[K]=T,N++}c.attributes=z,c.attributesNum=N,c.index=W}function f(){const C=c.newAttributes;for(let W=0,z=C.length;W<z;W++)C[W]=0}function b(C){M(C,0)}function M(C,W){const z=c.newAttributes,E=c.enabledAttributes,N=c.attributeDivisors;z[C]=1,E[C]===0&&(r.enableVertexAttribArray(C),E[C]=1),N[C]!==W&&((n.isWebGL2?r:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](C,W),N[C]=W)}function S(){const C=c.newAttributes,W=c.enabledAttributes;for(let z=0,E=W.length;z<E;z++)W[z]!==C[z]&&(r.disableVertexAttribArray(z),W[z]=0)}function x(C,W,z,E,N,K){n.isWebGL2===!0&&(z===5124||z===5125)?r.vertexAttribIPointer(C,W,z,N,K):r.vertexAttribPointer(C,W,z,E,N,K)}function I(C,W,z,E){if(n.isWebGL2===!1&&(C.isInstancedMesh||E.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;f();const N=E.attributes,K=z.getAttributes(),J=W.defaultAttributeValues;for(const T in K){const O=K[T];if(O>=0){const H=N[T];if(H!==void 0){const ee=H.normalized,B=H.itemSize,ne=t.get(H);if(ne===void 0)continue;const Q=ne.buffer,se=ne.type,re=ne.bytesPerElement;if(H.isInterleavedBufferAttribute){const be=H.data,me=be.stride,Ne=H.offset;be&&be.isInstancedInterleavedBuffer?(M(O,be.meshPerAttribute),E._maxInstanceCount===void 0&&(E._maxInstanceCount=be.meshPerAttribute*be.count)):b(O),r.bindBuffer(34962,Q),x(O,B,se,ee,me*re,Ne*re)}else H.isInstancedBufferAttribute?(M(O,H.meshPerAttribute),E._maxInstanceCount===void 0&&(E._maxInstanceCount=H.meshPerAttribute*H.count)):b(O),r.bindBuffer(34962,Q),x(O,B,se,ee,0,0)}else if(T==="instanceMatrix"){const ee=t.get(C.instanceMatrix);if(ee===void 0)continue;const B=ee.buffer,ne=ee.type;M(O+0,1),M(O+1,1),M(O+2,1),M(O+3,1),r.bindBuffer(34962,B),r.vertexAttribPointer(O+0,4,ne,!1,64,0),r.vertexAttribPointer(O+1,4,ne,!1,64,16),r.vertexAttribPointer(O+2,4,ne,!1,64,32),r.vertexAttribPointer(O+3,4,ne,!1,64,48)}else if(T==="instanceColor"){const ee=t.get(C.instanceColor);if(ee===void 0)continue;const B=ee.buffer,ne=ee.type;M(O,1),r.bindBuffer(34962,B),r.vertexAttribPointer(O,3,ne,!1,12,0)}else if(J!==void 0){const ee=J[T];if(ee!==void 0)switch(ee.length){case 2:r.vertexAttrib2fv(O,ee);break;case 3:r.vertexAttrib3fv(O,ee);break;case 4:r.vertexAttrib4fv(O,ee);break;default:r.vertexAttrib1fv(O,ee)}}}}S()}function V(){G();for(const C in o){const W=o[C];for(const z in W){const E=W[z];for(const N in E)m(E[N].object),delete E[N];delete W[z]}delete o[C]}}function Y(C){if(o[C.id]===void 0)return;const W=o[C.id];for(const z in W){const E=W[z];for(const N in E)m(E[N].object),delete E[N];delete W[z]}delete o[C.id]}function j(C){for(const W in o){const z=o[W];if(z[C.id]===void 0)continue;const E=z[C.id];for(const N in E)m(E[N].object),delete E[N];delete z[C.id]}}function G(){q(),c!==l&&(c=l,h(c.object))}function q(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:d,reset:G,resetDefaultState:q,dispose:V,releaseStatesOfGeometry:Y,releaseStatesOfProgram:j,initAttributes:f,enableAttribute:b,disableUnusedAttributes:S}}function Ey(r,e,t,n){const i=n.isWebGL2;let s;function a(c){s=c}function o(c,d){r.drawArrays(s,c,d),t.update(d,s,1)}function l(c,d,u){if(u===0)return;let h,m;if(i)h=r,m="drawArraysInstanced";else if(h=e.get("ANGLE_instanced_arrays"),m="drawArraysInstancedANGLE",h===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}h[m](s,c,d,u),t.update(d,s,u)}this.setMode=a,this.render=o,this.renderInstances=l}function Ay(r,e,t){let n;function i(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const x=e.get("EXT_texture_filter_anisotropic");n=r.getParameter(x.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(x){if(x==="highp"){if(r.getShaderPrecisionFormat(35633,36338).precision>0&&r.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";x="mediump"}return x==="mediump"&&r.getShaderPrecisionFormat(35633,36337).precision>0&&r.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext<"u"&&r instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&r instanceof WebGL2ComputeRenderingContext;let o=t.precision!==void 0?t.precision:"highp";const l=s(o);l!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",l,"instead."),o=l);const c=t.logarithmicDepthBuffer===!0,d=r.getParameter(34930),u=r.getParameter(35660),h=r.getParameter(3379),m=r.getParameter(34076),_=r.getParameter(34921),v=r.getParameter(36347),y=r.getParameter(36348),p=r.getParameter(36349),f=u>0,b=a||e.has("OES_texture_float"),M=f&&b,S=a?r.getParameter(36183):0;return{isWebGL2:a,getMaxAnisotropy:i,getMaxPrecision:s,precision:o,logarithmicDepthBuffer:c,maxTextures:d,maxVertexTextures:u,maxTextureSize:h,maxCubemapSize:m,maxAttributes:_,maxVertexUniforms:v,maxVaryings:y,maxFragmentUniforms:p,vertexTextures:f,floatFragmentTextures:b,floatVertexTextures:M,maxSamples:S}}function Ly(r){const e=this;let t=null,n=0,i=!1,s=!1;const a=new Dn,o=new Ut,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,h,m){const _=u.length!==0||h||n!==0||i;return i=h,t=d(u,m,0),n=u.length,_},this.beginShadows=function(){s=!0,d(null)},this.endShadows=function(){s=!1,c()},this.setState=function(u,h,m){const _=u.clippingPlanes,v=u.clipIntersection,y=u.clipShadows,p=r.get(u);if(!i||_===null||_.length===0||s&&!y)s?d(null):c();else{const f=s?0:n,b=f*4;let M=p.clippingState||null;l.value=M,M=d(_,h,b,m);for(let S=0;S!==b;++S)M[S]=t[S];p.clippingState=M,this.numIntersection=v?this.numPlanes:0,this.numPlanes+=f}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function d(u,h,m,_){const v=u!==null?u.length:0;let y=null;if(v!==0){if(y=l.value,_!==!0||y===null){const p=m+v*4,f=h.matrixWorldInverse;o.getNormalMatrix(f),(y===null||y.length<p)&&(y=new Float32Array(p));for(let b=0,M=m;b!==v;++b,M+=4)a.copy(u[b]).applyMatrix4(f,o),a.normal.toArray(y,M),y[M+3]=a.constant}l.value=y,l.needsUpdate=!0}return e.numPlanes=v,e.numIntersection=0,y}}function Ry(r){let e=new WeakMap;function t(a,o){return o===Ql?a.mapping=$o:o===ec&&(a.mapping=Xo),a}function n(a){if(a&&a.isTexture){const o=a.mapping;if(o===Ql||o===ec)if(e.has(a)){const l=e.get(a).texture;return t(l,a.mapping)}else{const l=a.image;if(l&&l.height>0){const c=r.getRenderTarget(),d=new Jd(l.height/2);return d.fromEquirectangularTexture(r,a),e.set(a,d),r.setRenderTarget(c),a.addEventListener("dispose",i),t(d.texture,a.mapping)}else return null}}return a}function i(a){const o=a.target;o.removeEventListener("dispose",i);const l=e.get(o);l!==void 0&&(e.delete(o),l.dispose())}function s(){e=new WeakMap}return{get:n,dispose:s}}function Cy(r){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=r.getExtension("WEBGL_depth_texture")||r.getExtension("MOZ_WEBGL_depth_texture")||r.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=r.getExtension("EXT_texture_filter_anisotropic")||r.getExtension("MOZ_EXT_texture_filter_anisotropic")||r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=r.getExtension("WEBGL_compressed_texture_s3tc")||r.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=r.getExtension("WEBGL_compressed_texture_pvrtc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=r.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(n){const i=t(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function Iy(r,e,t,n){const i={},s=new WeakMap;function a(u){const h=u.target;h.index!==null&&e.remove(h.index);for(const _ in h.attributes)e.remove(h.attributes[_]);h.removeEventListener("dispose",a),delete i[h.id];const m=s.get(h);m&&(e.remove(m),s.delete(h)),n.releaseStatesOfGeometry(h),h.isInstancedBufferGeometry===!0&&delete h._maxInstanceCount,t.memory.geometries--}function o(u,h){return i[h.id]===!0||(h.addEventListener("dispose",a),i[h.id]=!0,t.memory.geometries++),h}function l(u){const h=u.attributes;for(const _ in h)e.update(h[_],34962);const m=u.morphAttributes;for(const _ in m){const v=m[_];for(let y=0,p=v.length;y<p;y++)e.update(v[y],34962)}}function c(u){const h=[],m=u.index,_=u.attributes.position;let v=0;if(m!==null){const f=m.array;v=m.version;for(let b=0,M=f.length;b<M;b+=3){const S=f[b+0],x=f[b+1],I=f[b+2];h.push(S,x,x,I,I,S)}}else{const f=_.array;v=_.version;for(let b=0,M=f.length/3-1;b<M;b+=3){const S=b+0,x=b+1,I=b+2;h.push(S,x,x,I,I,S)}}const y=new(Kd(h)>65535?Zd:Yd)(h,1);y.version=v;const p=s.get(u);p&&e.remove(p),s.set(u,y)}function d(u){const h=s.get(u);if(h){const m=u.index;m!==null&&h.version<m.version&&c(u)}else c(u);return s.get(u)}return{get:o,update:l,getWireframeAttribute:d}}function Py(r,e,t,n){const i=n.isWebGL2;let s;function a(h){s=h}let o,l;function c(h){o=h.type,l=h.bytesPerElement}function d(h,m){r.drawElements(s,m,o,h*l),t.update(m,s,1)}function u(h,m,_){if(_===0)return;let v,y;if(i)v=r,y="drawElementsInstanced";else if(v=e.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",v===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}v[y](s,m,o,h*l,_),t.update(m,s,_)}this.setMode=a,this.setIndex=c,this.render=d,this.renderInstances=u}function Dy(r){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,o){switch(t.calls++,a){case 4:t.triangles+=o*(s/3);break;case 1:t.lines+=o*(s/2);break;case 3:t.lines+=o*(s-1);break;case 2:t.lines+=o*s;break;case 0:t.points+=o*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:n}}function Ny(r,e){return r[0]-e[0]}function Fy(r,e){return Math.abs(e[1])-Math.abs(r[1])}function By(r){const e={},t=new Float32Array(8),n=[];for(let s=0;s<8;s++)n[s]=[s,0];function i(s,a,o,l){const c=s.morphTargetInfluences,d=c===void 0?0:c.length;let u=e[a.id];if(u===void 0){u=[];for(let y=0;y<d;y++)u[y]=[y,0];e[a.id]=u}for(let y=0;y<d;y++){const p=u[y];p[0]=y,p[1]=c[y]}u.sort(Fy);for(let y=0;y<8;y++)y<d&&u[y][1]?(n[y][0]=u[y][0],n[y][1]=u[y][1]):(n[y][0]=Number.MAX_SAFE_INTEGER,n[y][1]=0);n.sort(Ny);const h=o.morphTargets&&a.morphAttributes.position,m=o.morphNormals&&a.morphAttributes.normal;let _=0;for(let y=0;y<8;y++){const p=n[y],f=p[0],b=p[1];f!==Number.MAX_SAFE_INTEGER&&b?(h&&a.getAttribute("morphTarget"+y)!==h[f]&&a.setAttribute("morphTarget"+y,h[f]),m&&a.getAttribute("morphNormal"+y)!==m[f]&&a.setAttribute("morphNormal"+y,m[f]),t[y]=b,_+=b):(h&&a.hasAttribute("morphTarget"+y)===!0&&a.deleteAttribute("morphTarget"+y),m&&a.hasAttribute("morphNormal"+y)===!0&&a.deleteAttribute("morphNormal"+y),t[y]=0)}const v=a.morphTargetsRelative?1:1-_;l.getUniforms().setValue(r,"morphTargetBaseInfluence",v),l.getUniforms().setValue(r,"morphTargetInfluences",t)}return{update:i}}function ky(r,e,t,n){let i=new WeakMap;function s(l){const c=n.render.frame,d=l.geometry,u=e.get(l,d);return i.get(u)!==c&&(e.update(u),i.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),u}function a(){i=new WeakMap}function o(l){const c=l.target;c.removeEventListener("dispose",o),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:s,dispose:a}}class tu extends Bt{constructor(e=null,t=1,n=1,i=1){super(null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=Ft,this.minFilter=Ft,this.wrapR=tn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}tu.prototype.isDataTexture2DArray=!0;class nu extends Bt{constructor(e=null,t=1,n=1,i=1){super(null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=Ft,this.minFilter=Ft,this.wrapR=tn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}nu.prototype.isDataTexture3D=!0;const iu=new Bt,Oy=new tu,zy=new nu,su=new va,Mc=[],Sc=[],Tc=new Float32Array(16),Ec=new Float32Array(9),Ac=new Float32Array(4);function Cs(r,e,t){const n=r[0];if(n<=0||n>0)return r;const i=e*t;let s=Mc[i];if(s===void 0&&(s=new Float32Array(i),Mc[i]=s),e!==0){n.toArray(s,0);for(let a=1,o=0;a!==e;++a)o+=t,r[a].toArray(s,o)}return s}function Jt(r,e){if(r.length!==e.length)return!1;for(let t=0,n=r.length;t<n;t++)if(r[t]!==e[t])return!1;return!0}function Xt(r,e){for(let t=0,n=e.length;t<n;t++)r[t]=e[t]}function ru(r,e){let t=Sc[e];t===void 0&&(t=new Int32Array(e),Sc[e]=t);for(let n=0;n!==e;++n)t[n]=r.allocateTextureUnit();return t}function Uy(r,e){const t=this.cache;t[0]!==e&&(r.uniform1f(this.addr,e),t[0]=e)}function Hy(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Jt(t,e))return;r.uniform2fv(this.addr,e),Xt(t,e)}}function Gy(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(r.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Jt(t,e))return;r.uniform3fv(this.addr,e),Xt(t,e)}}function Vy(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Jt(t,e))return;r.uniform4fv(this.addr,e),Xt(t,e)}}function Wy(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(Jt(t,e))return;r.uniformMatrix2fv(this.addr,!1,e),Xt(t,e)}else{if(Jt(t,n))return;Ac.set(n),r.uniformMatrix2fv(this.addr,!1,Ac),Xt(t,n)}}function qy(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(Jt(t,e))return;r.uniformMatrix3fv(this.addr,!1,e),Xt(t,e)}else{if(Jt(t,n))return;Ec.set(n),r.uniformMatrix3fv(this.addr,!1,Ec),Xt(t,n)}}function $y(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(Jt(t,e))return;r.uniformMatrix4fv(this.addr,!1,e),Xt(t,e)}else{if(Jt(t,n))return;Tc.set(n),r.uniformMatrix4fv(this.addr,!1,Tc),Xt(t,n)}}function Xy(r,e){const t=this.cache;t[0]!==e&&(r.uniform1i(this.addr,e),t[0]=e)}function jy(r,e){const t=this.cache;Jt(t,e)||(r.uniform2iv(this.addr,e),Xt(t,e))}function Yy(r,e){const t=this.cache;Jt(t,e)||(r.uniform3iv(this.addr,e),Xt(t,e))}function Zy(r,e){const t=this.cache;Jt(t,e)||(r.uniform4iv(this.addr,e),Xt(t,e))}function Ky(r,e){const t=this.cache;t[0]!==e&&(r.uniform1ui(this.addr,e),t[0]=e)}function Jy(r,e){const t=this.cache;Jt(t,e)||(r.uniform2uiv(this.addr,e),Xt(t,e))}function Qy(r,e){const t=this.cache;Jt(t,e)||(r.uniform3uiv(this.addr,e),Xt(t,e))}function e_(r,e){const t=this.cache;Jt(t,e)||(r.uniform4uiv(this.addr,e),Xt(t,e))}function t_(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.safeSetTexture2D(e||iu,i)}function n_(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||zy,i)}function i_(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.safeSetTextureCube(e||su,i)}function s_(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||Oy,i)}function r_(r){switch(r){case 5126:return Uy;case 35664:return Hy;case 35665:return Gy;case 35666:return Vy;case 35674:return Wy;case 35675:return qy;case 35676:return $y;case 5124:case 35670:return Xy;case 35667:case 35671:return jy;case 35668:case 35672:return Yy;case 35669:case 35673:return Zy;case 5125:return Ky;case 36294:return Jy;case 36295:return Qy;case 36296:return e_;case 35678:case 36198:case 36298:case 36306:case 35682:return t_;case 35679:case 36299:case 36307:return n_;case 35680:case 36300:case 36308:case 36293:return i_;case 36289:case 36303:case 36311:case 36292:return s_}}function a_(r,e){r.uniform1fv(this.addr,e)}function o_(r,e){const t=Cs(e,this.size,2);r.uniform2fv(this.addr,t)}function l_(r,e){const t=Cs(e,this.size,3);r.uniform3fv(this.addr,t)}function c_(r,e){const t=Cs(e,this.size,4);r.uniform4fv(this.addr,t)}function d_(r,e){const t=Cs(e,this.size,4);r.uniformMatrix2fv(this.addr,!1,t)}function u_(r,e){const t=Cs(e,this.size,9);r.uniformMatrix3fv(this.addr,!1,t)}function h_(r,e){const t=Cs(e,this.size,16);r.uniformMatrix4fv(this.addr,!1,t)}function f_(r,e){r.uniform1iv(this.addr,e)}function p_(r,e){r.uniform2iv(this.addr,e)}function m_(r,e){r.uniform3iv(this.addr,e)}function g_(r,e){r.uniform4iv(this.addr,e)}function y_(r,e){r.uniform1uiv(this.addr,e)}function __(r,e){r.uniform2uiv(this.addr,e)}function v_(r,e){r.uniform3uiv(this.addr,e)}function x_(r,e){r.uniform4uiv(this.addr,e)}function b_(r,e,t){const n=e.length,i=ru(t,n);r.uniform1iv(this.addr,i);for(let s=0;s!==n;++s)t.safeSetTexture2D(e[s]||iu,i[s])}function w_(r,e,t){const n=e.length,i=ru(t,n);r.uniform1iv(this.addr,i);for(let s=0;s!==n;++s)t.safeSetTextureCube(e[s]||su,i[s])}function M_(r){switch(r){case 5126:return a_;case 35664:return o_;case 35665:return l_;case 35666:return c_;case 35674:return d_;case 35675:return u_;case 35676:return h_;case 5124:case 35670:return f_;case 35667:case 35671:return p_;case 35668:case 35672:return m_;case 35669:case 35673:return g_;case 5125:return y_;case 36294:return __;case 36295:return v_;case 36296:return x_;case 35678:case 36198:case 36298:case 36306:case 35682:return b_;case 35680:case 36300:case 36308:case 36293:return w_}}function S_(r,e,t){this.id=r,this.addr=t,this.cache=[],this.setValue=r_(e.type)}function au(r,e,t){this.id=r,this.addr=t,this.cache=[],this.size=e.size,this.setValue=M_(e.type)}au.prototype.updateCache=function(r){const e=this.cache;r instanceof Float32Array&&e.length!==r.length&&(this.cache=new Float32Array(r.length)),Xt(e,r)};function ou(r){this.id=r,this.seq=[],this.map={}}ou.prototype.setValue=function(r,e,t){const n=this.seq;for(let i=0,s=n.length;i!==s;++i){const a=n[i];a.setValue(r,e[a.id],t)}};const yo=/(\w+)(\])?(\[|\.)?/g;function Lc(r,e){r.seq.push(e),r.map[e.id]=e}function T_(r,e,t){const n=r.name,i=n.length;for(yo.lastIndex=0;;){const s=yo.exec(n),a=yo.lastIndex;let o=s[1];const l=s[2]==="]",c=s[3];if(l&&(o=o|0),c===void 0||c==="["&&a+2===i){Lc(t,c===void 0?new S_(o,r,e):new au(o,r,e));break}else{let u=t.map[o];u===void 0&&(u=new ou(o),Lc(t,u)),t=u}}}function pi(r,e){this.seq=[],this.map={};const t=r.getProgramParameter(e,35718);for(let n=0;n<t;++n){const i=r.getActiveUniform(e,n),s=r.getUniformLocation(e,i.name);T_(i,s,this)}}pi.prototype.setValue=function(r,e,t,n){const i=this.map[e];i!==void 0&&i.setValue(r,t,n)};pi.prototype.setOptional=function(r,e,t){const n=e[t];n!==void 0&&this.setValue(r,t,n)};pi.upload=function(r,e,t,n){for(let i=0,s=e.length;i!==s;++i){const a=e[i],o=t[a.id];o.needsUpdate!==!1&&a.setValue(r,o.value,n)}};pi.seqWithValue=function(r,e){const t=[];for(let n=0,i=r.length;n!==i;++n){const s=r[n];s.id in e&&t.push(s)}return t};function Rc(r,e,t){const n=r.createShader(e);return r.shaderSource(n,t),r.compileShader(n),n}let E_=0;function A_(r){const e=r.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function lu(r){switch(r){case sn:return["Linear","( value )"];case jn:return["sRGB","( value )"];case Ko:return["RGBE","( value )"];case Gd:return["RGBM","( value, 7.0 )"];case Vd:return["RGBM","( value, 16.0 )"];case Wd:return["RGBD","( value, 256.0 )"];case Zo:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case xp:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",r),["Linear","( value )"]}}function Cc(r,e,t){const n=r.getShaderParameter(e,35713),i=r.getShaderInfoLog(e).trim();if(n&&i==="")return"";const s=r.getShaderSource(e);return"THREE.WebGLShader: gl.getShaderInfoLog() "+t+`
`+i+A_(s)}function qs(r,e){const t=lu(e);return"vec4 "+r+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function L_(r,e){const t=lu(e);return"vec4 "+r+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function R_(r,e){let t;switch(e){case vf:t="Linear";break;case xf:t="Reinhard";break;case bf:t="OptimizedCineon";break;case kd:t="ACESFilmic";break;case wf:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+r+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function C_(r){return[r.extensionDerivatives||r.envMapCubeUV||r.bumpMap||r.tangentSpaceNormalMap||r.clearcoatNormalMap||r.flatShading||r.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(r.extensionFragDepth||r.logarithmicDepthBuffer)&&r.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",r.extensionDrawBuffers&&r.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(r.extensionShaderTextureLOD||r.envMap)&&r.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(nr).join(`
`)}function I_(r){const e=[];for(const t in r){const n=r[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function P_(r,e){const t={},n=r.getProgramParameter(e,35721);for(let i=0;i<n;i++){const a=r.getActiveAttrib(e,i).name;t[a]=r.getAttribLocation(e,a)}return t}function nr(r){return r!==""}function Ic(r,e){return r.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Pc(r,e){return r.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const D_=/^[ \t]*#include +<([\w\d./]+)>/gm;function Bo(r){return r.replace(D_,N_)}function N_(r,e){const t=nt[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return Bo(t)}const F_=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,B_=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Dc(r){return r.replace(B_,cu).replace(F_,k_)}function k_(r,e,t,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),cu(r,e,t,n)}function cu(r,e,t,n){let i="";for(let s=parseInt(e);s<parseInt(t);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function Nc(r){let e="precision "+r.precision+` float;
precision `+r.precision+" int;";return r.precision==="highp"?e+=`
#define HIGH_PRECISION`:r.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:r.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function O_(r){let e="SHADOWMAP_TYPE_BASIC";return r.shadowMapType===Pd?e="SHADOWMAP_TYPE_PCF":r.shadowMapType===Dd?e="SHADOWMAP_TYPE_PCF_SOFT":r.shadowMapType===er&&(e="SHADOWMAP_TYPE_VSM"),e}function z_(r){let e="ENVMAP_TYPE_CUBE";if(r.envMap)switch(r.envMapMode){case $o:case Xo:e="ENVMAP_TYPE_CUBE";break;case ya:case jo:e="ENVMAP_TYPE_CUBE_UV";break}return e}function U_(r){let e="ENVMAP_MODE_REFLECTION";if(r.envMap)switch(r.envMapMode){case Xo:case jo:e="ENVMAP_MODE_REFRACTION";break}return e}function H_(r){let e="ENVMAP_BLENDING_NONE";if(r.envMap)switch(r.combine){case ga:e="ENVMAP_BLENDING_MULTIPLY";break;case yf:e="ENVMAP_BLENDING_MIX";break;case _f:e="ENVMAP_BLENDING_ADD";break}return e}function G_(r,e,t,n){const i=r.getContext(),s=t.defines;let a=t.vertexShader,o=t.fragmentShader;const l=O_(t),c=z_(t),d=U_(t),u=H_(t),h=r.gammaFactor>0?r.gammaFactor:1,m=t.isWebGL2?"":C_(t),_=I_(s),v=i.createProgram();let y,p,f=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(y=[_].filter(nr).join(`
`),y.length>0&&(y+=`
`),p=[m,_].filter(nr).join(`
`),p.length>0&&(p+=`
`)):(y=[Nc(t),"#define SHADER_NAME "+t.shaderName,_,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+h,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+d:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(nr).join(`
`),p=[m,Nc(t),"#define SHADER_NAME "+t.shaderName,_,t.alphaTest?"#define ALPHATEST "+t.alphaTest+(t.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+h,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+d:"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.sheen?"#define USE_SHEEN":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Ii?"#define TONE_MAPPING":"",t.toneMapping!==Ii?nt.tonemapping_pars_fragment:"",t.toneMapping!==Ii?R_("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",nt.encodings_pars_fragment,t.map?qs("mapTexelToLinear",t.mapEncoding):"",t.matcap?qs("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?qs("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?qs("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.lightMap?qs("lightMapTexelToLinear",t.lightMapEncoding):"",L_("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(nr).join(`
`)),a=Bo(a),a=Ic(a,t),a=Pc(a,t),o=Bo(o),o=Ic(o,t),o=Pc(o,t),a=Dc(a),o=Dc(o),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(f=`#version 300 es
`,y=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,p=["#define varying in",t.glslVersion===uc?"":"out highp vec4 pc_fragColor;",t.glslVersion===uc?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+p);const b=f+y+a,M=f+p+o,S=Rc(i,35633,b),x=Rc(i,35632,M);if(i.attachShader(v,S),i.attachShader(v,x),t.index0AttributeName!==void 0?i.bindAttribLocation(v,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(v,0,"position"),i.linkProgram(v),r.debug.checkShaderErrors){const Y=i.getProgramInfoLog(v).trim(),j=i.getShaderInfoLog(S).trim(),G=i.getShaderInfoLog(x).trim();let q=!0,C=!0;if(i.getProgramParameter(v,35714)===!1){q=!1;const W=Cc(i,S,"vertex"),z=Cc(i,x,"fragment");console.error("THREE.WebGLProgram: shader error: ",i.getError(),"35715",i.getProgramParameter(v,35715),"gl.getProgramInfoLog",Y,W,z)}else Y!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",Y):(j===""||G==="")&&(C=!1);C&&(this.diagnostics={runnable:q,programLog:Y,vertexShader:{log:j,prefix:y},fragmentShader:{log:G,prefix:p}})}i.deleteShader(S),i.deleteShader(x);let I;this.getUniforms=function(){return I===void 0&&(I=new pi(i,v)),I};let V;return this.getAttributes=function(){return V===void 0&&(V=P_(i,v)),V},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(v),this.program=void 0},this.name=t.shaderName,this.id=E_++,this.cacheKey=e,this.usedTimes=1,this.program=v,this.vertexShader=S,this.fragmentShader=x,this}function V_(r,e,t,n,i,s){const a=[],o=n.isWebGL2,l=n.logarithmicDepthBuffer,c=n.floatVertexTextures,d=n.maxVertexUniforms,u=n.vertexTextures;let h=n.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},_=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function v(x){const V=x.skeleton.bones;if(c)return 1024;{const j=Math.floor((d-20)/4),G=Math.min(j,V.length);return G<V.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+V.length+" bones. This GPU supports "+G+"."),0):G}}function y(x){let I;return x&&x.isTexture?I=x.encoding:x&&x.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),I=x.texture.encoding):I=sn,I}function p(x,I,V,Y,j){const G=Y.fog,q=x.isMeshStandardMaterial?Y.environment:null,C=e.get(x.envMap||q),W=m[x.type],z=j.isSkinnedMesh?v(j):0;x.precision!==null&&(h=n.getMaxPrecision(x.precision),h!==x.precision&&console.warn("THREE.WebGLProgram.getParameters:",x.precision,"not supported, using",h,"instead."));let E,N;if(W){const T=Nn[W];E=T.vertexShader,N=T.fragmentShader}else E=x.vertexShader,N=x.fragmentShader;const K=r.getRenderTarget();return{isWebGL2:o,shaderID:W,shaderName:x.type,vertexShader:E,fragmentShader:N,defines:x.defines,isRawShaderMaterial:x.isRawShaderMaterial===!0,glslVersion:x.glslVersion,precision:h,instancing:j.isInstancedMesh===!0,instancingColor:j.isInstancedMesh===!0&&j.instanceColor!==null,supportsVertexTextures:u,outputEncoding:K!==null?y(K.texture):r.outputEncoding,map:!!x.map,mapEncoding:y(x.map),matcap:!!x.matcap,matcapEncoding:y(x.matcap),envMap:!!C,envMapMode:C&&C.mapping,envMapEncoding:y(C),envMapCubeUV:!!C&&(C.mapping===ya||C.mapping===jo),lightMap:!!x.lightMap,lightMapEncoding:y(x.lightMap),aoMap:!!x.aoMap,emissiveMap:!!x.emissiveMap,emissiveMapEncoding:y(x.emissiveMap),bumpMap:!!x.bumpMap,normalMap:!!x.normalMap,objectSpaceNormalMap:x.normalMapType===Mp,tangentSpaceNormalMap:x.normalMapType===Ni,clearcoatMap:!!x.clearcoatMap,clearcoatRoughnessMap:!!x.clearcoatRoughnessMap,clearcoatNormalMap:!!x.clearcoatNormalMap,displacementMap:!!x.displacementMap,roughnessMap:!!x.roughnessMap,metalnessMap:!!x.metalnessMap,specularMap:!!x.specularMap,alphaMap:!!x.alphaMap,gradientMap:!!x.gradientMap,sheen:!!x.sheen,transmissionMap:!!x.transmissionMap,combine:x.combine,vertexTangents:x.normalMap&&x.vertexTangents,vertexColors:x.vertexColors,vertexAlphas:x.vertexColors===!0&&j.geometry&&j.geometry.attributes.color&&j.geometry.attributes.color.itemSize===4,vertexUvs:!!x.map||!!x.bumpMap||!!x.normalMap||!!x.specularMap||!!x.alphaMap||!!x.emissiveMap||!!x.roughnessMap||!!x.metalnessMap||!!x.clearcoatMap||!!x.clearcoatRoughnessMap||!!x.clearcoatNormalMap||!!x.displacementMap||!!x.transmissionMap,uvsVertexOnly:!(x.map||x.bumpMap||x.normalMap||x.specularMap||x.alphaMap||x.emissiveMap||x.roughnessMap||x.metalnessMap||x.clearcoatNormalMap||x.transmissionMap)&&!!x.displacementMap,fog:!!G,useFog:x.fog,fogExp2:G&&G.isFogExp2,flatShading:!!x.flatShading,sizeAttenuation:x.sizeAttenuation,logarithmicDepthBuffer:l,skinning:x.skinning&&z>0,maxBones:z,useVertexTexture:c,morphTargets:x.morphTargets,morphNormals:x.morphNormals,numDirLights:I.directional.length,numPointLights:I.point.length,numSpotLights:I.spot.length,numRectAreaLights:I.rectArea.length,numHemiLights:I.hemi.length,numDirLightShadows:I.directionalShadowMap.length,numPointLightShadows:I.pointShadowMap.length,numSpotLightShadows:I.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:x.dithering,shadowMapEnabled:r.shadowMap.enabled&&V.length>0,shadowMapType:r.shadowMap.type,toneMapping:x.toneMapped?r.toneMapping:Ii,physicallyCorrectLights:r.physicallyCorrectLights,premultipliedAlpha:x.premultipliedAlpha,alphaTest:x.alphaTest,doubleSided:x.side===yi,flipSided:x.side===Pt,depthPacking:x.depthPacking!==void 0?x.depthPacking:!1,index0AttributeName:x.index0AttributeName,extensionDerivatives:x.extensions&&x.extensions.derivatives,extensionFragDepth:x.extensions&&x.extensions.fragDepth,extensionDrawBuffers:x.extensions&&x.extensions.drawBuffers,extensionShaderTextureLOD:x.extensions&&x.extensions.shaderTextureLOD,rendererExtensionFragDepth:o||t.has("EXT_frag_depth"),rendererExtensionDrawBuffers:o||t.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:o||t.has("EXT_shader_texture_lod"),customProgramCacheKey:x.customProgramCacheKey()}}function f(x){const I=[];if(x.shaderID?I.push(x.shaderID):(I.push(x.fragmentShader),I.push(x.vertexShader)),x.defines!==void 0)for(const V in x.defines)I.push(V),I.push(x.defines[V]);if(x.isRawShaderMaterial===!1){for(let V=0;V<_.length;V++)I.push(x[_[V]]);I.push(r.outputEncoding),I.push(r.gammaFactor)}return I.push(x.customProgramCacheKey),I.join()}function b(x){const I=m[x.type];let V;if(I){const Y=Nn[I];V=Qp.clone(Y.uniforms)}else V=x.uniforms;return V}function M(x,I){let V;for(let Y=0,j=a.length;Y<j;Y++){const G=a[Y];if(G.cacheKey===I){V=G,++V.usedTimes;break}}return V===void 0&&(V=new G_(r,I,x,i),a.push(V)),V}function S(x){if(--x.usedTimes===0){const I=a.indexOf(x);a[I]=a[a.length-1],a.pop(),x.destroy()}}return{getParameters:p,getProgramCacheKey:f,getUniforms:b,acquireProgram:M,releaseProgram:S,programs:a}}function W_(){let r=new WeakMap;function e(s){let a=r.get(s);return a===void 0&&(a={},r.set(s,a)),a}function t(s){r.delete(s)}function n(s,a,o){r.get(s)[a]=o}function i(){r=new WeakMap}return{get:e,remove:t,update:n,dispose:i}}function q_(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.program!==e.program?r.program.id-e.program.id:r.material.id!==e.material.id?r.material.id-e.material.id:r.z!==e.z?r.z-e.z:r.id-e.id}function $_(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.z!==e.z?e.z-r.z:r.id-e.id}function Fc(r){const e=[];let t=0;const n=[],i=[],s={id:-1};function a(){t=0,n.length=0,i.length=0}function o(h,m,_,v,y,p){let f=e[t];const b=r.get(_);return f===void 0?(f={id:h.id,object:h,geometry:m,material:_,program:b.program||s,groupOrder:v,renderOrder:h.renderOrder,z:y,group:p},e[t]=f):(f.id=h.id,f.object=h,f.geometry=m,f.material=_,f.program=b.program||s,f.groupOrder=v,f.renderOrder=h.renderOrder,f.z=y,f.group=p),t++,f}function l(h,m,_,v,y,p){const f=o(h,m,_,v,y,p);(_.transparent===!0?i:n).push(f)}function c(h,m,_,v,y,p){const f=o(h,m,_,v,y,p);(_.transparent===!0?i:n).unshift(f)}function d(h,m){n.length>1&&n.sort(h||q_),i.length>1&&i.sort(m||$_)}function u(){for(let h=t,m=e.length;h<m;h++){const _=e[h];if(_.id===null)break;_.id=null,_.object=null,_.geometry=null,_.material=null,_.program=null,_.group=null}}return{opaque:n,transparent:i,init:a,push:l,unshift:c,finish:u,sort:d}}function X_(r){let e=new WeakMap;function t(i,s){let a;return e.has(i)===!1?(a=new Fc(r),e.set(i,[a])):s>=e.get(i).length?(a=new Fc(r),e.get(i).push(a)):a=e.get(i)[s],a}function n(){e=new WeakMap}return{get:t,dispose:n}}function j_(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new P,color:new ke};break;case"SpotLight":t={position:new P,direction:new P,color:new ke,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new P,color:new ke,distance:0,decay:0};break;case"HemisphereLight":t={direction:new P,skyColor:new ke,groundColor:new ke};break;case"RectAreaLight":t={color:new ke,position:new P,halfWidth:new P,halfHeight:new P};break}return r[e.id]=t,t}}}function Y_(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ae};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ae};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ae,shadowCameraNear:1,shadowCameraFar:1e3};break}return r[e.id]=t,t}}}let Z_=0;function K_(r,e){return(e.castShadow?1:0)-(r.castShadow?1:0)}function J_(r,e){const t=new j_,n=Y_(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let d=0;d<9;d++)i.probe.push(new P);const s=new P,a=new Ve,o=new Ve;function l(d){let u=0,h=0,m=0;for(let I=0;I<9;I++)i.probe[I].set(0,0,0);let _=0,v=0,y=0,p=0,f=0,b=0,M=0,S=0;d.sort(K_);for(let I=0,V=d.length;I<V;I++){const Y=d[I],j=Y.color,G=Y.intensity,q=Y.distance,C=Y.shadow&&Y.shadow.map?Y.shadow.map.texture:null;if(Y.isAmbientLight)u+=j.r*G,h+=j.g*G,m+=j.b*G;else if(Y.isLightProbe)for(let W=0;W<9;W++)i.probe[W].addScaledVector(Y.sh.coefficients[W],G);else if(Y.isDirectionalLight){const W=t.get(Y);if(W.color.copy(Y.color).multiplyScalar(Y.intensity),Y.castShadow){const z=Y.shadow,E=n.get(Y);E.shadowBias=z.bias,E.shadowNormalBias=z.normalBias,E.shadowRadius=z.radius,E.shadowMapSize=z.mapSize,i.directionalShadow[_]=E,i.directionalShadowMap[_]=C,i.directionalShadowMatrix[_]=Y.shadow.matrix,b++}i.directional[_]=W,_++}else if(Y.isSpotLight){const W=t.get(Y);if(W.position.setFromMatrixPosition(Y.matrixWorld),W.color.copy(j).multiplyScalar(G),W.distance=q,W.coneCos=Math.cos(Y.angle),W.penumbraCos=Math.cos(Y.angle*(1-Y.penumbra)),W.decay=Y.decay,Y.castShadow){const z=Y.shadow,E=n.get(Y);E.shadowBias=z.bias,E.shadowNormalBias=z.normalBias,E.shadowRadius=z.radius,E.shadowMapSize=z.mapSize,i.spotShadow[y]=E,i.spotShadowMap[y]=C,i.spotShadowMatrix[y]=Y.shadow.matrix,S++}i.spot[y]=W,y++}else if(Y.isRectAreaLight){const W=t.get(Y);W.color.copy(j).multiplyScalar(G),W.halfWidth.set(Y.width*.5,0,0),W.halfHeight.set(0,Y.height*.5,0),i.rectArea[p]=W,p++}else if(Y.isPointLight){const W=t.get(Y);if(W.color.copy(Y.color).multiplyScalar(Y.intensity),W.distance=Y.distance,W.decay=Y.decay,Y.castShadow){const z=Y.shadow,E=n.get(Y);E.shadowBias=z.bias,E.shadowNormalBias=z.normalBias,E.shadowRadius=z.radius,E.shadowMapSize=z.mapSize,E.shadowCameraNear=z.camera.near,E.shadowCameraFar=z.camera.far,i.pointShadow[v]=E,i.pointShadowMap[v]=C,i.pointShadowMatrix[v]=Y.shadow.matrix,M++}i.point[v]=W,v++}else if(Y.isHemisphereLight){const W=t.get(Y);W.skyColor.copy(Y.color).multiplyScalar(G),W.groundColor.copy(Y.groundColor).multiplyScalar(G),i.hemi[f]=W,f++}}p>0&&(e.isWebGL2||r.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=Ie.LTC_FLOAT_1,i.rectAreaLTC2=Ie.LTC_FLOAT_2):r.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=Ie.LTC_HALF_1,i.rectAreaLTC2=Ie.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=u,i.ambient[1]=h,i.ambient[2]=m;const x=i.hash;(x.directionalLength!==_||x.pointLength!==v||x.spotLength!==y||x.rectAreaLength!==p||x.hemiLength!==f||x.numDirectionalShadows!==b||x.numPointShadows!==M||x.numSpotShadows!==S)&&(i.directional.length=_,i.spot.length=y,i.rectArea.length=p,i.point.length=v,i.hemi.length=f,i.directionalShadow.length=b,i.directionalShadowMap.length=b,i.pointShadow.length=M,i.pointShadowMap.length=M,i.spotShadow.length=S,i.spotShadowMap.length=S,i.directionalShadowMatrix.length=b,i.pointShadowMatrix.length=M,i.spotShadowMatrix.length=S,x.directionalLength=_,x.pointLength=v,x.spotLength=y,x.rectAreaLength=p,x.hemiLength=f,x.numDirectionalShadows=b,x.numPointShadows=M,x.numSpotShadows=S,i.version=Z_++)}function c(d,u){let h=0,m=0,_=0,v=0,y=0;const p=u.matrixWorldInverse;for(let f=0,b=d.length;f<b;f++){const M=d[f];if(M.isDirectionalLight){const S=i.directional[h];S.direction.setFromMatrixPosition(M.matrixWorld),s.setFromMatrixPosition(M.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(p),h++}else if(M.isSpotLight){const S=i.spot[_];S.position.setFromMatrixPosition(M.matrixWorld),S.position.applyMatrix4(p),S.direction.setFromMatrixPosition(M.matrixWorld),s.setFromMatrixPosition(M.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(p),_++}else if(M.isRectAreaLight){const S=i.rectArea[v];S.position.setFromMatrixPosition(M.matrixWorld),S.position.applyMatrix4(p),o.identity(),a.copy(M.matrixWorld),a.premultiply(p),o.extractRotation(a),S.halfWidth.set(M.width*.5,0,0),S.halfHeight.set(0,M.height*.5,0),S.halfWidth.applyMatrix4(o),S.halfHeight.applyMatrix4(o),v++}else if(M.isPointLight){const S=i.point[m];S.position.setFromMatrixPosition(M.matrixWorld),S.position.applyMatrix4(p),m++}else if(M.isHemisphereLight){const S=i.hemi[y];S.direction.setFromMatrixPosition(M.matrixWorld),S.direction.transformDirection(p),S.direction.normalize(),y++}}}return{setup:l,setupView:c,state:i}}function Bc(r,e){const t=new J_(r,e),n=[],i=[];function s(){n.length=0,i.length=0}function a(u){n.push(u)}function o(u){i.push(u)}function l(){t.setup(n)}function c(u){t.setupView(n,u)}return{init:s,state:{lightsArray:n,shadowsArray:i,lights:t},setupLights:l,setupLightsView:c,pushLight:a,pushShadow:o}}function Q_(r,e){let t=new WeakMap;function n(s,a=0){let o;return t.has(s)===!1?(o=new Bc(r,e),t.set(s,[o])):a>=t.get(s).length?(o=new Bc(r,e),t.get(s).push(o)):o=t.get(s)[a],o}function i(){t=new WeakMap}return{get:n,dispose:i}}class du extends Ct{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=bp,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}du.prototype.isMeshDepthMaterial=!0;class uu extends Ct{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new P,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}uu.prototype.isMeshDistanceMaterial=!0;var ev=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,tv=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function hu(r,e,t){let n=new xa;const i=new Ae,s=new Ae,a=new gt,o=[],l=[],c={},d=t.maxTextureSize,u={0:Pt,1:xr,2:yi},h=new Di({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ae},radius:{value:4}},vertexShader:tv,fragmentShader:ev}),m=h.clone();m.defines.HORIZONTAL_PASS=1;const _=new pt;_.setAttribute("position",new Tt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const v=new dt(_,h),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Pd,this.render=function(x,I,V){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||x.length===0)return;const Y=r.getRenderTarget(),j=r.getActiveCubeFace(),G=r.getActiveMipmapLevel(),q=r.state;q.setBlending(ui),q.buffers.color.setClear(1,1,1,1),q.buffers.depth.setTest(!0),q.setScissorTest(!1);for(let C=0,W=x.length;C<W;C++){const z=x[C],E=z.shadow;if(E===void 0){console.warn("THREE.WebGLShadowMap:",z,"has no shadow.");continue}if(E.autoUpdate===!1&&E.needsUpdate===!1)continue;i.copy(E.mapSize);const N=E.getFrameExtents();if(i.multiply(N),s.copy(E.mapSize),(i.x>d||i.y>d)&&(i.x>d&&(s.x=Math.floor(d/N.x),i.x=s.x*N.x,E.mapSize.x=s.x),i.y>d&&(s.y=Math.floor(d/N.y),i.y=s.y*N.y,E.mapSize.y=s.y)),E.map===null&&!E.isPointLightShadow&&this.type===er){const J={minFilter:nn,magFilter:nn,format:pn};E.map=new fi(i.x,i.y,J),E.map.texture.name=z.name+".shadowMap",E.mapPass=new fi(i.x,i.y,J),E.camera.updateProjectionMatrix()}if(E.map===null){const J={minFilter:Ft,magFilter:Ft,format:pn};E.map=new fi(i.x,i.y,J),E.map.texture.name=z.name+".shadowMap",E.camera.updateProjectionMatrix()}r.setRenderTarget(E.map),r.clear();const K=E.getViewportCount();for(let J=0;J<K;J++){const T=E.getViewport(J);a.set(s.x*T.x,s.y*T.y,s.x*T.z,s.y*T.w),q.viewport(a),E.updateMatrices(z,J),n=E.getFrustum(),S(I,V,E.camera,z,this.type)}!E.isPointLightShadow&&this.type===er&&p(E,V),E.needsUpdate=!1}y.needsUpdate=!1,r.setRenderTarget(Y,j,G)};function p(x,I){const V=e.update(v);h.uniforms.shadow_pass.value=x.map.texture,h.uniforms.resolution.value=x.mapSize,h.uniforms.radius.value=x.radius,r.setRenderTarget(x.mapPass),r.clear(),r.renderBufferDirect(I,null,V,h,v,null),m.uniforms.shadow_pass.value=x.mapPass.texture,m.uniforms.resolution.value=x.mapSize,m.uniforms.radius.value=x.radius,r.setRenderTarget(x.map),r.clear(),r.renderBufferDirect(I,null,V,m,v,null)}function f(x,I,V){const Y=x<<0|I<<1|V<<2;let j=o[Y];return j===void 0&&(j=new du({depthPacking:wp,morphTargets:x,skinning:I}),o[Y]=j),j}function b(x,I,V){const Y=x<<0|I<<1|V<<2;let j=l[Y];return j===void 0&&(j=new uu({morphTargets:x,skinning:I}),l[Y]=j),j}function M(x,I,V,Y,j,G,q){let C=null,W=f,z=x.customDepthMaterial;if(Y.isPointLight===!0&&(W=b,z=x.customDistanceMaterial),z===void 0){let E=!1;V.morphTargets===!0&&(E=I.morphAttributes&&I.morphAttributes.position&&I.morphAttributes.position.length>0);let N=!1;x.isSkinnedMesh===!0&&(V.skinning===!0?N=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",x));const K=x.isInstancedMesh===!0;C=W(E,N,K)}else C=z;if(r.localClippingEnabled&&V.clipShadows===!0&&V.clippingPlanes.length!==0){const E=C.uuid,N=V.uuid;let K=c[E];K===void 0&&(K={},c[E]=K);let J=K[N];J===void 0&&(J=C.clone(),K[N]=J),C=J}return C.visible=V.visible,C.wireframe=V.wireframe,q===er?C.side=V.shadowSide!==null?V.shadowSide:V.side:C.side=V.shadowSide!==null?V.shadowSide:u[V.side],C.clipShadows=V.clipShadows,C.clippingPlanes=V.clippingPlanes,C.clipIntersection=V.clipIntersection,C.wireframeLinewidth=V.wireframeLinewidth,C.linewidth=V.linewidth,Y.isPointLight===!0&&C.isMeshDistanceMaterial===!0&&(C.referencePosition.setFromMatrixPosition(Y.matrixWorld),C.nearDistance=j,C.farDistance=G),C}function S(x,I,V,Y,j){if(x.visible===!1)return;if(x.layers.test(I.layers)&&(x.isMesh||x.isLine||x.isPoints)&&(x.castShadow||x.receiveShadow&&j===er)&&(!x.frustumCulled||n.intersectsObject(x))){x.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse,x.matrixWorld);const C=e.update(x),W=x.material;if(Array.isArray(W)){const z=C.groups;for(let E=0,N=z.length;E<N;E++){const K=z[E],J=W[K.materialIndex];if(J&&J.visible){const T=M(x,C,J,Y,V.near,V.far,j);r.renderBufferDirect(V,null,C,T,x,K)}}}else if(W.visible){const z=M(x,C,W,Y,V.near,V.far,j);r.renderBufferDirect(V,null,C,z,x,null)}}const q=x.children;for(let C=0,W=q.length;C<W;C++)S(q[C],I,V,Y,j)}}function nv(r,e,t){const n=t.isWebGL2;function i(){let U=!1;const _e=new gt;let Se=null;const De=new gt(0,0,0,0);return{setMask:function(ve){Se!==ve&&!U&&(r.colorMask(ve,ve,ve,ve),Se=ve)},setLocked:function(ve){U=ve},setClear:function(ve,We,it,rt,vt){vt===!0&&(ve*=rt,We*=rt,it*=rt),_e.set(ve,We,it,rt),De.equals(_e)===!1&&(r.clearColor(ve,We,it,rt),De.copy(_e))},reset:function(){U=!1,Se=null,De.set(-1,0,0,0)}}}function s(){let U=!1,_e=null,Se=null,De=null;return{setTest:function(ve){ve?H(2929):ee(2929)},setMask:function(ve){_e!==ve&&!U&&(r.depthMask(ve),_e=ve)},setFunc:function(ve){if(Se!==ve){if(ve)switch(ve){case df:r.depthFunc(512);break;case uf:r.depthFunc(519);break;case hf:r.depthFunc(513);break;case Po:r.depthFunc(515);break;case ff:r.depthFunc(514);break;case pf:r.depthFunc(518);break;case mf:r.depthFunc(516);break;case gf:r.depthFunc(517);break;default:r.depthFunc(515)}else r.depthFunc(515);Se=ve}},setLocked:function(ve){U=ve},setClear:function(ve){De!==ve&&(r.clearDepth(ve),De=ve)},reset:function(){U=!1,_e=null,Se=null,De=null}}}function a(){let U=!1,_e=null,Se=null,De=null,ve=null,We=null,it=null,rt=null,vt=null;return{setTest:function(mt){U||(mt?H(2960):ee(2960))},setMask:function(mt){_e!==mt&&!U&&(r.stencilMask(mt),_e=mt)},setFunc:function(mt,It,jt){(Se!==mt||De!==It||ve!==jt)&&(r.stencilFunc(mt,It,jt),Se=mt,De=It,ve=jt)},setOp:function(mt,It,jt){(We!==mt||it!==It||rt!==jt)&&(r.stencilOp(mt,It,jt),We=mt,it=It,rt=jt)},setLocked:function(mt){U=mt},setClear:function(mt){vt!==mt&&(r.clearStencil(mt),vt=mt)},reset:function(){U=!1,_e=null,Se=null,De=null,ve=null,We=null,it=null,rt=null,vt=null}}}const o=new i,l=new s,c=new a;let d={},u=null,h={},m=null,_=!1,v=null,y=null,p=null,f=null,b=null,M=null,S=null,x=!1,I=null,V=null,Y=null,j=null,G=null;const q=r.getParameter(35661);let C=!1,W=0;const z=r.getParameter(7938);z.indexOf("WebGL")!==-1?(W=parseFloat(/^WebGL (\d)/.exec(z)[1]),C=W>=1):z.indexOf("OpenGL ES")!==-1&&(W=parseFloat(/^OpenGL ES (\d)/.exec(z)[1]),C=W>=2);let E=null,N={};const K=new gt(0,0,r.canvas.width,r.canvas.height),J=new gt(0,0,r.canvas.width,r.canvas.height);function T(U,_e,Se){const De=new Uint8Array(4),ve=r.createTexture();r.bindTexture(U,ve),r.texParameteri(U,10241,9728),r.texParameteri(U,10240,9728);for(let We=0;We<Se;We++)r.texImage2D(_e+We,0,6408,1,1,0,6408,5121,De);return ve}const O={};O[3553]=T(3553,3553,1),O[34067]=T(34067,34069,6),o.setClear(0,0,0,1),l.setClear(1),c.setClear(0),H(2929),l.setFunc(Po),Ne(!1),ue(Xl),H(2884),be(ui);function H(U){d[U]!==!0&&(r.enable(U),d[U]=!0)}function ee(U){d[U]!==!1&&(r.disable(U),d[U]=!1)}function B(U){U!==u&&(r.bindFramebuffer(36160,U),u=U)}function ne(U,_e){_e===null&&u!==null&&(_e=u),h[U]!==_e&&(r.bindFramebuffer(U,_e),h[U]=_e,n&&(U===36009&&(h[36160]=_e),U===36160&&(h[36009]=_e)))}function Q(U){return m!==U?(r.useProgram(U),m=U,!0):!1}const se={[ps]:32774,[Jh]:32778,[Qh]:32779};if(n)se[Kl]=32775,se[Jl]=32776;else{const U=e.get("EXT_blend_minmax");U!==null&&(se[Kl]=U.MIN_EXT,se[Jl]=U.MAX_EXT)}const re={[ef]:0,[tf]:1,[nf]:768,[Fd]:770,[cf]:776,[of]:774,[rf]:772,[sf]:769,[Bd]:771,[lf]:775,[af]:773};function be(U,_e,Se,De,ve,We,it,rt){if(U===ui){_===!0&&(ee(3042),_=!1);return}if(_===!1&&(H(3042),_=!0),U!==Kh){if(U!==v||rt!==x){if((y!==ps||b!==ps)&&(r.blendEquation(32774),y=ps,b=ps),rt)switch(U){case sr:r.blendFuncSeparate(1,771,1,771);break;case jl:r.blendFunc(1,1);break;case Yl:r.blendFuncSeparate(0,0,769,771);break;case Zl:r.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",U);break}else switch(U){case sr:r.blendFuncSeparate(770,771,1,771);break;case jl:r.blendFunc(770,1);break;case Yl:r.blendFunc(0,769);break;case Zl:r.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",U);break}p=null,f=null,M=null,S=null,v=U,x=rt}return}ve=ve||_e,We=We||Se,it=it||De,(_e!==y||ve!==b)&&(r.blendEquationSeparate(se[_e],se[ve]),y=_e,b=ve),(Se!==p||De!==f||We!==M||it!==S)&&(r.blendFuncSeparate(re[Se],re[De],re[We],re[it]),p=Se,f=De,M=We,S=it),v=U,x=null}function me(U,_e){U.side===yi?ee(2884):H(2884);let Se=U.side===Pt;_e&&(Se=!Se),Ne(Se),U.blending===sr&&U.transparent===!1?be(ui):be(U.blending,U.blendEquation,U.blendSrc,U.blendDst,U.blendEquationAlpha,U.blendSrcAlpha,U.blendDstAlpha,U.premultipliedAlpha),l.setFunc(U.depthFunc),l.setTest(U.depthTest),l.setMask(U.depthWrite),o.setMask(U.colorWrite);const De=U.stencilWrite;c.setTest(De),De&&(c.setMask(U.stencilWriteMask),c.setFunc(U.stencilFunc,U.stencilRef,U.stencilFuncMask),c.setOp(U.stencilFail,U.stencilZFail,U.stencilZPass)),ae(U.polygonOffset,U.polygonOffsetFactor,U.polygonOffsetUnits),U.alphaToCoverage===!0?H(32926):ee(32926)}function Ne(U){I!==U&&(U?r.frontFace(2304):r.frontFace(2305),I=U)}function ue(U){U!==Yh?(H(2884),U!==V&&(U===Xl?r.cullFace(1029):U===Zh?r.cullFace(1028):r.cullFace(1032))):ee(2884),V=U}function le(U){U!==Y&&(C&&r.lineWidth(U),Y=U)}function ae(U,_e,Se){U?(H(32823),(j!==_e||G!==Se)&&(r.polygonOffset(_e,Se),j=_e,G=Se)):ee(32823)}function Le(U){U?H(3089):ee(3089)}function de(U){U===void 0&&(U=33984+q-1),E!==U&&(r.activeTexture(U),E=U)}function D(U,_e){E===null&&de();let Se=N[E];Se===void 0&&(Se={type:void 0,texture:void 0},N[E]=Se),(Se.type!==U||Se.texture!==_e)&&(r.bindTexture(U,_e||O[U]),Se.type=U,Se.texture=_e)}function L(){const U=N[E];U!==void 0&&U.type!==void 0&&(r.bindTexture(U.type,null),U.type=void 0,U.texture=void 0)}function ce(){try{r.compressedTexImage2D.apply(r,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function oe(){try{r.texImage2D.apply(r,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function Te(){try{r.texImage3D.apply(r,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function Be(U){K.equals(U)===!1&&(r.scissor(U.x,U.y,U.z,U.w),K.copy(U))}function qe(U){J.equals(U)===!1&&(r.viewport(U.x,U.y,U.z,U.w),J.copy(U))}function X(){r.disable(3042),r.disable(2884),r.disable(2929),r.disable(32823),r.disable(3089),r.disable(2960),r.disable(32926),r.blendEquation(32774),r.blendFunc(1,0),r.blendFuncSeparate(1,0,1,0),r.colorMask(!0,!0,!0,!0),r.clearColor(0,0,0,0),r.depthMask(!0),r.depthFunc(513),r.clearDepth(1),r.stencilMask(4294967295),r.stencilFunc(519,0,4294967295),r.stencilOp(7680,7680,7680),r.clearStencil(0),r.cullFace(1029),r.frontFace(2305),r.polygonOffset(0,0),r.activeTexture(33984),r.bindFramebuffer(36160,null),n===!0&&(r.bindFramebuffer(36009,null),r.bindFramebuffer(36008,null)),r.useProgram(null),r.lineWidth(1),r.scissor(0,0,r.canvas.width,r.canvas.height),r.viewport(0,0,r.canvas.width,r.canvas.height),d={},E=null,N={},u=null,h={},m=null,_=!1,v=null,y=null,p=null,f=null,b=null,M=null,S=null,x=!1,I=null,V=null,Y=null,j=null,G=null,K.set(0,0,r.canvas.width,r.canvas.height),J.set(0,0,r.canvas.width,r.canvas.height),o.reset(),l.reset(),c.reset()}return{buffers:{color:o,depth:l,stencil:c},enable:H,disable:ee,bindFramebuffer:ne,bindXRFramebuffer:B,useProgram:Q,setBlending:be,setMaterial:me,setFlipSided:Ne,setCullFace:ue,setLineWidth:le,setPolygonOffset:ae,setScissorTest:Le,activeTexture:de,bindTexture:D,unbindTexture:L,compressedTexImage2D:ce,texImage2D:oe,texImage3D:Te,scissor:Be,viewport:qe,reset:X}}function iv(r,e,t,n,i,s,a){const o=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,d=i.maxTextureSize,u=i.maxSamples,h=new WeakMap;let m,_=!1;try{_=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function v(D,L){return _?new OffscreenCanvas(D,L):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function y(D,L,ce,oe){let Te=1;if((D.width>oe||D.height>oe)&&(Te=oe/Math.max(D.width,D.height)),Te<1||L===!0)if(typeof HTMLImageElement<"u"&&D instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&D instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&D instanceof ImageBitmap){const Be=L?$d:Math.floor,qe=Be(Te*D.width),X=Be(Te*D.height);m===void 0&&(m=v(qe,X));const U=ce?v(qe,X):m;return U.width=qe,U.height=X,U.getContext("2d").drawImage(D,0,0,qe,X),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+D.width+"x"+D.height+") to ("+qe+"x"+X+")."),U}else return"data"in D&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+D.width+"x"+D.height+")."),D;return D}function p(D){return Fo(D.width)&&Fo(D.height)}function f(D){return o?!1:D.wrapS!==tn||D.wrapT!==tn||D.minFilter!==Ft&&D.minFilter!==nn}function b(D,L){return D.generateMipmaps&&L&&D.minFilter!==Ft&&D.minFilter!==nn}function M(D,L,ce,oe){r.generateMipmap(D);const Te=n.get(L);Te.__maxMipLevel=Math.log2(Math.max(ce,oe))}function S(D,L,ce){if(o===!1)return L;if(D!==null){if(r[D]!==void 0)return r[D];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+D+"'")}let oe=L;return L===6403&&(ce===5126&&(oe=33326),ce===5131&&(oe=33325),ce===5121&&(oe=33321)),L===6407&&(ce===5126&&(oe=34837),ce===5131&&(oe=34843),ce===5121&&(oe=32849)),L===6408&&(ce===5126&&(oe=34836),ce===5131&&(oe=34842),ce===5121&&(oe=32856)),(oe===33325||oe===33326||oe===34842||oe===34836)&&e.get("EXT_color_buffer_float"),oe}function x(D){return D===Ft||D===Do||D===No?9728:9729}function I(D){const L=D.target;L.removeEventListener("dispose",I),Y(L),L.isVideoTexture&&h.delete(L),a.memory.textures--}function V(D){const L=D.target;L.removeEventListener("dispose",V),j(L),a.memory.textures--}function Y(D){const L=n.get(D);L.__webglInit!==void 0&&(r.deleteTexture(L.__webglTexture),n.remove(D))}function j(D){const L=D.texture,ce=n.get(D),oe=n.get(L);if(D){if(oe.__webglTexture!==void 0&&r.deleteTexture(oe.__webglTexture),D.depthTexture&&D.depthTexture.dispose(),D.isWebGLCubeRenderTarget)for(let Te=0;Te<6;Te++)r.deleteFramebuffer(ce.__webglFramebuffer[Te]),ce.__webglDepthbuffer&&r.deleteRenderbuffer(ce.__webglDepthbuffer[Te]);else r.deleteFramebuffer(ce.__webglFramebuffer),ce.__webglDepthbuffer&&r.deleteRenderbuffer(ce.__webglDepthbuffer),ce.__webglMultisampledFramebuffer&&r.deleteFramebuffer(ce.__webglMultisampledFramebuffer),ce.__webglColorRenderbuffer&&r.deleteRenderbuffer(ce.__webglColorRenderbuffer),ce.__webglDepthRenderbuffer&&r.deleteRenderbuffer(ce.__webglDepthRenderbuffer);n.remove(L),n.remove(D)}}let G=0;function q(){G=0}function C(){const D=G;return D>=l&&console.warn("THREE.WebGLTextures: Trying to use "+D+" texture units while this GPU supports only "+l),G+=1,D}function W(D,L){const ce=n.get(D);if(D.isVideoTexture&&ue(D),D.version>0&&ce.__version!==D.version){const oe=D.image;if(oe===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(oe.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{H(ce,D,L);return}}t.activeTexture(33984+L),t.bindTexture(3553,ce.__webglTexture)}function z(D,L){const ce=n.get(D);if(D.version>0&&ce.__version!==D.version){H(ce,D,L);return}t.activeTexture(33984+L),t.bindTexture(35866,ce.__webglTexture)}function E(D,L){const ce=n.get(D);if(D.version>0&&ce.__version!==D.version){H(ce,D,L);return}t.activeTexture(33984+L),t.bindTexture(32879,ce.__webglTexture)}function N(D,L){const ce=n.get(D);if(D.version>0&&ce.__version!==D.version){ee(ce,D,L);return}t.activeTexture(33984+L),t.bindTexture(34067,ce.__webglTexture)}const K={[_i]:10497,[tn]:33071,[da]:33648},J={[Ft]:9728,[Do]:9984,[No]:9986,[nn]:9729,[zd]:9985,[br]:9987};function T(D,L,ce){if(ce?(r.texParameteri(D,10242,K[L.wrapS]),r.texParameteri(D,10243,K[L.wrapT]),(D===32879||D===35866)&&r.texParameteri(D,32882,K[L.wrapR]),r.texParameteri(D,10240,J[L.magFilter]),r.texParameteri(D,10241,J[L.minFilter])):(r.texParameteri(D,10242,33071),r.texParameteri(D,10243,33071),(D===32879||D===35866)&&r.texParameteri(D,32882,33071),(L.wrapS!==tn||L.wrapT!==tn)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),r.texParameteri(D,10240,x(L.magFilter)),r.texParameteri(D,10241,x(L.minFilter)),L.minFilter!==Ft&&L.minFilter!==nn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const oe=e.get("EXT_texture_filter_anisotropic");if(L.type===di&&e.has("OES_texture_float_linear")===!1||o===!1&&L.type===ha&&e.has("OES_texture_half_float_linear")===!1)return;(L.anisotropy>1||n.get(L).__currentAnisotropy)&&(r.texParameterf(D,oe.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(L.anisotropy,i.getMaxAnisotropy())),n.get(L).__currentAnisotropy=L.anisotropy)}}function O(D,L){D.__webglInit===void 0&&(D.__webglInit=!0,L.addEventListener("dispose",I),D.__webglTexture=r.createTexture(),a.memory.textures++)}function H(D,L,ce){let oe=3553;L.isDataTexture2DArray&&(oe=35866),L.isDataTexture3D&&(oe=32879),O(D,L),t.activeTexture(33984+ce),t.bindTexture(oe,D.__webglTexture),r.pixelStorei(37440,L.flipY),r.pixelStorei(37441,L.premultiplyAlpha),r.pixelStorei(3317,L.unpackAlignment),r.pixelStorei(37443,0);const Te=f(L)&&p(L.image)===!1,Be=y(L.image,Te,!1,d),qe=p(Be)||o,X=s.convert(L.format);let U=s.convert(L.type),_e=S(L.internalFormat,X,U);T(oe,L,qe);let Se;const De=L.mipmaps;if(L.isDepthTexture)_e=6402,o?L.type===di?_e=36012:L.type===ca?_e=33190:L.type===rr?_e=35056:_e=33189:L.type===di&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),L.format===vs&&_e===6402&&L.type!==ua&&L.type!==ca&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),L.type=ua,U=s.convert(L.type)),L.format===dr&&_e===6402&&(_e=34041,L.type!==rr&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),L.type=rr,U=s.convert(L.type))),t.texImage2D(3553,0,_e,Be.width,Be.height,0,X,U,null);else if(L.isDataTexture)if(De.length>0&&qe){for(let ve=0,We=De.length;ve<We;ve++)Se=De[ve],t.texImage2D(3553,ve,_e,Se.width,Se.height,0,X,U,Se.data);L.generateMipmaps=!1,D.__maxMipLevel=De.length-1}else t.texImage2D(3553,0,_e,Be.width,Be.height,0,X,U,Be.data),D.__maxMipLevel=0;else if(L.isCompressedTexture){for(let ve=0,We=De.length;ve<We;ve++)Se=De[ve],L.format!==pn&&L.format!==hi?X!==null?t.compressedTexImage2D(3553,ve,_e,Se.width,Se.height,0,Se.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,ve,_e,Se.width,Se.height,0,X,U,Se.data);D.__maxMipLevel=De.length-1}else if(L.isDataTexture2DArray)t.texImage3D(35866,0,_e,Be.width,Be.height,Be.depth,0,X,U,Be.data),D.__maxMipLevel=0;else if(L.isDataTexture3D)t.texImage3D(32879,0,_e,Be.width,Be.height,Be.depth,0,X,U,Be.data),D.__maxMipLevel=0;else if(De.length>0&&qe){for(let ve=0,We=De.length;ve<We;ve++)Se=De[ve],t.texImage2D(3553,ve,_e,X,U,Se);L.generateMipmaps=!1,D.__maxMipLevel=De.length-1}else t.texImage2D(3553,0,_e,X,U,Be),D.__maxMipLevel=0;b(L,qe)&&M(oe,L,Be.width,Be.height),D.__version=L.version,L.onUpdate&&L.onUpdate(L)}function ee(D,L,ce){if(L.image.length!==6)return;O(D,L),t.activeTexture(33984+ce),t.bindTexture(34067,D.__webglTexture),r.pixelStorei(37440,L.flipY),r.pixelStorei(37441,L.premultiplyAlpha),r.pixelStorei(3317,L.unpackAlignment),r.pixelStorei(37443,0);const oe=L&&(L.isCompressedTexture||L.image[0].isCompressedTexture),Te=L.image[0]&&L.image[0].isDataTexture,Be=[];for(let ve=0;ve<6;ve++)!oe&&!Te?Be[ve]=y(L.image[ve],!1,!0,c):Be[ve]=Te?L.image[ve].image:L.image[ve];const qe=Be[0],X=p(qe)||o,U=s.convert(L.format),_e=s.convert(L.type),Se=S(L.internalFormat,U,_e);T(34067,L,X);let De;if(oe){for(let ve=0;ve<6;ve++){De=Be[ve].mipmaps;for(let We=0;We<De.length;We++){const it=De[We];L.format!==pn&&L.format!==hi?U!==null?t.compressedTexImage2D(34069+ve,We,Se,it.width,it.height,0,it.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+ve,We,Se,it.width,it.height,0,U,_e,it.data)}}D.__maxMipLevel=De.length-1}else{De=L.mipmaps;for(let ve=0;ve<6;ve++)if(Te){t.texImage2D(34069+ve,0,Se,Be[ve].width,Be[ve].height,0,U,_e,Be[ve].data);for(let We=0;We<De.length;We++){const rt=De[We].image[ve].image;t.texImage2D(34069+ve,We+1,Se,rt.width,rt.height,0,U,_e,rt.data)}}else{t.texImage2D(34069+ve,0,Se,U,_e,Be[ve]);for(let We=0;We<De.length;We++){const it=De[We];t.texImage2D(34069+ve,We+1,Se,U,_e,it.image[ve])}}D.__maxMipLevel=De.length}b(L,X)&&M(34067,L,qe.width,qe.height),D.__version=L.version,L.onUpdate&&L.onUpdate(L)}function B(D,L,ce,oe){const Te=L.texture,Be=s.convert(Te.format),qe=s.convert(Te.type),X=S(Te.internalFormat,Be,qe);oe===32879||oe===35866?t.texImage3D(oe,0,X,L.width,L.height,L.depth,0,Be,qe,null):t.texImage2D(oe,0,X,L.width,L.height,0,Be,qe,null),t.bindFramebuffer(36160,D),r.framebufferTexture2D(36160,ce,oe,n.get(Te).__webglTexture,0),t.bindFramebuffer(36160,null)}function ne(D,L,ce){if(r.bindRenderbuffer(36161,D),L.depthBuffer&&!L.stencilBuffer){let oe=33189;if(ce){const Te=L.depthTexture;Te&&Te.isDepthTexture&&(Te.type===di?oe=36012:Te.type===ca&&(oe=33190));const Be=Ne(L);r.renderbufferStorageMultisample(36161,Be,oe,L.width,L.height)}else r.renderbufferStorage(36161,oe,L.width,L.height);r.framebufferRenderbuffer(36160,36096,36161,D)}else if(L.depthBuffer&&L.stencilBuffer){if(ce){const oe=Ne(L);r.renderbufferStorageMultisample(36161,oe,35056,L.width,L.height)}else r.renderbufferStorage(36161,34041,L.width,L.height);r.framebufferRenderbuffer(36160,33306,36161,D)}else{const oe=L.texture,Te=s.convert(oe.format),Be=s.convert(oe.type),qe=S(oe.internalFormat,Te,Be);if(ce){const X=Ne(L);r.renderbufferStorageMultisample(36161,X,qe,L.width,L.height)}else r.renderbufferStorage(36161,qe,L.width,L.height)}r.bindRenderbuffer(36161,null)}function Q(D,L){if(L&&L.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,D),!(L.depthTexture&&L.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(L.depthTexture).__webglTexture||L.depthTexture.image.width!==L.width||L.depthTexture.image.height!==L.height)&&(L.depthTexture.image.width=L.width,L.depthTexture.image.height=L.height,L.depthTexture.needsUpdate=!0),W(L.depthTexture,0);const oe=n.get(L.depthTexture).__webglTexture;if(L.depthTexture.format===vs)r.framebufferTexture2D(36160,36096,3553,oe,0);else if(L.depthTexture.format===dr)r.framebufferTexture2D(36160,33306,3553,oe,0);else throw new Error("Unknown depthTexture format")}function se(D){const L=n.get(D),ce=D.isWebGLCubeRenderTarget===!0;if(D.depthTexture){if(ce)throw new Error("target.depthTexture not supported in Cube render targets");Q(L.__webglFramebuffer,D)}else if(ce){L.__webglDepthbuffer=[];for(let oe=0;oe<6;oe++)t.bindFramebuffer(36160,L.__webglFramebuffer[oe]),L.__webglDepthbuffer[oe]=r.createRenderbuffer(),ne(L.__webglDepthbuffer[oe],D,!1)}else t.bindFramebuffer(36160,L.__webglFramebuffer),L.__webglDepthbuffer=r.createRenderbuffer(),ne(L.__webglDepthbuffer,D,!1);t.bindFramebuffer(36160,null)}function re(D){const L=D.texture,ce=n.get(D),oe=n.get(L);D.addEventListener("dispose",V),oe.__webglTexture=r.createTexture(),oe.__version=L.version,a.memory.textures++;const Te=D.isWebGLCubeRenderTarget===!0,Be=D.isWebGLMultisampleRenderTarget===!0,qe=L.isDataTexture3D||L.isDataTexture2DArray,X=p(D)||o;if(o&&L.format===hi&&(L.type===di||L.type===ha)&&(L.format=pn,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),Te){ce.__webglFramebuffer=[];for(let U=0;U<6;U++)ce.__webglFramebuffer[U]=r.createFramebuffer()}else if(ce.__webglFramebuffer=r.createFramebuffer(),Be)if(o){ce.__webglMultisampledFramebuffer=r.createFramebuffer(),ce.__webglColorRenderbuffer=r.createRenderbuffer(),r.bindRenderbuffer(36161,ce.__webglColorRenderbuffer);const U=s.convert(L.format),_e=s.convert(L.type),Se=S(L.internalFormat,U,_e),De=Ne(D);r.renderbufferStorageMultisample(36161,De,Se,D.width,D.height),t.bindFramebuffer(36160,ce.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(36160,36064,36161,ce.__webglColorRenderbuffer),r.bindRenderbuffer(36161,null),D.depthBuffer&&(ce.__webglDepthRenderbuffer=r.createRenderbuffer(),ne(ce.__webglDepthRenderbuffer,D,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(Te){t.bindTexture(34067,oe.__webglTexture),T(34067,L,X);for(let U=0;U<6;U++)B(ce.__webglFramebuffer[U],D,36064,34069+U);b(L,X)&&M(34067,L,D.width,D.height),t.bindTexture(34067,null)}else{let U=3553;qe&&(o?U=L.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),t.bindTexture(U,oe.__webglTexture),T(U,L,X),B(ce.__webglFramebuffer,D,36064,U),b(L,X)&&M(3553,L,D.width,D.height),t.bindTexture(3553,null)}D.depthBuffer&&se(D)}function be(D){const L=D.texture,ce=p(D)||o;if(b(L,ce)){const oe=D.isWebGLCubeRenderTarget?34067:3553,Te=n.get(L).__webglTexture;t.bindTexture(oe,Te),M(oe,L,D.width,D.height),t.bindTexture(oe,null)}}function me(D){if(D.isWebGLMultisampleRenderTarget)if(o){const L=D.width,ce=D.height;let oe=16384;D.depthBuffer&&(oe|=256),D.stencilBuffer&&(oe|=1024);const Te=n.get(D);t.bindFramebuffer(36008,Te.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,Te.__webglFramebuffer),r.blitFramebuffer(0,0,L,ce,0,0,L,ce,oe,9728),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,Te.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function Ne(D){return o&&D.isWebGLMultisampleRenderTarget?Math.min(u,D.samples):0}function ue(D){const L=a.render.frame;h.get(D)!==L&&(h.set(D,L),D.update())}let le=!1,ae=!1;function Le(D,L){D&&D.isWebGLRenderTarget&&(le===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),le=!0),D=D.texture),W(D,L)}function de(D,L){D&&D.isWebGLCubeRenderTarget&&(ae===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),ae=!0),D=D.texture),N(D,L)}this.allocateTextureUnit=C,this.resetTextureUnits=q,this.setTexture2D=W,this.setTexture2DArray=z,this.setTexture3D=E,this.setTextureCube=N,this.setupRenderTarget=re,this.updateRenderTargetMipmap=be,this.updateMultisampleRenderTarget=me,this.safeSetTexture2D=Le,this.safeSetTextureCube=de}function sv(r,e,t){const n=t.isWebGL2;function i(s){let a;if(s===wr)return 5121;if(s===Ef)return 32819;if(s===Af)return 32820;if(s===Lf)return 33635;if(s===Mf)return 5120;if(s===Sf)return 5122;if(s===ua)return 5123;if(s===Tf)return 5124;if(s===ca)return 5125;if(s===di)return 5126;if(s===ha)return n?5131:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===Rf)return 6406;if(s===hi)return 6407;if(s===pn)return 6408;if(s===Cf)return 6409;if(s===If)return 6410;if(s===vs)return 6402;if(s===dr)return 34041;if(s===Df)return 6403;if(s===Nf)return 36244;if(s===Ff)return 33319;if(s===Bf)return 33320;if(s===kf)return 36248;if(s===Of)return 36249;if(s===tc||s===nc||s===ic||s===sc)if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===tc)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===nc)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===ic)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===sc)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===rc||s===ac||s===oc||s===lc)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===rc)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===ac)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===oc)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===lc)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===zf)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===cc||s===dc)&&(a=e.get("WEBGL_compressed_texture_etc"),a!==null)){if(s===cc)return a.COMPRESSED_RGB8_ETC2;if(s===dc)return a.COMPRESSED_RGBA8_ETC2_EAC}if(s===Uf||s===Hf||s===Gf||s===Vf||s===Wf||s===qf||s===$f||s===Xf||s===jf||s===Yf||s===Zf||s===Kf||s===Jf||s===Qf||s===tp||s===np||s===ip||s===sp||s===rp||s===ap||s===op||s===lp||s===cp||s===dp||s===up||s===hp||s===fp||s===pp)return a=e.get("WEBGL_compressed_texture_astc"),a!==null?s:null;if(s===ep)return a=e.get("EXT_texture_compression_bptc"),a!==null?s:null;if(s===rr)return n?34042:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:i}}class fu extends $t{constructor(e=[]){super(),this.cameras=e}}fu.prototype.isArrayCamera=!0;class $n extends ht{constructor(){super(),this.type="Group"}}$n.prototype.isGroup=!0;const rv={type:"move"};class _o{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new $n,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new $n,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new P,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new P),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new $n,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new P,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new P),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,s=null,a=null;const o=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(o!==null&&(i=t.getPose(e.targetRaySpace,n),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(rv))),c&&e.hand){a=!0;for(const v of e.hand.values()){const y=t.getJointPose(v,n);if(c.joints[v.jointName]===void 0){const f=new $n;f.matrixAutoUpdate=!1,f.visible=!1,c.joints[v.jointName]=f,c.add(f)}const p=c.joints[v.jointName];y!==null&&(p.matrix.fromArray(y.transform.matrix),p.matrix.decompose(p.position,p.rotation,p.scale),p.jointRadius=y.radius),p.visible=y!==null}const d=c.joints["index-finger-tip"],u=c.joints["thumb-tip"],h=d.position.distanceTo(u.position),m=.02,_=.005;c.inputState.pinching&&h>m+_?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&h<=m-_&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,n),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));return o!==null&&(o.visible=i!==null),l!==null&&(l.visible=s!==null),c!==null&&(c.visible=a!==null),this}}class av extends xi{constructor(e,t){super();const n=this,i=e.state;let s=null,a=1,o=null,l="local-floor",c=null;const d=[],u=new Map,h=new $t;h.layers.enable(1),h.viewport=new gt;const m=new $t;m.layers.enable(2),m.viewport=new gt;const _=[h,m],v=new fu;v.layers.enable(1),v.layers.enable(2);let y=null,p=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(q){let C=d[q];return C===void 0&&(C=new _o,d[q]=C),C.getTargetRaySpace()},this.getControllerGrip=function(q){let C=d[q];return C===void 0&&(C=new _o,d[q]=C),C.getGripSpace()},this.getHand=function(q){let C=d[q];return C===void 0&&(C=new _o,d[q]=C),C.getHandSpace()};function f(q){const C=u.get(q.inputSource);C&&C.dispatchEvent({type:q.type,data:q.inputSource})}function b(){u.forEach(function(q,C){q.disconnect(C)}),u.clear(),y=null,p=null,i.bindXRFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),G.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(q){a=q,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(q){l=q,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getSession=function(){return s},this.setSession=async function(q){if(s=q,s!==null){s.addEventListener("select",f),s.addEventListener("selectstart",f),s.addEventListener("selectend",f),s.addEventListener("squeeze",f),s.addEventListener("squeezestart",f),s.addEventListener("squeezeend",f),s.addEventListener("end",b),s.addEventListener("inputsourceschange",M);const C=t.getContextAttributes();C.xrCompatible!==!0&&await t.makeXRCompatible();const W={antialias:C.antialias,alpha:C.alpha,depth:C.depth,stencil:C.stencil,framebufferScaleFactor:a},z=new XRWebGLLayer(s,t,W);s.updateRenderState({baseLayer:z}),o=await s.requestReferenceSpace(l),G.setContext(s),G.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function M(q){const C=s.inputSources;for(let W=0;W<d.length;W++)u.set(C[W],d[W]);for(let W=0;W<q.removed.length;W++){const z=q.removed[W],E=u.get(z);E&&(E.dispatchEvent({type:"disconnected",data:z}),u.delete(z))}for(let W=0;W<q.added.length;W++){const z=q.added[W],E=u.get(z);E&&E.dispatchEvent({type:"connected",data:z})}}const S=new P,x=new P;function I(q,C,W){S.setFromMatrixPosition(C.matrixWorld),x.setFromMatrixPosition(W.matrixWorld);const z=S.distanceTo(x),E=C.projectionMatrix.elements,N=W.projectionMatrix.elements,K=E[14]/(E[10]-1),J=E[14]/(E[10]+1),T=(E[9]+1)/E[5],O=(E[9]-1)/E[5],H=(E[8]-1)/E[0],ee=(N[8]+1)/N[0],B=K*H,ne=K*ee,Q=z/(-H+ee),se=Q*-H;C.matrixWorld.decompose(q.position,q.quaternion,q.scale),q.translateX(se),q.translateZ(Q),q.matrixWorld.compose(q.position,q.quaternion,q.scale),q.matrixWorldInverse.copy(q.matrixWorld).invert();const re=K+Q,be=J+Q,me=B-se,Ne=ne+(z-se),ue=T*J/be*re,le=O*J/be*re;q.projectionMatrix.makePerspective(me,Ne,ue,le,re,be)}function V(q,C){C===null?q.matrixWorld.copy(q.matrix):q.matrixWorld.multiplyMatrices(C.matrixWorld,q.matrix),q.matrixWorldInverse.copy(q.matrixWorld).invert()}this.getCamera=function(q){v.near=m.near=h.near=q.near,v.far=m.far=h.far=q.far,(y!==v.near||p!==v.far)&&(s.updateRenderState({depthNear:v.near,depthFar:v.far}),y=v.near,p=v.far);const C=q.parent,W=v.cameras;V(v,C);for(let E=0;E<W.length;E++)V(W[E],C);q.matrixWorld.copy(v.matrixWorld),q.matrix.copy(v.matrix),q.matrix.decompose(q.position,q.quaternion,q.scale);const z=q.children;for(let E=0,N=z.length;E<N;E++)z[E].updateMatrixWorld(!0);return W.length===2?I(v,h,m):v.projectionMatrix.copy(h.projectionMatrix),v};let Y=null;function j(q,C){if(c=C.getViewerPose(o),c!==null){const z=c.views,E=s.renderState.baseLayer;i.bindXRFramebuffer(E.framebuffer);let N=!1;z.length!==v.cameras.length&&(v.cameras.length=0,N=!0);for(let K=0;K<z.length;K++){const J=z[K],T=E.getViewport(J),O=_[K];O.matrix.fromArray(J.transform.matrix),O.projectionMatrix.fromArray(J.projectionMatrix),O.viewport.set(T.x,T.y,T.width,T.height),K===0&&v.matrix.copy(O.matrix),N===!0&&v.cameras.push(O)}}const W=s.inputSources;for(let z=0;z<d.length;z++){const E=d[z],N=W[z];E.update(N,C,o)}Y&&Y(q,C)}const G=new eu;G.setAnimationLoop(j),this.setAnimationLoop=function(q){Y=q},this.dispose=function(){}}}function ov(r){function e(p,f){p.fogColor.value.copy(f.color),f.isFog?(p.fogNear.value=f.near,p.fogFar.value=f.far):f.isFogExp2&&(p.fogDensity.value=f.density)}function t(p,f,b,M){f.isMeshBasicMaterial?n(p,f):f.isMeshLambertMaterial?(n(p,f),l(p,f)):f.isMeshToonMaterial?(n(p,f),d(p,f)):f.isMeshPhongMaterial?(n(p,f),c(p,f)):f.isMeshStandardMaterial?(n(p,f),f.isMeshPhysicalMaterial?h(p,f):u(p,f)):f.isMeshMatcapMaterial?(n(p,f),m(p,f)):f.isMeshDepthMaterial?(n(p,f),_(p,f)):f.isMeshDistanceMaterial?(n(p,f),v(p,f)):f.isMeshNormalMaterial?(n(p,f),y(p,f)):f.isLineBasicMaterial?(i(p,f),f.isLineDashedMaterial&&s(p,f)):f.isPointsMaterial?a(p,f,b,M):f.isSpriteMaterial?o(p,f):f.isShadowMaterial?(p.color.value.copy(f.color),p.opacity.value=f.opacity):f.isShaderMaterial&&(f.uniformsNeedUpdate=!1)}function n(p,f){p.opacity.value=f.opacity,f.color&&p.diffuse.value.copy(f.color),f.emissive&&p.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity),f.map&&(p.map.value=f.map),f.alphaMap&&(p.alphaMap.value=f.alphaMap),f.specularMap&&(p.specularMap.value=f.specularMap);const b=r.get(f).envMap;if(b){p.envMap.value=b,p.flipEnvMap.value=b.isCubeTexture&&b._needsFlipEnvMap?-1:1,p.reflectivity.value=f.reflectivity,p.refractionRatio.value=f.refractionRatio;const x=r.get(b).__maxMipLevel;x!==void 0&&(p.maxMipLevel.value=x)}f.lightMap&&(p.lightMap.value=f.lightMap,p.lightMapIntensity.value=f.lightMapIntensity),f.aoMap&&(p.aoMap.value=f.aoMap,p.aoMapIntensity.value=f.aoMapIntensity);let M;f.map?M=f.map:f.specularMap?M=f.specularMap:f.displacementMap?M=f.displacementMap:f.normalMap?M=f.normalMap:f.bumpMap?M=f.bumpMap:f.roughnessMap?M=f.roughnessMap:f.metalnessMap?M=f.metalnessMap:f.alphaMap?M=f.alphaMap:f.emissiveMap?M=f.emissiveMap:f.clearcoatMap?M=f.clearcoatMap:f.clearcoatNormalMap?M=f.clearcoatNormalMap:f.clearcoatRoughnessMap&&(M=f.clearcoatRoughnessMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),p.uvTransform.value.copy(M.matrix));let S;f.aoMap?S=f.aoMap:f.lightMap&&(S=f.lightMap),S!==void 0&&(S.isWebGLRenderTarget&&(S=S.texture),S.matrixAutoUpdate===!0&&S.updateMatrix(),p.uv2Transform.value.copy(S.matrix))}function i(p,f){p.diffuse.value.copy(f.color),p.opacity.value=f.opacity}function s(p,f){p.dashSize.value=f.dashSize,p.totalSize.value=f.dashSize+f.gapSize,p.scale.value=f.scale}function a(p,f,b,M){p.diffuse.value.copy(f.color),p.opacity.value=f.opacity,p.size.value=f.size*b,p.scale.value=M*.5,f.map&&(p.map.value=f.map),f.alphaMap&&(p.alphaMap.value=f.alphaMap);let S;f.map?S=f.map:f.alphaMap&&(S=f.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),p.uvTransform.value.copy(S.matrix))}function o(p,f){p.diffuse.value.copy(f.color),p.opacity.value=f.opacity,p.rotation.value=f.rotation,f.map&&(p.map.value=f.map),f.alphaMap&&(p.alphaMap.value=f.alphaMap);let b;f.map?b=f.map:f.alphaMap&&(b=f.alphaMap),b!==void 0&&(b.matrixAutoUpdate===!0&&b.updateMatrix(),p.uvTransform.value.copy(b.matrix))}function l(p,f){f.emissiveMap&&(p.emissiveMap.value=f.emissiveMap)}function c(p,f){p.specular.value.copy(f.specular),p.shininess.value=Math.max(f.shininess,1e-4),f.emissiveMap&&(p.emissiveMap.value=f.emissiveMap),f.bumpMap&&(p.bumpMap.value=f.bumpMap,p.bumpScale.value=f.bumpScale,f.side===Pt&&(p.bumpScale.value*=-1)),f.normalMap&&(p.normalMap.value=f.normalMap,p.normalScale.value.copy(f.normalScale),f.side===Pt&&p.normalScale.value.negate()),f.displacementMap&&(p.displacementMap.value=f.displacementMap,p.displacementScale.value=f.displacementScale,p.displacementBias.value=f.displacementBias)}function d(p,f){f.gradientMap&&(p.gradientMap.value=f.gradientMap),f.emissiveMap&&(p.emissiveMap.value=f.emissiveMap),f.bumpMap&&(p.bumpMap.value=f.bumpMap,p.bumpScale.value=f.bumpScale,f.side===Pt&&(p.bumpScale.value*=-1)),f.normalMap&&(p.normalMap.value=f.normalMap,p.normalScale.value.copy(f.normalScale),f.side===Pt&&p.normalScale.value.negate()),f.displacementMap&&(p.displacementMap.value=f.displacementMap,p.displacementScale.value=f.displacementScale,p.displacementBias.value=f.displacementBias)}function u(p,f){p.roughness.value=f.roughness,p.metalness.value=f.metalness,f.roughnessMap&&(p.roughnessMap.value=f.roughnessMap),f.metalnessMap&&(p.metalnessMap.value=f.metalnessMap),f.emissiveMap&&(p.emissiveMap.value=f.emissiveMap),f.bumpMap&&(p.bumpMap.value=f.bumpMap,p.bumpScale.value=f.bumpScale,f.side===Pt&&(p.bumpScale.value*=-1)),f.normalMap&&(p.normalMap.value=f.normalMap,p.normalScale.value.copy(f.normalScale),f.side===Pt&&p.normalScale.value.negate()),f.displacementMap&&(p.displacementMap.value=f.displacementMap,p.displacementScale.value=f.displacementScale,p.displacementBias.value=f.displacementBias),r.get(f).envMap&&(p.envMapIntensity.value=f.envMapIntensity)}function h(p,f){u(p,f),p.reflectivity.value=f.reflectivity,p.clearcoat.value=f.clearcoat,p.clearcoatRoughness.value=f.clearcoatRoughness,f.sheen&&p.sheen.value.copy(f.sheen),f.clearcoatMap&&(p.clearcoatMap.value=f.clearcoatMap),f.clearcoatRoughnessMap&&(p.clearcoatRoughnessMap.value=f.clearcoatRoughnessMap),f.clearcoatNormalMap&&(p.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),p.clearcoatNormalMap.value=f.clearcoatNormalMap,f.side===Pt&&p.clearcoatNormalScale.value.negate()),p.transmission.value=f.transmission,f.transmissionMap&&(p.transmissionMap.value=f.transmissionMap)}function m(p,f){f.matcap&&(p.matcap.value=f.matcap),f.bumpMap&&(p.bumpMap.value=f.bumpMap,p.bumpScale.value=f.bumpScale,f.side===Pt&&(p.bumpScale.value*=-1)),f.normalMap&&(p.normalMap.value=f.normalMap,p.normalScale.value.copy(f.normalScale),f.side===Pt&&p.normalScale.value.negate()),f.displacementMap&&(p.displacementMap.value=f.displacementMap,p.displacementScale.value=f.displacementScale,p.displacementBias.value=f.displacementBias)}function _(p,f){f.displacementMap&&(p.displacementMap.value=f.displacementMap,p.displacementScale.value=f.displacementScale,p.displacementBias.value=f.displacementBias)}function v(p,f){f.displacementMap&&(p.displacementMap.value=f.displacementMap,p.displacementScale.value=f.displacementScale,p.displacementBias.value=f.displacementBias),p.referencePosition.value.copy(f.referencePosition),p.nearDistance.value=f.nearDistance,p.farDistance.value=f.farDistance}function y(p,f){f.bumpMap&&(p.bumpMap.value=f.bumpMap,p.bumpScale.value=f.bumpScale,f.side===Pt&&(p.bumpScale.value*=-1)),f.normalMap&&(p.normalMap.value=f.normalMap,p.normalScale.value.copy(f.normalScale),f.side===Pt&&p.normalScale.value.negate()),f.displacementMap&&(p.displacementMap.value=f.displacementMap,p.displacementScale.value=f.displacementScale,p.displacementBias.value=f.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function lv(){const r=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return r.style.display="block",r}function yt(r){r=r||{};const e=r.canvas!==void 0?r.canvas:lv(),t=r.context!==void 0?r.context:null,n=r.alpha!==void 0?r.alpha:!1,i=r.depth!==void 0?r.depth:!0,s=r.stencil!==void 0?r.stencil:!0,a=r.antialias!==void 0?r.antialias:!1,o=r.premultipliedAlpha!==void 0?r.premultipliedAlpha:!0,l=r.preserveDrawingBuffer!==void 0?r.preserveDrawingBuffer:!1,c=r.powerPreference!==void 0?r.powerPreference:"default",d=r.failIfMajorPerformanceCaveat!==void 0?r.failIfMajorPerformanceCaveat:!1;let u=null,h=null;const m=[],_=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=sn,this.physicallyCorrectLights=!1,this.toneMapping=Ii,this.toneMappingExposure=1;const v=this;let y=!1,p=0,f=0,b=null,M=-1,S=null;const x=new gt,I=new gt;let V=null,Y=e.width,j=e.height,G=1,q=null,C=null;const W=new gt(0,0,Y,j),z=new gt(0,0,Y,j);let E=!1;const N=new xa;let K=!1,J=!1;const T=new Ve,O=new P,H={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function ee(){return b===null?G:1}let B=t;function ne(g,A){for(let R=0;R<g.length;R++){const F=g[R],te=e.getContext(F,A);if(te!==null)return te}return null}try{const g={alpha:n,depth:i,stencil:s,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:d};if(e.addEventListener("webglcontextlost",We,!1),e.addEventListener("webglcontextrestored",it,!1),B===null){const A=["webgl2","webgl","experimental-webgl"];if(v.isWebGL1Renderer===!0&&A.shift(),B=ne(A,g),B===null)throw ne(A)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}B.getShaderPrecisionFormat===void 0&&(B.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(g){throw console.error("THREE.WebGLRenderer: "+g.message),g}let Q,se,re,be,me,Ne,ue,le,ae,Le,de,D,L,ce,oe,Te,Be,qe,X,U,_e,Se;function De(){Q=new Cy(B),se=new Ay(B,Q,r),Q.init(se),_e=new sv(B,Q,se),re=new nv(B,Q,se),be=new Dy,me=new W_,Ne=new iv(B,Q,re,me,se,_e,be),ue=new Ry(v),le=new nm(B,se),Se=new Ty(B,Q,le,se),ae=new Iy(B,le,be,Se),Le=new ky(B,ae,le,be),qe=new By(B),oe=new Ly(me),de=new V_(v,ue,Q,se,Se,oe),D=new ov(me),L=new X_(me),ce=new Q_(Q,se),Be=new Sy(v,ue,re,Le,o),Te=new hu(v,Le,se),X=new Ey(B,Q,be,se),U=new Py(B,Q,be,se),be.programs=de.programs,v.capabilities=se,v.extensions=Q,v.properties=me,v.renderLists=L,v.shadowMap=Te,v.state=re,v.info=be}De();const ve=new av(v,B);this.xr=ve,this.getContext=function(){return B},this.getContextAttributes=function(){return B.getContextAttributes()},this.forceContextLoss=function(){const g=Q.get("WEBGL_lose_context");g&&g.loseContext()},this.forceContextRestore=function(){const g=Q.get("WEBGL_lose_context");g&&g.restoreContext()},this.getPixelRatio=function(){return G},this.setPixelRatio=function(g){g!==void 0&&(G=g,this.setSize(Y,j,!1))},this.getSize=function(g){return g===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),g=new Ae),g.set(Y,j)},this.setSize=function(g,A,R){if(ve.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}Y=g,j=A,e.width=Math.floor(g*G),e.height=Math.floor(A*G),R!==!1&&(e.style.width=g+"px",e.style.height=A+"px"),this.setViewport(0,0,g,A)},this.getDrawingBufferSize=function(g){return g===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),g=new Ae),g.set(Y*G,j*G).floor()},this.setDrawingBufferSize=function(g,A,R){Y=g,j=A,G=R,e.width=Math.floor(g*R),e.height=Math.floor(A*R),this.setViewport(0,0,g,A)},this.getCurrentViewport=function(g){return g===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),g=new gt),g.copy(x)},this.getViewport=function(g){return g.copy(W)},this.setViewport=function(g,A,R,F){g.isVector4?W.set(g.x,g.y,g.z,g.w):W.set(g,A,R,F),re.viewport(x.copy(W).multiplyScalar(G).floor())},this.getScissor=function(g){return g.copy(z)},this.setScissor=function(g,A,R,F){g.isVector4?z.set(g.x,g.y,g.z,g.w):z.set(g,A,R,F),re.scissor(I.copy(z).multiplyScalar(G).floor())},this.getScissorTest=function(){return E},this.setScissorTest=function(g){re.setScissorTest(E=g)},this.setOpaqueSort=function(g){q=g},this.setTransparentSort=function(g){C=g},this.getClearColor=function(g){return g===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),g=new ke),g.copy(Be.getClearColor())},this.setClearColor=function(){Be.setClearColor.apply(Be,arguments)},this.getClearAlpha=function(){return Be.getClearAlpha()},this.setClearAlpha=function(){Be.setClearAlpha.apply(Be,arguments)},this.clear=function(g,A,R){let F=0;(g===void 0||g)&&(F|=16384),(A===void 0||A)&&(F|=256),(R===void 0||R)&&(F|=1024),B.clear(F)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",We,!1),e.removeEventListener("webglcontextrestored",it,!1),L.dispose(),ce.dispose(),me.dispose(),ue.dispose(),Le.dispose(),Se.dispose(),ve.dispose(),ve.removeEventListener("sessionstart",wi),ve.removeEventListener("sessionend",zi),Yt.stop()};function We(g){g.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),y=!0}function it(){console.log("THREE.WebGLRenderer: Context Restored."),y=!1;const g=be.autoReset,A=Te.enabled,R=Te.autoUpdate,F=Te.needsUpdate,te=Te.type;De(),be.autoReset=g,Te.enabled=A,Te.autoUpdate=R,Te.needsUpdate=F,Te.type=te}function rt(g){const A=g.target;A.removeEventListener("dispose",rt),vt(A)}function vt(g){mt(g),me.remove(g)}function mt(g){const A=me.get(g).programs;A!==void 0&&A.forEach(function(R){de.releaseProgram(R)})}function It(g,A){g.render(function(R){v.renderBufferImmediate(R,A)})}this.renderBufferImmediate=function(g,A){Se.initAttributes();const R=me.get(g);g.hasPositions&&!R.position&&(R.position=B.createBuffer()),g.hasNormals&&!R.normal&&(R.normal=B.createBuffer()),g.hasUvs&&!R.uv&&(R.uv=B.createBuffer()),g.hasColors&&!R.color&&(R.color=B.createBuffer());const F=A.getAttributes();g.hasPositions&&(B.bindBuffer(34962,R.position),B.bufferData(34962,g.positionArray,35048),Se.enableAttribute(F.position),B.vertexAttribPointer(F.position,3,5126,!1,0,0)),g.hasNormals&&(B.bindBuffer(34962,R.normal),B.bufferData(34962,g.normalArray,35048),Se.enableAttribute(F.normal),B.vertexAttribPointer(F.normal,3,5126,!1,0,0)),g.hasUvs&&(B.bindBuffer(34962,R.uv),B.bufferData(34962,g.uvArray,35048),Se.enableAttribute(F.uv),B.vertexAttribPointer(F.uv,2,5126,!1,0,0)),g.hasColors&&(B.bindBuffer(34962,R.color),B.bufferData(34962,g.colorArray,35048),Se.enableAttribute(F.color),B.vertexAttribPointer(F.color,3,5126,!1,0,0)),Se.disableUnusedAttributes(),B.drawArrays(4,0,g.count),g.count=0},this.renderBufferDirect=function(g,A,R,F,te,he){A===null&&(A=H);const ie=te.isMesh&&te.matrixWorld.determinant()<0,ge=On(g,A,F,te);re.setMaterial(F,ie);let Ee=R.index;const Me=R.attributes.position;if(Ee===null){if(Me===void 0||Me.count===0)return}else if(Ee.count===0)return;let Oe=1;F.wireframe===!0&&(Ee=ae.getWireframeAttribute(R),Oe=2),(F.morphTargets||F.morphNormals)&&qe.update(te,R,F,ge),Se.setup(te,F,ge,R,Ee);let Fe,Ue=X;Ee!==null&&(Fe=le.get(Ee),Ue=U,Ue.setIndex(Fe));const Je=Ee!==null?Ee.count:Me.count,je=R.drawRange.start*Oe,Ke=R.drawRange.count*Oe,we=he!==null?he.start*Oe:0,ze=he!==null?he.count*Oe:1/0,Ce=Math.max(je,we),tt=Math.min(Je,je+Ke,we+ze)-1,Ge=Math.max(0,tt-Ce+1);if(Ge!==0){if(te.isMesh)F.wireframe===!0?(re.setLineWidth(F.wireframeLinewidth*ee()),Ue.setMode(1)):Ue.setMode(4);else if(te.isLine){let st=F.linewidth;st===void 0&&(st=1),re.setLineWidth(st*ee()),te.isLineSegments?Ue.setMode(1):te.isLineLoop?Ue.setMode(2):Ue.setMode(3)}else te.isPoints?Ue.setMode(0):te.isSprite&&Ue.setMode(4);if(te.isInstancedMesh)Ue.renderInstances(Ce,Ge,te.count);else if(R.isInstancedBufferGeometry){const st=Math.min(R.instanceCount,R._maxInstanceCount);Ue.renderInstances(Ce,Ge,st)}else Ue.render(Ce,Ge)}},this.compile=function(g,A){h=ce.get(g),h.init(),g.traverseVisible(function(R){R.isLight&&R.layers.test(A.layers)&&(h.pushLight(R),R.castShadow&&h.pushShadow(R))}),h.setupLights(),g.traverse(function(R){const F=R.material;if(F)if(Array.isArray(F))for(let te=0;te<F.length;te++){const he=F[te];Jn(he,g,R)}else Jn(F,g,R)})};let jt=null;function yn(g){jt&&jt(g)}function wi(){Yt.stop()}function zi(){Yt.start()}const Yt=new eu;Yt.setAnimationLoop(yn),typeof window<"u"&&Yt.setContext(window),this.setAnimationLoop=function(g){jt=g,ve.setAnimationLoop(g),g===null?Yt.stop():Yt.start()},ve.addEventListener("sessionstart",wi),ve.addEventListener("sessionend",zi),this.render=function(g,A){let R,F;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),R=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),F=arguments[3]),A!==void 0&&A.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(y===!0)return;g.autoUpdate===!0&&g.updateMatrixWorld(),A.parent===null&&A.updateMatrixWorld(),ve.enabled===!0&&ve.isPresenting===!0&&(A=ve.getCamera(A)),g.isScene===!0&&g.onBeforeRender(v,g,A,R||b),h=ce.get(g,_.length),h.init(),_.push(h),T.multiplyMatrices(A.projectionMatrix,A.matrixWorldInverse),N.setFromProjectionMatrix(T),J=this.localClippingEnabled,K=oe.init(this.clippingPlanes,J,A),u=L.get(g,m.length),u.init(),m.push(u),Mi(g,A,0,v.sortObjects),u.finish(),v.sortObjects===!0&&u.sort(q,C),K===!0&&oe.beginShadows();const te=h.state.shadowsArray;Te.render(te,g,A),h.setupLights(),h.setupLightsView(A),K===!0&&oe.endShadows(),this.info.autoReset===!0&&this.info.reset(),R!==void 0&&this.setRenderTarget(R),Be.render(u,g,A,F);const he=u.opaque,ie=u.transparent;he.length>0&&Si(he,g,A),ie.length>0&&Si(ie,g,A),b!==null&&(Ne.updateRenderTargetMipmap(b),Ne.updateMultisampleRenderTarget(b)),g.isScene===!0&&g.onAfterRender(v,g,A),re.buffers.depth.setTest(!0),re.buffers.depth.setMask(!0),re.buffers.color.setMask(!0),re.setPolygonOffset(!1),Se.resetDefaultState(),M=-1,S=null,_.pop(),_.length>0?h=_[_.length-1]:h=null,m.pop(),m.length>0?u=m[m.length-1]:u=null};function Mi(g,A,R,F){if(g.visible===!1)return;if(g.layers.test(A.layers)){if(g.isGroup)R=g.renderOrder;else if(g.isLOD)g.autoUpdate===!0&&g.update(A);else if(g.isLight)h.pushLight(g),g.castShadow&&h.pushShadow(g);else if(g.isSprite){if(!g.frustumCulled||N.intersectsSprite(g)){F&&O.setFromMatrixPosition(g.matrixWorld).applyMatrix4(T);const ie=Le.update(g),ge=g.material;ge.visible&&u.push(g,ie,ge,R,O.z,null)}}else if(g.isImmediateRenderObject)F&&O.setFromMatrixPosition(g.matrixWorld).applyMatrix4(T),u.push(g,null,g.material,R,O.z,null);else if((g.isMesh||g.isLine||g.isPoints)&&(g.isSkinnedMesh&&g.skeleton.frame!==be.render.frame&&(g.skeleton.update(),g.skeleton.frame=be.render.frame),!g.frustumCulled||N.intersectsObject(g))){F&&O.setFromMatrixPosition(g.matrixWorld).applyMatrix4(T);const ie=Le.update(g),ge=g.material;if(Array.isArray(ge)){const Ee=ie.groups;for(let Me=0,Oe=Ee.length;Me<Oe;Me++){const Fe=Ee[Me],Ue=ge[Fe.materialIndex];Ue&&Ue.visible&&u.push(g,ie,Ue,R,O.z,Fe)}}else ge.visible&&u.push(g,ie,ge,R,O.z,null)}}const he=g.children;for(let ie=0,ge=he.length;ie<ge;ie++)Mi(he[ie],A,R,F)}function Si(g,A,R){const F=A.isScene===!0?A.overrideMaterial:null;for(let te=0,he=g.length;te<he;te++){const ie=g[te],ge=ie.object,Ee=ie.geometry,Me=F===null?ie.material:F,Oe=ie.group;if(R.isArrayCamera){const Fe=R.cameras;for(let Ue=0,Je=Fe.length;Ue<Je;Ue++){const je=Fe[Ue];ge.layers.test(je.layers)&&(re.viewport(x.copy(je.viewport)),h.setupLightsView(je),Ui(ge,A,je,Ee,Me,Oe))}}else Ui(ge,A,R,Ee,Me,Oe)}}function Ui(g,A,R,F,te,he){if(g.onBeforeRender(v,A,R,F,te,he),g.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse,g.matrixWorld),g.normalMatrix.getNormalMatrix(g.modelViewMatrix),g.isImmediateRenderObject){const ie=On(R,A,te,g);re.setMaterial(te),Se.reset(),It(g,ie)}else v.renderBufferDirect(R,A,F,te,g,he);g.onAfterRender(v,A,R,F,te,he)}function Jn(g,A,R){A.isScene!==!0&&(A=H);const F=me.get(g),te=h.state.lights,he=h.state.shadowsArray,ie=te.state.version,ge=de.getParameters(g,te.state,he,A,R),Ee=de.getProgramCacheKey(ge);let Me=F.programs;F.environment=g.isMeshStandardMaterial?A.environment:null,F.fog=A.fog,F.envMap=ue.get(g.envMap||F.environment),Me===void 0&&(g.addEventListener("dispose",rt),Me=new Map,F.programs=Me);let Oe=Me.get(Ee);if(Oe!==void 0){if(F.currentProgram===Oe&&F.lightsStateVersion===ie)return Pe(g,ge),Oe}else ge.uniforms=de.getUniforms(g),g.onBuild(ge,v),g.onBeforeCompile(ge,v),Oe=de.acquireProgram(ge,Ee),Me.set(Ee,Oe),F.uniforms=ge.uniforms;const Fe=F.uniforms;(!g.isShaderMaterial&&!g.isRawShaderMaterial||g.clipping===!0)&&(Fe.clippingPlanes=oe.uniform),Pe(g,ge),F.needsLights=ln(g),F.lightsStateVersion=ie,F.needsLights&&(Fe.ambientLightColor.value=te.state.ambient,Fe.lightProbe.value=te.state.probe,Fe.directionalLights.value=te.state.directional,Fe.directionalLightShadows.value=te.state.directionalShadow,Fe.spotLights.value=te.state.spot,Fe.spotLightShadows.value=te.state.spotShadow,Fe.rectAreaLights.value=te.state.rectArea,Fe.ltc_1.value=te.state.rectAreaLTC1,Fe.ltc_2.value=te.state.rectAreaLTC2,Fe.pointLights.value=te.state.point,Fe.pointLightShadows.value=te.state.pointShadow,Fe.hemisphereLights.value=te.state.hemi,Fe.directionalShadowMap.value=te.state.directionalShadowMap,Fe.directionalShadowMatrix.value=te.state.directionalShadowMatrix,Fe.spotShadowMap.value=te.state.spotShadowMap,Fe.spotShadowMatrix.value=te.state.spotShadowMatrix,Fe.pointShadowMap.value=te.state.pointShadowMap,Fe.pointShadowMatrix.value=te.state.pointShadowMatrix);const Ue=Oe.getUniforms(),Je=pi.seqWithValue(Ue.seq,Fe);return F.currentProgram=Oe,F.uniformsList=Je,Oe}function Pe(g,A){const R=me.get(g);R.outputEncoding=A.outputEncoding,R.instancing=A.instancing,R.numClippingPlanes=A.numClippingPlanes,R.numIntersection=A.numClipIntersection,R.vertexAlphas=A.vertexAlphas}function On(g,A,R,F){A.isScene!==!0&&(A=H),Ne.resetTextureUnits();const te=A.fog,he=R.isMeshStandardMaterial?A.environment:null,ie=b===null?v.outputEncoding:b.texture.encoding,ge=ue.get(R.envMap||he),Ee=R.vertexColors===!0&&F.geometry&&F.geometry.attributes.color&&F.geometry.attributes.color.itemSize===4,Me=me.get(R),Oe=h.state.lights;if(K===!0&&(J===!0||g!==S)){const Ce=g===S&&R.id===M;oe.setState(R,g,Ce)}let Fe=!1;R.version===Me.__version?(Me.needsLights&&Me.lightsStateVersion!==Oe.state.version||Me.outputEncoding!==ie||F.isInstancedMesh&&Me.instancing===!1||!F.isInstancedMesh&&Me.instancing===!0||Me.envMap!==ge||R.fog&&Me.fog!==te||Me.numClippingPlanes!==void 0&&(Me.numClippingPlanes!==oe.numPlanes||Me.numIntersection!==oe.numIntersection)||Me.vertexAlphas!==Ee)&&(Fe=!0):(Fe=!0,Me.__version=R.version);let Ue=Me.currentProgram;Fe===!0&&(Ue=Jn(R,A,F));let Je=!1,je=!1,Ke=!1;const we=Ue.getUniforms(),ze=Me.uniforms;if(re.useProgram(Ue.program)&&(Je=!0,je=!0,Ke=!0),R.id!==M&&(M=R.id,je=!0),Je||S!==g){if(we.setValue(B,"projectionMatrix",g.projectionMatrix),se.logarithmicDepthBuffer&&we.setValue(B,"logDepthBufFC",2/(Math.log(g.far+1)/Math.LN2)),S!==g&&(S=g,je=!0,Ke=!0),R.isShaderMaterial||R.isMeshPhongMaterial||R.isMeshToonMaterial||R.isMeshStandardMaterial||R.envMap){const Ce=we.map.cameraPosition;Ce!==void 0&&Ce.setValue(B,O.setFromMatrixPosition(g.matrixWorld))}(R.isMeshPhongMaterial||R.isMeshToonMaterial||R.isMeshLambertMaterial||R.isMeshBasicMaterial||R.isMeshStandardMaterial||R.isShaderMaterial)&&we.setValue(B,"isOrthographic",g.isOrthographicCamera===!0),(R.isMeshPhongMaterial||R.isMeshToonMaterial||R.isMeshLambertMaterial||R.isMeshBasicMaterial||R.isMeshStandardMaterial||R.isShaderMaterial||R.isShadowMaterial||R.skinning)&&we.setValue(B,"viewMatrix",g.matrixWorldInverse)}if(R.skinning){we.setOptional(B,F,"bindMatrix"),we.setOptional(B,F,"bindMatrixInverse");const Ce=F.skeleton;if(Ce){const tt=Ce.bones;if(se.floatVertexTextures){if(Ce.boneTexture===null){let Ge=Math.sqrt(tt.length*4);Ge=qd(Ge),Ge=Math.max(Ge,4);const st=new Float32Array(Ge*Ge*4);st.set(Ce.boneMatrices);const kt=new Qd(st,Ge,Ge,pn,di);Ce.boneMatrices=st,Ce.boneTexture=kt,Ce.boneTextureSize=Ge}we.setValue(B,"boneTexture",Ce.boneTexture,Ne),we.setValue(B,"boneTextureSize",Ce.boneTextureSize)}else we.setOptional(B,Ce,"boneMatrices")}}return(je||Me.receiveShadow!==F.receiveShadow)&&(Me.receiveShadow=F.receiveShadow,we.setValue(B,"receiveShadow",F.receiveShadow)),je&&(we.setValue(B,"toneMappingExposure",v.toneMappingExposure),Me.needsLights&&Qn(ze,Ke),te&&R.fog&&D.refreshFogUniforms(ze,te),D.refreshMaterialUniforms(ze,R,G,j),pi.upload(B,Me.uniformsList,ze,Ne)),R.isShaderMaterial&&R.uniformsNeedUpdate===!0&&(pi.upload(B,Me.uniformsList,ze,Ne),R.uniformsNeedUpdate=!1),R.isSpriteMaterial&&we.setValue(B,"center",F.center),we.setValue(B,"modelViewMatrix",F.modelViewMatrix),we.setValue(B,"normalMatrix",F.normalMatrix),we.setValue(B,"modelMatrix",F.matrixWorld),Ue}function Qn(g,A){g.ambientLightColor.needsUpdate=A,g.lightProbe.needsUpdate=A,g.directionalLights.needsUpdate=A,g.directionalLightShadows.needsUpdate=A,g.pointLights.needsUpdate=A,g.pointLightShadows.needsUpdate=A,g.spotLights.needsUpdate=A,g.spotLightShadows.needsUpdate=A,g.rectAreaLights.needsUpdate=A,g.hemisphereLights.needsUpdate=A}function ln(g){return g.isMeshLambertMaterial||g.isMeshToonMaterial||g.isMeshPhongMaterial||g.isMeshStandardMaterial||g.isShadowMaterial||g.isShaderMaterial&&g.lights===!0}this.getActiveCubeFace=function(){return p},this.getActiveMipmapLevel=function(){return f},this.getRenderTarget=function(){return b},this.setRenderTarget=function(g,A=0,R=0){b=g,p=A,f=R,g&&me.get(g).__webglFramebuffer===void 0&&Ne.setupRenderTarget(g);let F=null,te=!1,he=!1;if(g){const ie=g.texture;(ie.isDataTexture3D||ie.isDataTexture2DArray)&&(he=!0);const ge=me.get(g).__webglFramebuffer;g.isWebGLCubeRenderTarget?(F=ge[A],te=!0):g.isWebGLMultisampleRenderTarget?F=me.get(g).__webglMultisampledFramebuffer:F=ge,x.copy(g.viewport),I.copy(g.scissor),V=g.scissorTest}else x.copy(W).multiplyScalar(G).floor(),I.copy(z).multiplyScalar(G).floor(),V=E;if(re.bindFramebuffer(36160,F),re.viewport(x),re.scissor(I),re.setScissorTest(V),te){const ie=me.get(g.texture);B.framebufferTexture2D(36160,36064,34069+A,ie.__webglTexture,R)}else if(he){const ie=me.get(g.texture),ge=A||0;B.framebufferTextureLayer(36160,36064,ie.__webglTexture,R||0,ge)}},this.readRenderTargetPixels=function(g,A,R,F,te,he,ie){if(!(g&&g.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let ge=me.get(g).__webglFramebuffer;if(g.isWebGLCubeRenderTarget&&ie!==void 0&&(ge=ge[ie]),ge){re.bindFramebuffer(36160,ge);try{const Ee=g.texture,Me=Ee.format,Oe=Ee.type;if(Me!==pn&&_e.convert(Me)!==B.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Fe=Oe===ha&&(Q.has("EXT_color_buffer_half_float")||se.isWebGL2&&Q.has("EXT_color_buffer_float"));if(Oe!==wr&&_e.convert(Oe)!==B.getParameter(35738)&&!(Oe===di&&(se.isWebGL2||Q.has("OES_texture_float")||Q.has("WEBGL_color_buffer_float")))&&!Fe){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}B.checkFramebufferStatus(36160)===36053?A>=0&&A<=g.width-F&&R>=0&&R<=g.height-te&&B.readPixels(A,R,F,te,_e.convert(Me),_e.convert(Oe),he):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Ee=b!==null?me.get(b).__webglFramebuffer:null;re.bindFramebuffer(36160,Ee)}}},this.copyFramebufferToTexture=function(g,A,R=0){const F=Math.pow(2,-R),te=Math.floor(A.image.width*F),he=Math.floor(A.image.height*F),ie=_e.convert(A.format);Ne.setTexture2D(A,0),B.copyTexImage2D(3553,R,ie,g.x,g.y,te,he,0),re.unbindTexture()},this.copyTextureToTexture=function(g,A,R,F=0){const te=A.image.width,he=A.image.height,ie=_e.convert(R.format),ge=_e.convert(R.type);Ne.setTexture2D(R,0),B.pixelStorei(37440,R.flipY),B.pixelStorei(37441,R.premultiplyAlpha),B.pixelStorei(3317,R.unpackAlignment),A.isDataTexture?B.texSubImage2D(3553,F,g.x,g.y,te,he,ie,ge,A.image.data):A.isCompressedTexture?B.compressedTexSubImage2D(3553,F,g.x,g.y,A.mipmaps[0].width,A.mipmaps[0].height,ie,A.mipmaps[0].data):B.texSubImage2D(3553,F,g.x,g.y,ie,ge,A.image),F===0&&R.generateMipmaps&&B.generateMipmap(3553),re.unbindTexture()},this.copyTextureToTexture3D=function(g,A,R,F,te=0){if(v.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const{width:he,height:ie,data:ge}=R.image,Ee=_e.convert(F.format),Me=_e.convert(F.type);let Oe;if(F.isDataTexture3D)Ne.setTexture3D(F,0),Oe=32879;else if(F.isDataTexture2DArray)Ne.setTexture2DArray(F,0),Oe=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}B.pixelStorei(37440,F.flipY),B.pixelStorei(37441,F.premultiplyAlpha),B.pixelStorei(3317,F.unpackAlignment);const Fe=B.getParameter(3314),Ue=B.getParameter(32878),Je=B.getParameter(3316),je=B.getParameter(3315),Ke=B.getParameter(32877);B.pixelStorei(3314,he),B.pixelStorei(32878,ie),B.pixelStorei(3316,g.min.x),B.pixelStorei(3315,g.min.y),B.pixelStorei(32877,g.min.z),B.texSubImage3D(Oe,te,A.x,A.y,A.z,g.max.x-g.min.x+1,g.max.y-g.min.y+1,g.max.z-g.min.z+1,Ee,Me,ge),B.pixelStorei(3314,Fe),B.pixelStorei(32878,Ue),B.pixelStorei(3316,Je),B.pixelStorei(3315,je),B.pixelStorei(32877,Ke),te===0&&F.generateMipmaps&&B.generateMipmap(Oe),re.unbindTexture()},this.initTexture=function(g){Ne.setTexture2D(g,0),re.unbindTexture()},this.resetState=function(){p=0,f=0,b=null,re.reset(),Se.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class cv extends yt{}cv.prototype.isWebGL1Renderer=!0;class ba extends ht{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.background!==null&&(t.object.background=this.background.toJSON(e)),this.environment!==null&&(t.object.environment=this.environment.toJSON(e)),this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}ba.prototype.isScene=!0;class bi{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=hr,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=mn(),this.onUploadCallback=function(){}}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,s=this.stride;i<s;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=mn()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new bi(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=mn()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}bi.prototype.isInterleavedBuffer=!0;const Lt=new P;class Es{constructor(e,t,n,i){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Lt.x=this.getX(t),Lt.y=this.getY(t),Lt.z=this.getZ(t),Lt.applyMatrix4(e),this.setXYZ(t,Lt.x,Lt.y,Lt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Lt.x=this.getX(t),Lt.y=this.getY(t),Lt.z=this.getZ(t),Lt.applyNormalMatrix(e),this.setXYZ(t,Lt.x,Lt.y,Lt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Lt.x=this.getX(t),Lt.y=this.getY(t),Lt.z=this.getZ(t),Lt.transformDirection(e),this.setXYZ(t,Lt.x,Lt.y,Lt.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,s){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return new Tt(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Es(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Es.prototype.isInterleavedBufferAttribute=!0;class pu extends Ct{constructor(e){super(),this.type="SpriteMaterial",this.color=new ke(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}pu.prototype.isSpriteMaterial=!0;let rs;const $s=new P,as=new P,os=new P,ls=new Ae,Xs=new Ae,mu=new Ve,Yr=new P,js=new P,Zr=new P,kc=new Ae,vo=new Ae,Oc=new Ae;class dv extends ht{constructor(e){if(super(),this.type="Sprite",rs===void 0){rs=new pt;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new bi(t,5);rs.setIndex([0,1,2,0,2,3]),rs.setAttribute("position",new Es(n,3,0,!1)),rs.setAttribute("uv",new Es(n,2,3,!1))}this.geometry=rs,this.material=e!==void 0?e:new pu,this.center=new Ae(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),as.setFromMatrixScale(this.matrixWorld),mu.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),os.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&as.multiplyScalar(-os.z);const n=this.material.rotation;let i,s;n!==0&&(s=Math.cos(n),i=Math.sin(n));const a=this.center;Kr(Yr.set(-.5,-.5,0),os,a,as,i,s),Kr(js.set(.5,-.5,0),os,a,as,i,s),Kr(Zr.set(.5,.5,0),os,a,as,i,s),kc.set(0,0),vo.set(1,0),Oc.set(1,1);let o=e.ray.intersectTriangle(Yr,js,Zr,!1,$s);if(o===null&&(Kr(js.set(-.5,.5,0),os,a,as,i,s),vo.set(0,1),o=e.ray.intersectTriangle(Yr,Zr,js,!1,$s),o===null))return;const l=e.ray.origin.distanceTo($s);l<e.near||l>e.far||t.push({distance:l,point:$s.clone(),uv:Dt.getUV($s,Yr,js,Zr,kc,vo,Oc,new Ae),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}dv.prototype.isSprite=!0;function Kr(r,e,t,n,i,s){ls.subVectors(r,t).addScalar(.5).multiply(n),i!==void 0?(Xs.x=s*ls.x-i*ls.y,Xs.y=i*ls.x+s*ls.y):Xs.copy(ls),r.copy(e),r.x+=Xs.x,r.y+=Xs.y,r.applyMatrix4(mu)}const zc=new P,Uc=new gt,Hc=new gt,uv=new P,Gc=new Ve;class nl extends dt{constructor(e,t){super(e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Ve,this.bindMatrixInverse=new Ve}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new gt,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,i=this.geometry;Uc.fromBufferAttribute(i.attributes.skinIndex,e),Hc.fromBufferAttribute(i.attributes.skinWeight,e),zc.fromBufferAttribute(i.attributes.position,e).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const a=Hc.getComponent(s);if(a!==0){const o=Uc.getComponent(s);Gc.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),t.addScaledVector(uv.copy(zc).applyMatrix4(Gc),a)}}return t.applyMatrix4(this.bindMatrixInverse)}}nl.prototype.isSkinnedMesh=!0;class il extends ht{constructor(){super(),this.type="Bone"}}il.prototype.isBone=!0;const Vc=new Ve,hv=new Ve;class sl{constructor(e=[],t=[]){this.uuid=mn(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new Ve)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new Ve;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let s=0,a=e.length;s<a;s++){const o=e[s]?e[s].matrixWorld:hv;Vc.multiplyMatrices(o,t[s]),Vc.toArray(n,s*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new sl(this.bones,this.boneInverses)}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const s=e.bones[n];let a=t[s];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),a=new il),this.bones.push(a),this.boneInverses.push(new Ve().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,s=t.length;i<s;i++){const a=t[i];e.bones.push(a.uuid);const o=n[i];e.boneInverses.push(o.toArray())}return e}}const Wc=new Ve,qc=new Ve,Jr=[],Ys=new dt;class fv extends dt{constructor(e,t,n){super(e,t),this.instanceMatrix=new Tt(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const n=this.matrixWorld,i=this.count;if(Ys.geometry=this.geometry,Ys.material=this.material,Ys.material!==void 0)for(let s=0;s<i;s++){this.getMatrixAt(s,Wc),qc.multiplyMatrices(n,Wc),Ys.matrixWorld=qc,Ys.raycast(e,Jr);for(let a=0,o=Jr.length;a<o;a++){const l=Jr[a];l.instanceId=s,l.object=this,t.push(l)}Jr.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Tt(new Float32Array(this.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}fv.prototype.isInstancedMesh=!0;class Oi extends Ct{constructor(e){super(),this.type="LineBasicMaterial",this.color=new ke(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this}}Oi.prototype.isLineBasicMaterial=!0;const $c=new P,Xc=new P,jc=new Ve,xo=new Bi,Qr=new Fi;class Mr extends ht{constructor(e=new pt,t=new Oi){super(),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,s=t.count;i<s;i++)$c.fromBufferAttribute(t,i-1),Xc.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=$c.distanceTo(Xc);e.setAttribute("lineDistance",new Rt(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,s=e.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Qr.copy(n.boundingSphere),Qr.applyMatrix4(i),Qr.radius+=s,e.ray.intersectsSphere(Qr)===!1)return;jc.copy(i).invert(),xo.copy(e.ray).applyMatrix4(jc);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=new P,d=new P,u=new P,h=new P,m=this.isLineSegments?2:1;if(n.isBufferGeometry){const _=n.index,y=n.attributes.position;if(_!==null){const p=Math.max(0,a.start),f=Math.min(_.count,a.start+a.count);for(let b=p,M=f-1;b<M;b+=m){const S=_.getX(b),x=_.getX(b+1);if(c.fromBufferAttribute(y,S),d.fromBufferAttribute(y,x),xo.distanceSqToSegment(c,d,h,u)>l)continue;h.applyMatrix4(this.matrixWorld);const V=e.ray.origin.distanceTo(h);V<e.near||V>e.far||t.push({distance:V,point:u.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}else{const p=Math.max(0,a.start),f=Math.min(y.count,a.start+a.count);for(let b=p,M=f-1;b<M;b+=m){if(c.fromBufferAttribute(y,b),d.fromBufferAttribute(y,b+1),xo.distanceSqToSegment(c,d,h,u)>l)continue;h.applyMatrix4(this.matrixWorld);const x=e.ray.origin.distanceTo(h);x<e.near||x>e.far||t.push({distance:x,point:u.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Mr.prototype.isLine=!0;const Yc=new P,Zc=new P;class wa extends Mr{constructor(e,t){super(e,t),this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,s=t.count;i<s;i+=2)Yc.fromBufferAttribute(t,i),Zc.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+Yc.distanceTo(Zc);e.setAttribute("lineDistance",new Rt(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}wa.prototype.isLineSegments=!0;class gu extends Mr{constructor(e,t){super(e,t),this.type="LineLoop"}}gu.prototype.isLineLoop=!0;class rl extends Ct{constructor(e){super(),this.type="PointsMaterial",this.color=new ke(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this}}rl.prototype.isPointsMaterial=!0;const Kc=new Ve,ko=new Bi,ea=new Fi,ta=new P;class yu extends ht{constructor(e=new pt,t=new rl){super(),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,s=e.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),ea.copy(n.boundingSphere),ea.applyMatrix4(i),ea.radius+=s,e.ray.intersectsSphere(ea)===!1)return;Kc.copy(i).invert(),ko.copy(e.ray).applyMatrix4(Kc);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o;if(n.isBufferGeometry){const c=n.index,u=n.attributes.position;if(c!==null){const h=Math.max(0,a.start),m=Math.min(c.count,a.start+a.count);for(let _=h,v=m;_<v;_++){const y=c.getX(_);ta.fromBufferAttribute(u,y),Jc(ta,y,l,i,e,t,this)}}else{const h=Math.max(0,a.start),m=Math.min(u.count,a.start+a.count);for(let _=h,v=m;_<v;_++)ta.fromBufferAttribute(u,_),Jc(ta,_,l,i,e,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}yu.prototype.isPoints=!0;function Jc(r,e,t,n,i,s,a){const o=ko.distanceSqToPoint(r);if(o<t){const l=new P;ko.closestPointToPoint(r,l),l.applyMatrix4(n);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;s.push({distance:c,distanceToRay:Math.sqrt(o),point:l,index:e,face:null,object:a})}}class pv extends Bt{constructor(e,t,n,i,s,a,o,l,c){super(e,t,n,i,s,a,o,l,c),this.format=o!==void 0?o:hi,this.minFilter=a!==void 0?a:nn,this.magFilter=s!==void 0?s:nn,this.generateMipmaps=!1;const d=this;function u(){d.needsUpdate=!0,e.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(u)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}pv.prototype.isVideoTexture=!0;class mv extends Bt{constructor(e,t,n,i,s,a,o,l,c,d,u,h){super(null,a,o,l,c,d,i,s,u,h),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}mv.prototype.isCompressedTexture=!0;class _u extends Bt{constructor(e,t,n,i,s,a,o,l,c){super(e,t,n,i,s,a,o,l,c),this.needsUpdate=!0}}_u.prototype.isCanvasTexture=!0;class gv extends Bt{constructor(e,t,n,i,s,a,o,l,c,d){if(d=d!==void 0?d:vs,d!==vs&&d!==dr)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&d===vs&&(n=ua),n===void 0&&d===dr&&(n=rr),super(null,i,s,a,o,l,d,n,c),this.image={width:e,height:t},this.magFilter=o!==void 0?o:Ft,this.minFilter=l!==void 0?l:Ft,this.flipY=!1,this.generateMipmaps=!1}}gv.prototype.isDepthTexture=!0;const yv={triangulate:function(r,e,t){t=t||2;const n=e&&e.length,i=n?e[0]*t:r.length;let s=vu(r,0,i,t,!0);const a=[];if(!s||s.next===s.prev)return a;let o,l,c,d,u,h,m;if(n&&(s=wv(r,e,s,t)),r.length>80*t){o=c=r[0],l=d=r[1];for(let _=t;_<i;_+=t)u=r[_],h=r[_+1],u<o&&(o=u),h<l&&(l=h),u>c&&(c=u),h>d&&(d=h);m=Math.max(c-o,d-l),m=m!==0?1/m:0}return pr(s,a,t,o,l,m),a}};function vu(r,e,t,n,i){let s,a;if(i===Dv(r,e,t,n)>0)for(s=e;s<t;s+=n)a=Qc(s,r[s],r[s+1],a);else for(s=t-n;s>=e;s-=n)a=Qc(s,r[s],r[s+1],a);return a&&Ma(a,a.next)&&(gr(a),a=a.next),a}function vi(r,e){if(!r)return r;e||(e=r);let t=r,n;do if(n=!1,!t.steiner&&(Ma(t,t.next)||St(t.prev,t,t.next)===0)){if(gr(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function pr(r,e,t,n,i,s,a){if(!r)return;!a&&s&&Av(r,n,i,s);let o=r,l,c;for(;r.prev!==r.next;){if(l=r.prev,c=r.next,s?vv(r,n,i,s):_v(r)){e.push(l.i/t),e.push(r.i/t),e.push(c.i/t),gr(r),r=c.next,o=c.next;continue}if(r=c,r===o){a?a===1?(r=xv(vi(r),e,t),pr(r,e,t,n,i,s,2)):a===2&&bv(r,e,t,n,i,s):pr(vi(r),e,t,n,i,s,1);break}}}function _v(r){const e=r.prev,t=r,n=r.next;if(St(e,t,n)>=0)return!1;let i=r.next.next;for(;i!==r.prev;){if(ys(e.x,e.y,t.x,t.y,n.x,n.y,i.x,i.y)&&St(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function vv(r,e,t,n){const i=r.prev,s=r,a=r.next;if(St(i,s,a)>=0)return!1;const o=i.x<s.x?i.x<a.x?i.x:a.x:s.x<a.x?s.x:a.x,l=i.y<s.y?i.y<a.y?i.y:a.y:s.y<a.y?s.y:a.y,c=i.x>s.x?i.x>a.x?i.x:a.x:s.x>a.x?s.x:a.x,d=i.y>s.y?i.y>a.y?i.y:a.y:s.y>a.y?s.y:a.y,u=Oo(o,l,e,t,n),h=Oo(c,d,e,t,n);let m=r.prevZ,_=r.nextZ;for(;m&&m.z>=u&&_&&_.z<=h;){if(m!==r.prev&&m!==r.next&&ys(i.x,i.y,s.x,s.y,a.x,a.y,m.x,m.y)&&St(m.prev,m,m.next)>=0||(m=m.prevZ,_!==r.prev&&_!==r.next&&ys(i.x,i.y,s.x,s.y,a.x,a.y,_.x,_.y)&&St(_.prev,_,_.next)>=0))return!1;_=_.nextZ}for(;m&&m.z>=u;){if(m!==r.prev&&m!==r.next&&ys(i.x,i.y,s.x,s.y,a.x,a.y,m.x,m.y)&&St(m.prev,m,m.next)>=0)return!1;m=m.prevZ}for(;_&&_.z<=h;){if(_!==r.prev&&_!==r.next&&ys(i.x,i.y,s.x,s.y,a.x,a.y,_.x,_.y)&&St(_.prev,_,_.next)>=0)return!1;_=_.nextZ}return!0}function xv(r,e,t){let n=r;do{const i=n.prev,s=n.next.next;!Ma(i,s)&&xu(i,n,n.next,s)&&mr(i,s)&&mr(s,i)&&(e.push(i.i/t),e.push(n.i/t),e.push(s.i/t),gr(n),gr(n.next),n=r=s),n=n.next}while(n!==r);return vi(n)}function bv(r,e,t,n,i,s){let a=r;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&Cv(a,o)){let l=bu(a,o);a=vi(a,a.next),l=vi(l,l.next),pr(a,e,t,n,i,s),pr(l,e,t,n,i,s);return}o=o.next}a=a.next}while(a!==r)}function wv(r,e,t,n){const i=[];let s,a,o,l,c;for(s=0,a=e.length;s<a;s++)o=e[s]*n,l=s<a-1?e[s+1]*n:r.length,c=vu(r,o,l,n,!1),c===c.next&&(c.steiner=!0),i.push(Rv(c));for(i.sort(Mv),s=0;s<i.length;s++)Sv(i[s],t),t=vi(t,t.next);return t}function Mv(r,e){return r.x-e.x}function Sv(r,e){if(e=Tv(r,e),e){const t=bu(e,r);vi(e,e.next),vi(t,t.next)}}function Tv(r,e){let t=e;const n=r.x,i=r.y;let s=-1/0,a;do{if(i<=t.y&&i>=t.next.y&&t.next.y!==t.y){const h=t.x+(i-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(h<=n&&h>s){if(s=h,h===n){if(i===t.y)return t;if(i===t.next.y)return t.next}a=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!a)return null;if(n===s)return a;const o=a,l=a.x,c=a.y;let d=1/0,u;t=a;do n>=t.x&&t.x>=l&&n!==t.x&&ys(i<c?n:s,i,l,c,i<c?s:n,i,t.x,t.y)&&(u=Math.abs(i-t.y)/(n-t.x),mr(t,r)&&(u<d||u===d&&(t.x>a.x||t.x===a.x&&Ev(a,t)))&&(a=t,d=u)),t=t.next;while(t!==o);return a}function Ev(r,e){return St(r.prev,r,e.prev)<0&&St(e.next,r,r.next)<0}function Av(r,e,t,n){let i=r;do i.z===null&&(i.z=Oo(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==r);i.prevZ.nextZ=null,i.prevZ=null,Lv(i)}function Lv(r){let e,t,n,i,s,a,o,l,c=1;do{for(t=r,r=null,s=null,a=0;t;){for(a++,n=t,o=0,e=0;e<c&&(o++,n=n.nextZ,!!n);e++);for(l=c;o>0||l>0&&n;)o!==0&&(l===0||!n||t.z<=n.z)?(i=t,t=t.nextZ,o--):(i=n,n=n.nextZ,l--),s?s.nextZ=i:r=i,i.prevZ=s,s=i;t=n}s.nextZ=null,c*=2}while(a>1);return r}function Oo(r,e,t,n,i){return r=32767*(r-t)*i,e=32767*(e-n)*i,r=(r|r<<8)&16711935,r=(r|r<<4)&252645135,r=(r|r<<2)&858993459,r=(r|r<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,r|e<<1}function Rv(r){let e=r,t=r;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==r);return t}function ys(r,e,t,n,i,s,a,o){return(i-a)*(e-o)-(r-a)*(s-o)>=0&&(r-a)*(n-o)-(t-a)*(e-o)>=0&&(t-a)*(s-o)-(i-a)*(n-o)>=0}function Cv(r,e){return r.next.i!==e.i&&r.prev.i!==e.i&&!Iv(r,e)&&(mr(r,e)&&mr(e,r)&&Pv(r,e)&&(St(r.prev,r,e.prev)||St(r,e.prev,e))||Ma(r,e)&&St(r.prev,r,r.next)>0&&St(e.prev,e,e.next)>0)}function St(r,e,t){return(e.y-r.y)*(t.x-e.x)-(e.x-r.x)*(t.y-e.y)}function Ma(r,e){return r.x===e.x&&r.y===e.y}function xu(r,e,t,n){const i=ia(St(r,e,t)),s=ia(St(r,e,n)),a=ia(St(t,n,r)),o=ia(St(t,n,e));return!!(i!==s&&a!==o||i===0&&na(r,t,e)||s===0&&na(r,n,e)||a===0&&na(t,r,n)||o===0&&na(t,e,n))}function na(r,e,t){return e.x<=Math.max(r.x,t.x)&&e.x>=Math.min(r.x,t.x)&&e.y<=Math.max(r.y,t.y)&&e.y>=Math.min(r.y,t.y)}function ia(r){return r>0?1:r<0?-1:0}function Iv(r,e){let t=r;do{if(t.i!==r.i&&t.next.i!==r.i&&t.i!==e.i&&t.next.i!==e.i&&xu(t,t.next,r,e))return!0;t=t.next}while(t!==r);return!1}function mr(r,e){return St(r.prev,r,r.next)<0?St(r,e,r.next)>=0&&St(r,r.prev,e)>=0:St(r,e,r.prev)<0||St(r,r.next,e)<0}function Pv(r,e){let t=r,n=!1;const i=(r.x+e.x)/2,s=(r.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&i<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==r);return n}function bu(r,e){const t=new zo(r.i,r.x,r.y),n=new zo(e.i,e.x,e.y),i=r.next,s=e.prev;return r.next=e,e.prev=r,t.next=i,i.prev=t,n.next=t,t.prev=n,s.next=n,n.prev=s,n}function Qc(r,e,t,n){const i=new zo(r,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function gr(r){r.next.prev=r.prev,r.prev.next=r.next,r.prevZ&&(r.prevZ.nextZ=r.nextZ),r.nextZ&&(r.nextZ.prevZ=r.prevZ)}function zo(r,e,t){this.i=r,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Dv(r,e,t,n){let i=0;for(let s=e,a=t-n;s<t;s+=n)i+=(r[a]-r[s])*(r[s+1]+r[a+1]),a=s;return i}class mi{static area(e){const t=e.length;let n=0;for(let i=t-1,s=0;s<t;i=s++)n+=e[i].x*e[s].y-e[s].x*e[i].y;return n*.5}static isClockWise(e){return mi.area(e)<0}static triangulateShape(e,t){const n=[],i=[],s=[];ed(e),td(n,e);let a=e.length;t.forEach(ed);for(let l=0;l<t.length;l++)i.push(a),a+=t[l].length,td(n,t[l]);const o=yv.triangulate(n,i);for(let l=0;l<o.length;l+=3)s.push(o.slice(l,l+3));return s}}function ed(r){const e=r.length;e>2&&r[e-1].equals(r[0])&&r.pop()}function td(r,e){for(let t=0;t<e.length;t++)r.push(e[t].x),r.push(e[t].y)}class Sa extends pt{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],s=[];for(let o=0,l=e.length;o<l;o++){const c=e[o];a(c)}this.setAttribute("position",new Rt(i,3)),this.setAttribute("uv",new Rt(s,2)),this.computeVertexNormals();function a(o){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,d=t.steps!==void 0?t.steps:1;let u=t.depth!==void 0?t.depth:100,h=t.bevelEnabled!==void 0?t.bevelEnabled:!0,m=t.bevelThickness!==void 0?t.bevelThickness:6,_=t.bevelSize!==void 0?t.bevelSize:m-2,v=t.bevelOffset!==void 0?t.bevelOffset:0,y=t.bevelSegments!==void 0?t.bevelSegments:3;const p=t.extrudePath,f=t.UVGenerator!==void 0?t.UVGenerator:Nv;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),u=t.amount);let b,M=!1,S,x,I,V;p&&(b=p.getSpacedPoints(d),M=!0,h=!1,S=p.computeFrenetFrames(d,!1),x=new P,I=new P,V=new P),h||(y=0,m=0,_=0,v=0);const Y=o.extractPoints(c);let j=Y.shape;const G=Y.holes;if(!mi.isClockWise(j)){j=j.reverse();for(let ue=0,le=G.length;ue<le;ue++){const ae=G[ue];mi.isClockWise(ae)&&(G[ue]=ae.reverse())}}const C=mi.triangulateShape(j,G),W=j;for(let ue=0,le=G.length;ue<le;ue++){const ae=G[ue];j=j.concat(ae)}function z(ue,le,ae){return le||console.error("THREE.ExtrudeGeometry: vec does not exist"),le.clone().multiplyScalar(ae).add(ue)}const E=j.length,N=C.length;function K(ue,le,ae){let Le,de,D;const L=ue.x-le.x,ce=ue.y-le.y,oe=ae.x-ue.x,Te=ae.y-ue.y,Be=L*L+ce*ce,qe=L*Te-ce*oe;if(Math.abs(qe)>Number.EPSILON){const X=Math.sqrt(Be),U=Math.sqrt(oe*oe+Te*Te),_e=le.x-ce/X,Se=le.y+L/X,De=ae.x-Te/U,ve=ae.y+oe/U,We=((De-_e)*Te-(ve-Se)*oe)/(L*Te-ce*oe);Le=_e+L*We-ue.x,de=Se+ce*We-ue.y;const it=Le*Le+de*de;if(it<=2)return new Ae(Le,de);D=Math.sqrt(it/2)}else{let X=!1;L>Number.EPSILON?oe>Number.EPSILON&&(X=!0):L<-Number.EPSILON?oe<-Number.EPSILON&&(X=!0):Math.sign(ce)===Math.sign(Te)&&(X=!0),X?(Le=-ce,de=L,D=Math.sqrt(Be)):(Le=L,de=ce,D=Math.sqrt(Be/2))}return new Ae(Le/D,de/D)}const J=[];for(let ue=0,le=W.length,ae=le-1,Le=ue+1;ue<le;ue++,ae++,Le++)ae===le&&(ae=0),Le===le&&(Le=0),J[ue]=K(W[ue],W[ae],W[Le]);const T=[];let O,H=J.concat();for(let ue=0,le=G.length;ue<le;ue++){const ae=G[ue];O=[];for(let Le=0,de=ae.length,D=de-1,L=Le+1;Le<de;Le++,D++,L++)D===de&&(D=0),L===de&&(L=0),O[Le]=K(ae[Le],ae[D],ae[L]);T.push(O),H=H.concat(O)}for(let ue=0;ue<y;ue++){const le=ue/y,ae=m*Math.cos(le*Math.PI/2),Le=_*Math.sin(le*Math.PI/2)+v;for(let de=0,D=W.length;de<D;de++){const L=z(W[de],J[de],Le);se(L.x,L.y,-ae)}for(let de=0,D=G.length;de<D;de++){const L=G[de];O=T[de];for(let ce=0,oe=L.length;ce<oe;ce++){const Te=z(L[ce],O[ce],Le);se(Te.x,Te.y,-ae)}}}const ee=_+v;for(let ue=0;ue<E;ue++){const le=h?z(j[ue],H[ue],ee):j[ue];M?(I.copy(S.normals[0]).multiplyScalar(le.x),x.copy(S.binormals[0]).multiplyScalar(le.y),V.copy(b[0]).add(I).add(x),se(V.x,V.y,V.z)):se(le.x,le.y,0)}for(let ue=1;ue<=d;ue++)for(let le=0;le<E;le++){const ae=h?z(j[le],H[le],ee):j[le];M?(I.copy(S.normals[ue]).multiplyScalar(ae.x),x.copy(S.binormals[ue]).multiplyScalar(ae.y),V.copy(b[ue]).add(I).add(x),se(V.x,V.y,V.z)):se(ae.x,ae.y,u/d*ue)}for(let ue=y-1;ue>=0;ue--){const le=ue/y,ae=m*Math.cos(le*Math.PI/2),Le=_*Math.sin(le*Math.PI/2)+v;for(let de=0,D=W.length;de<D;de++){const L=z(W[de],J[de],Le);se(L.x,L.y,u+ae)}for(let de=0,D=G.length;de<D;de++){const L=G[de];O=T[de];for(let ce=0,oe=L.length;ce<oe;ce++){const Te=z(L[ce],O[ce],Le);M?se(Te.x,Te.y+b[d-1].y,b[d-1].x+ae):se(Te.x,Te.y,u+ae)}}}B(),ne();function B(){const ue=i.length/3;if(h){let le=0,ae=E*le;for(let Le=0;Le<N;Le++){const de=C[Le];re(de[2]+ae,de[1]+ae,de[0]+ae)}le=d+y*2,ae=E*le;for(let Le=0;Le<N;Le++){const de=C[Le];re(de[0]+ae,de[1]+ae,de[2]+ae)}}else{for(let le=0;le<N;le++){const ae=C[le];re(ae[2],ae[1],ae[0])}for(let le=0;le<N;le++){const ae=C[le];re(ae[0]+E*d,ae[1]+E*d,ae[2]+E*d)}}n.addGroup(ue,i.length/3-ue,0)}function ne(){const ue=i.length/3;let le=0;Q(W,le),le+=W.length;for(let ae=0,Le=G.length;ae<Le;ae++){const de=G[ae];Q(de,le),le+=de.length}n.addGroup(ue,i.length/3-ue,1)}function Q(ue,le){let ae=ue.length;for(;--ae>=0;){const Le=ae;let de=ae-1;de<0&&(de=ue.length-1);for(let D=0,L=d+y*2;D<L;D++){const ce=E*D,oe=E*(D+1),Te=le+Le+ce,Be=le+de+ce,qe=le+de+oe,X=le+Le+oe;be(Te,Be,qe,X)}}}function se(ue,le,ae){l.push(ue),l.push(le),l.push(ae)}function re(ue,le,ae){me(ue),me(le),me(ae);const Le=i.length/3,de=f.generateTopUV(n,i,Le-3,Le-2,Le-1);Ne(de[0]),Ne(de[1]),Ne(de[2])}function be(ue,le,ae,Le){me(ue),me(le),me(Le),me(le),me(ae),me(Le);const de=i.length/3,D=f.generateSideWallUV(n,i,de-6,de-3,de-2,de-1);Ne(D[0]),Ne(D[1]),Ne(D[3]),Ne(D[1]),Ne(D[2]),Ne(D[3])}function me(ue){i.push(l[ue*3+0]),i.push(l[ue*3+1]),i.push(l[ue*3+2])}function Ne(ue){s.push(ue.x),s.push(ue.y)}}}toJSON(){const e=pt.prototype.toJSON.call(this),t=this.parameters.shapes,n=this.parameters.options;return Fv(t,n,e)}}const Nv={generateTopUV:function(r,e,t,n,i){const s=e[t*3],a=e[t*3+1],o=e[n*3],l=e[n*3+1],c=e[i*3],d=e[i*3+1];return[new Ae(s,a),new Ae(o,l),new Ae(c,d)]},generateSideWallUV:function(r,e,t,n,i,s){const a=e[t*3],o=e[t*3+1],l=e[t*3+2],c=e[n*3],d=e[n*3+1],u=e[n*3+2],h=e[i*3],m=e[i*3+1],_=e[i*3+2],v=e[s*3],y=e[s*3+1],p=e[s*3+2];return Math.abs(o-d)<.01?[new Ae(a,1-l),new Ae(c,1-u),new Ae(h,1-_),new Ae(v,1-p)]:[new Ae(o,1-l),new Ae(d,1-u),new Ae(m,1-_),new Ae(y,1-p)]}};function Fv(r,e,t){if(t.shapes=[],Array.isArray(r))for(let n=0,i=r.length;n<i;n++){const s=r[n];t.shapes.push(s.uuid)}else t.shapes.push(r.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class Bv extends pt{constructor(e=.5,t=1,n=8,i=1,s=0,a=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:i,thetaStart:s,thetaLength:a},n=Math.max(3,n),i=Math.max(1,i);const o=[],l=[],c=[],d=[];let u=e;const h=(t-e)/i,m=new P,_=new Ae;for(let v=0;v<=i;v++){for(let y=0;y<=n;y++){const p=s+y/n*a;m.x=u*Math.cos(p),m.y=u*Math.sin(p),l.push(m.x,m.y,m.z),c.push(0,0,1),_.x=(m.x/t+1)/2,_.y=(m.y/t+1)/2,d.push(_.x,_.y)}u+=h}for(let v=0;v<i;v++){const y=v*(n+1);for(let p=0;p<n;p++){const f=p+y,b=f,M=f+n+1,S=f+n+2,x=f+1;o.push(b,M,x),o.push(M,S,x)}}this.setIndex(o),this.setAttribute("position",new Rt(l,3)),this.setAttribute("normal",new Rt(c,3)),this.setAttribute("uv",new Rt(d,2))}}class kv extends pt{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],i=[],s=[],a=[];let o=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let d=0;d<e.length;d++)c(e[d]),this.addGroup(o,l,d),o+=l,l=0;this.setIndex(n),this.setAttribute("position",new Rt(i,3)),this.setAttribute("normal",new Rt(s,3)),this.setAttribute("uv",new Rt(a,2));function c(d){const u=i.length/3,h=d.extractPoints(t);let m=h.shape;const _=h.holes;mi.isClockWise(m)===!1&&(m=m.reverse());for(let y=0,p=_.length;y<p;y++){const f=_[y];mi.isClockWise(f)===!0&&(_[y]=f.reverse())}const v=mi.triangulateShape(m,_);for(let y=0,p=_.length;y<p;y++){const f=_[y];m=m.concat(f)}for(let y=0,p=m.length;y<p;y++){const f=m[y];i.push(f.x,f.y,0),s.push(0,0,1),a.push(f.x,f.y)}for(let y=0,p=v.length;y<p;y++){const f=v[y],b=f[0]+u,M=f[1]+u,S=f[2]+u;n.push(b,M,S),l+=3}}}toJSON(){const e=pt.prototype.toJSON.call(this),t=this.parameters.shapes;return Ov(t,e)}}function Ov(r,e){if(e.shapes=[],Array.isArray(r))for(let t=0,n=r.length;t<n;t++){const i=r[t];e.shapes.push(i.uuid)}else e.shapes.push(r.uuid);return e}class wu extends Ct{constructor(e){super(),this.type="ShadowMaterial",this.color=new ke(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}wu.prototype.isShadowMaterial=!0;class Ta extends Di{constructor(e){super(e),this.type="RawShaderMaterial"}}Ta.prototype.isRawShaderMaterial=!0;class Mn extends Ct{constructor(e){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new ke(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ni,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.vertexTangents=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this.vertexTangents=e.vertexTangents,this}}Mn.prototype.isMeshStandardMaterial=!0;class al extends Mn{constructor(e){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Ae(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=Kt(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new ke).copy(e.sheen):this.sheen=null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this}}al.prototype.isMeshPhysicalMaterial=!0;class zv extends Ct{constructor(e){super(),this.type="MeshPhongMaterial",this.color=new ke(16777215),this.specular=new ke(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ni,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ga,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}zv.prototype.isMeshPhongMaterial=!0;class Uv extends Ct{constructor(e){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ke(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ni,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this}}Uv.prototype.isMeshToonMaterial=!0;class Hv extends Ct{constructor(e){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ni,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}Hv.prototype.isMeshNormalMaterial=!0;class ir extends Ct{constructor(e){super(),this.type="MeshLambertMaterial",this.color=new ke(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ga,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this}}ir.prototype.isMeshLambertMaterial=!0;class Gv extends Ct{constructor(e){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ke(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ni,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}Gv.prototype.isMeshMatcapMaterial=!0;class Vv extends Oi{constructor(e){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}Vv.prototype.isLineDashedMaterial=!0;const wt={arraySlice:function(r,e,t){return wt.isTypedArray(r)?new r.constructor(r.subarray(e,t!==void 0?t:r.length)):r.slice(e,t)},convertArray:function(r,e,t){return!r||!t&&r.constructor===e?r:typeof e.BYTES_PER_ELEMENT=="number"?new e(r):Array.prototype.slice.call(r)},isTypedArray:function(r){return ArrayBuffer.isView(r)&&!(r instanceof DataView)},getKeyframeOrder:function(r){function e(i,s){return r[i]-r[s]}const t=r.length,n=new Array(t);for(let i=0;i!==t;++i)n[i]=i;return n.sort(e),n},sortedArray:function(r,e,t){const n=r.length,i=new r.constructor(n);for(let s=0,a=0;a!==n;++s){const o=t[s]*e;for(let l=0;l!==e;++l)i[a++]=r[o+l]}return i},flattenJSON:function(r,e,t,n){let i=1,s=r[0];for(;s!==void 0&&s[n]===void 0;)s=r[i++];if(s===void 0)return;let a=s[n];if(a!==void 0)if(Array.isArray(a))do a=s[n],a!==void 0&&(e.push(s.time),t.push.apply(t,a)),s=r[i++];while(s!==void 0);else if(a.toArray!==void 0)do a=s[n],a!==void 0&&(e.push(s.time),a.toArray(t,t.length)),s=r[i++];while(s!==void 0);else do a=s[n],a!==void 0&&(e.push(s.time),t.push(a)),s=r[i++];while(s!==void 0)},subclip:function(r,e,t,n,i=30){const s=r.clone();s.name=e;const a=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],d=c.getValueSize(),u=[],h=[];for(let m=0;m<c.times.length;++m){const _=c.times[m]*i;if(!(_<t||_>=n)){u.push(c.times[m]);for(let v=0;v<d;++v)h.push(c.values[m*d+v])}}u.length!==0&&(c.times=wt.convertArray(u,c.times.constructor),c.values=wt.convertArray(h,c.values.constructor),a.push(c))}s.tracks=a;let o=1/0;for(let l=0;l<s.tracks.length;++l)o>s.tracks[l].times[0]&&(o=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(r,e=0,t=r,n=30){n<=0&&(n=30);const i=t.tracks.length,s=e/n;for(let a=0;a<i;++a){const o=t.tracks[a],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const c=r.tracks.find(function(p){return p.name===o.name&&p.ValueTypeName===l});if(c===void 0)continue;let d=0;const u=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=u/3);let h=0;const m=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=m/3);const _=o.times.length-1;let v;if(s<=o.times[0]){const p=d,f=u-d;v=wt.arraySlice(o.values,p,f)}else if(s>=o.times[_]){const p=_*u+d,f=p+u-d;v=wt.arraySlice(o.values,p,f)}else{const p=o.createInterpolant(),f=d,b=u-d;p.evaluate(s),v=wt.arraySlice(p.resultBuffer,f,b)}l==="quaternion"&&new Ht().fromArray(v).normalize().conjugate().toArray(v);const y=c.times.length;for(let p=0;p<y;++p){const f=p*m+h;if(l==="quaternion")Ht.multiplyQuaternionsFlat(c.values,f,v,0,c.values,f);else{const b=m-h*2;for(let M=0;M<b;++M)c.values[f+M]-=v[M]}}}return r.blendMode=Ud,r}};class Yn{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],s=t[n-1];e:{t:{let a;n:{i:if(!(e<i)){for(let o=n+2;;){if(i===void 0){if(e<s)break i;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,s)}if(n===o)break;if(s=i,i=t[++n],e<i)break t}a=t.length;break n}if(!(e>=s)){const o=t[1];e<o&&(n=2,s=o);for(let l=n-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(n===l)break;if(i=s,s=t[--n-1],e>=s)break t}a=n,n=0;break n}break e}for(;n<a;){const o=n+a>>>1;e<t[o]?a=o:n=o+1}if(i=t[n],s=t[n-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(i===void 0)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,s,e)}this._cachedIndex=n,this.intervalChanged_(n,s,i)}return this.interpolate_(n,s,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=e*i;for(let a=0;a!==i;++a)t[a]=n[s+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Yn.prototype.beforeStart_=Yn.prototype.copySampleValue_;Yn.prototype.afterEnd_=Yn.prototype.copySampleValue_;class Wv extends Yn{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ms,endingEnd:ms}}intervalChanged_(e,t,n){const i=this.parameterPositions;let s=e-2,a=e+1,o=i[s],l=i[a];if(o===void 0)switch(this.getSettings_().endingStart){case gs:s=e,o=2*t-n;break;case fa:s=i.length-2,o=t+i[s]-i[s+1];break;default:s=e,o=n}if(l===void 0)switch(this.getSettings_().endingEnd){case gs:a=e,l=2*n-t;break;case fa:a=1,l=n+i[1]-i[0];break;default:a=e-1,l=t}const c=(n-t)*.5,d=this.valueSize;this._weightPrev=c/(t-o),this._weightNext=c/(l-n),this._offsetPrev=s*d,this._offsetNext=a*d}interpolate_(e,t,n,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=e*o,c=l-o,d=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,m=this._weightNext,_=(n-t)/(i-t),v=_*_,y=v*_,p=-h*y+2*h*v-h*_,f=(1+h)*y+(-1.5-2*h)*v+(-.5+h)*_+1,b=(-1-m)*y+(1.5+m)*v+.5*_,M=m*y-m*v;for(let S=0;S!==o;++S)s[S]=p*a[d+S]+f*a[c+S]+b*a[l+S]+M*a[u+S];return s}}class Mu extends Yn{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=e*o,c=l-o,d=(n-t)/(i-t),u=1-d;for(let h=0;h!==o;++h)s[h]=a[c+h]*u+a[l+h]*d;return s}}class qv extends Yn{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class kn{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=wt.convertArray(t,this.TimeBufferType),this.values=wt.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:wt.convertArray(e.times,Array),values:wt.convertArray(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new qv(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new Mu(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new Wv(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case ur:t=this.InterpolantFactoryMethodDiscrete;break;case Ss:t=this.InterpolantFactoryMethodLinear;break;case qa:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ur;case this.InterpolantFactoryMethodLinear:return Ss;case this.InterpolantFactoryMethodSmooth:return qa}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let s=0,a=i-1;for(;s!==i&&n[s]<e;)++s;for(;a!==-1&&n[a]>t;)--a;if(++a,s!==0||a!==i){s>=a&&(a=Math.max(a,1),s=a-1);const o=this.getValueSize();this.times=wt.arraySlice(n,s,a),this.values=wt.arraySlice(this.values,s*o,a*o)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let o=0;o!==s;o++){const l=n[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),e=!1;break}if(a!==null&&a>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,a),e=!1;break}a=l}if(i!==void 0&&wt.isTypedArray(i))for(let o=0,l=i.length;o!==l;++o){const c=i[o];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,c),e=!1;break}}return e}optimize(){const e=wt.arraySlice(this.times),t=wt.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===qa,s=e.length-1;let a=1;for(let o=1;o<s;++o){let l=!1;const c=e[o],d=e[o+1];if(c!==d&&(o!==1||c!==e[0]))if(i)l=!0;else{const u=o*n,h=u-n,m=u+n;for(let _=0;_!==n;++_){const v=t[u+_];if(v!==t[h+_]||v!==t[m+_]){l=!0;break}}}if(l){if(o!==a){e[a]=e[o];const u=o*n,h=a*n;for(let m=0;m!==n;++m)t[h+m]=t[u+m]}++a}}if(s>0){e[a]=e[s];for(let o=s*n,l=a*n,c=0;c!==n;++c)t[l+c]=t[o+c];++a}return a!==e.length?(this.times=wt.arraySlice(e,0,a),this.values=wt.arraySlice(t,0,a*n)):(this.times=e,this.values=t),this}clone(){const e=wt.arraySlice(this.times,0),t=wt.arraySlice(this.values,0),n=this.constructor,i=new n(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}kn.prototype.TimeBufferType=Float32Array;kn.prototype.ValueBufferType=Float32Array;kn.prototype.DefaultInterpolation=Ss;class Is extends kn{}Is.prototype.ValueTypeName="bool";Is.prototype.ValueBufferType=Array;Is.prototype.DefaultInterpolation=ur;Is.prototype.InterpolantFactoryMethodLinear=void 0;Is.prototype.InterpolantFactoryMethodSmooth=void 0;class Su extends kn{}Su.prototype.ValueTypeName="color";class yr extends kn{}yr.prototype.ValueTypeName="number";class $v extends Yn{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=(n-t)/(i-t);let c=e*o;for(let d=c+o;c!==d;c+=4)Ht.slerpFlat(s,0,a,c-o,a,c,l);return s}}class Ps extends kn{InterpolantFactoryMethodLinear(e){return new $v(this.times,this.values,this.getValueSize(),e)}}Ps.prototype.ValueTypeName="quaternion";Ps.prototype.DefaultInterpolation=Ss;Ps.prototype.InterpolantFactoryMethodSmooth=void 0;class Ds extends kn{}Ds.prototype.ValueTypeName="string";Ds.prototype.ValueBufferType=Array;Ds.prototype.DefaultInterpolation=ur;Ds.prototype.InterpolantFactoryMethodLinear=void 0;Ds.prototype.InterpolantFactoryMethodSmooth=void 0;class _r extends kn{}_r.prototype.ValueTypeName="vector";class Uo{constructor(e,t=-1,n,i=Yo){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=mn(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let a=0,o=n.length;a!==o;++a)t.push(jv(n[a]).scale(i));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,a=n.length;s!==a;++s)t.push(kn.toJSON(n[s]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const s=t.length,a=[];for(let o=0;o<s;o++){let l=[],c=[];l.push((o+s-1)%s,o,(o+1)%s),c.push(0,1,0);const d=wt.getKeyframeOrder(l);l=wt.sortedArray(l,1,d),c=wt.sortedArray(c,1,d),!i&&l[0]===0&&(l.push(s),c.push(c[0])),a.push(new yr(".morphTargetInfluences["+t[o].name+"]",l,c).scale(1/n))}return new this(e,-1,a)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,l=e.length;o<l;o++){const c=e[o],d=c.name.match(s);if(d&&d.length>1){const u=d[1];let h=i[u];h||(i[u]=h=[]),h.push(c)}}const a=[];for(const o in i)a.push(this.CreateFromMorphTargetSequence(o,i[o],t,n));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(u,h,m,_,v){if(m.length!==0){const y=[],p=[];wt.flattenJSON(m,y,p,_),y.length!==0&&v.push(new u(h,y,p))}},i=[],s=e.name||"default",a=e.fps||30,o=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let u=0;u<c.length;u++){const h=c[u].keys;if(!(!h||h.length===0))if(h[0].morphTargets){const m={};let _;for(_=0;_<h.length;_++)if(h[_].morphTargets)for(let v=0;v<h[_].morphTargets.length;v++)m[h[_].morphTargets[v]]=-1;for(const v in m){const y=[],p=[];for(let f=0;f!==h[_].morphTargets.length;++f){const b=h[_];y.push(b.time),p.push(b.morphTarget===v?1:0)}i.push(new yr(".morphTargetInfluence["+v+"]",y,p))}l=m.length*a}else{const m=".bones["+t[u].name+"]";n(_r,m+".position",h,"pos",i),n(Ps,m+".quaternion",h,"rot",i),n(_r,m+".scale",h,"scl",i)}}return i.length===0?null:new this(s,l,i,o)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,i=e.length;n!==i;++n){const s=this.tracks[n];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Xv(r){switch(r.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return yr;case"vector":case"vector2":case"vector3":case"vector4":return _r;case"color":return Su;case"quaternion":return Ps;case"bool":case"boolean":return Is;case"string":return Ds}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+r)}function jv(r){if(r.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=Xv(r.type);if(r.times===void 0){const t=[],n=[];wt.flattenJSON(r.keys,t,n,"value"),r.times=t,r.values=n}return e.parse!==void 0?e.parse(r):new e(r.name,r.times,r.values,r.interpolation)}const As={enabled:!1,files:{},add:function(r,e){this.enabled!==!1&&(this.files[r]=e)},get:function(r){if(this.enabled!==!1)return this.files[r]},remove:function(r){delete this.files[r]},clear:function(){this.files={}}};class Yv{constructor(e,t,n){const i=this;let s=!1,a=0,o=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(d){o++,s===!1&&i.onStart!==void 0&&i.onStart(d,a,o),s=!0},this.itemEnd=function(d){a++,i.onProgress!==void 0&&i.onProgress(d,a,o),a===o&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(d){i.onError!==void 0&&i.onError(d)},this.resolveURL=function(d){return l?l(d):d},this.setURLModifier=function(d){return l=d,this},this.addHandler=function(d,u){return c.push(d,u),this},this.removeHandler=function(d){const u=c.indexOf(d);return u!==-1&&c.splice(u,2),this},this.getHandler=function(d){for(let u=0,h=c.length;u<h;u+=2){const m=c[u],_=c[u+1];if(m.global&&(m.lastIndex=0),m.test(d))return _}return null}}}const Zv=new Yv;class Zn{constructor(e){this.manager=e!==void 0?e:Zv,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,s){n.load(e,i,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const bn={};class ol extends Zn{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=As.get(e);if(a!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(a),s.manager.itemEnd(e)},0),a;if(bn[e]!==void 0){bn[e].push({onLoad:t,onProgress:n,onError:i});return}const o=/^data:(.*?)(;base64)?,(.*)$/,l=e.match(o);let c;if(l){const d=l[1],u=!!l[2];let h=l[3];h=decodeURIComponent(h),u&&(h=atob(h));try{let m;const _=(this.responseType||"").toLowerCase();switch(_){case"arraybuffer":case"blob":const v=new Uint8Array(h.length);for(let p=0;p<h.length;p++)v[p]=h.charCodeAt(p);_==="blob"?m=new Blob([v.buffer],{type:d}):m=v.buffer;break;case"document":m=new DOMParser().parseFromString(h,d);break;case"json":m=JSON.parse(h);break;default:m=h;break}setTimeout(function(){t&&t(m),s.manager.itemEnd(e)},0)}catch(m){setTimeout(function(){i&&i(m),s.manager.itemError(e),s.manager.itemEnd(e)},0)}}else{bn[e]=[],bn[e].push({onLoad:t,onProgress:n,onError:i}),c=new XMLHttpRequest,c.open("GET",e,!0),c.addEventListener("load",function(d){const u=this.response,h=bn[e];if(delete bn[e],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),As.add(e,u);for(let m=0,_=h.length;m<_;m++){const v=h[m];v.onLoad&&v.onLoad(u)}s.manager.itemEnd(e)}else{for(let m=0,_=h.length;m<_;m++){const v=h[m];v.onError&&v.onError(d)}s.manager.itemError(e),s.manager.itemEnd(e)}},!1),c.addEventListener("progress",function(d){const u=bn[e];for(let h=0,m=u.length;h<m;h++){const _=u[h];_.onProgress&&_.onProgress(d)}},!1),c.addEventListener("error",function(d){const u=bn[e];delete bn[e];for(let h=0,m=u.length;h<m;h++){const _=u[h];_.onError&&_.onError(d)}s.manager.itemError(e),s.manager.itemEnd(e)},!1),c.addEventListener("abort",function(d){const u=bn[e];delete bn[e];for(let h=0,m=u.length;h<m;h++){const _=u[h];_.onError&&_.onError(d)}s.manager.itemError(e),s.manager.itemEnd(e)},!1),this.responseType!==void 0&&(c.responseType=this.responseType),this.withCredentials!==void 0&&(c.withCredentials=this.withCredentials),c.overrideMimeType&&c.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const d in this.requestHeader)c.setRequestHeader(d,this.requestHeader[d]);c.send(null)}return s.manager.itemStart(e),c}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class Tu extends Zn{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=As.get(e);if(a!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(a),s.manager.itemEnd(e)},0),a;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function l(){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1),As.add(e,this),t&&t(this),s.manager.itemEnd(e)}function c(d){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1),i&&i(d),s.manager.itemError(e),s.manager.itemEnd(e)}return o.addEventListener("load",l,!1),o.addEventListener("error",c,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(e),o.src=e,o}}class Kv extends Zn{constructor(e){super(e)}load(e,t,n,i){const s=new va,a=new Tu(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function l(c){a.load(e[c],function(d){s.images[c]=d,o++,o===6&&(s.needsUpdate=!0,t&&t(s))},void 0,i)}for(let c=0;c<e.length;++c)l(c);return s}}class ll extends Zn{constructor(e){super(e)}load(e,t,n,i){const s=new Bt,a=new Tu(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(o){s.image=o;const l=e.search(/\.jpe?g($|\?)/i)>0||e.search(/^data\:image\/jpeg/)===0;s.format=l?hi:pn,s.needsUpdate=!0,t!==void 0&&t(s)},n,i),s}}class gn{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),s=0;t.push(0);for(let a=1;a<=e;a++)n=this.getPoint(a/e),s+=n.distanceTo(i),t.push(s),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let i=0;const s=n.length;let a;t?a=t:a=e*n[s-1];let o=0,l=s-1,c;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),c=n[i]-a,c<0)o=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,n[i]===a)return i/(s-1);const d=n[i],h=n[i+1]-d,m=(a-d)/h;return(i+m)/(s-1)}getTangent(e,t){let i=e-1e-4,s=e+1e-4;i<0&&(i=0),s>1&&(s=1);const a=this.getPoint(i),o=this.getPoint(s),l=t||(a.isVector2?new Ae:new P);return l.copy(o).sub(a).normalize(),l}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new P,i=[],s=[],a=[],o=new P,l=new Ve;for(let m=0;m<=e;m++){const _=m/e;i[m]=this.getTangentAt(_,new P),i[m].normalize()}s[0]=new P,a[0]=new P;let c=Number.MAX_VALUE;const d=Math.abs(i[0].x),u=Math.abs(i[0].y),h=Math.abs(i[0].z);d<=c&&(c=d,n.set(1,0,0)),u<=c&&(c=u,n.set(0,1,0)),h<=c&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),s[0].crossVectors(i[0],o),a[0].crossVectors(i[0],s[0]);for(let m=1;m<=e;m++){if(s[m]=s[m-1].clone(),a[m]=a[m-1].clone(),o.crossVectors(i[m-1],i[m]),o.length()>Number.EPSILON){o.normalize();const _=Math.acos(Kt(i[m-1].dot(i[m]),-1,1));s[m].applyMatrix4(l.makeRotationAxis(o,_))}a[m].crossVectors(i[m],s[m])}if(t===!0){let m=Math.acos(Kt(s[0].dot(s[e]),-1,1));m/=e,i[0].dot(o.crossVectors(s[0],s[e]))>0&&(m=-m);for(let _=1;_<=e;_++)s[_].applyMatrix4(l.makeRotationAxis(i[_],m*_)),a[_].crossVectors(i[_],s[_])}return{tangents:i,normals:s,binormals:a}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class Ea extends gn{constructor(e=0,t=0,n=1,i=1,s=0,a=Math.PI*2,o=!1,l=0){super(),this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=s,this.aEndAngle=a,this.aClockwise=o,this.aRotation=l}getPoint(e,t){const n=t||new Ae,i=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const a=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=i;for(;s>i;)s-=i;s<Number.EPSILON&&(a?s=0:s=i),this.aClockwise===!0&&!a&&(s===i?s=-i:s=s-i);const o=this.aStartAngle+e*s;let l=this.aX+this.xRadius*Math.cos(o),c=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const d=Math.cos(this.aRotation),u=Math.sin(this.aRotation),h=l-this.aX,m=c-this.aY;l=h*d-m*u+this.aX,c=h*u+m*d+this.aY}return n.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}Ea.prototype.isEllipseCurve=!0;class Eu extends Ea{constructor(e,t,n,i,s,a){super(e,t,n,n,i,s,a),this.type="ArcCurve"}}Eu.prototype.isArcCurve=!0;function cl(){let r=0,e=0,t=0,n=0;function i(s,a,o,l){r=s,e=o,t=-3*s+3*a-2*o-l,n=2*s-2*a+o+l}return{initCatmullRom:function(s,a,o,l,c){i(a,o,c*(o-s),c*(l-a))},initNonuniformCatmullRom:function(s,a,o,l,c,d,u){let h=(a-s)/c-(o-s)/(c+d)+(o-a)/d,m=(o-a)/d-(l-a)/(d+u)+(l-o)/u;h*=d,m*=d,i(a,o,h,m)},calc:function(s){const a=s*s,o=a*s;return r+e*s+t*a+n*o}}}const sa=new P,bo=new cl,wo=new cl,Mo=new cl;class Au extends gn{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new P){const n=t,i=this.points,s=i.length,a=(s-(this.closed?0:1))*e;let o=Math.floor(a),l=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:l===0&&o===s-1&&(o=s-2,l=1);let c,d;this.closed||o>0?c=i[(o-1)%s]:(sa.subVectors(i[0],i[1]).add(i[0]),c=sa);const u=i[o%s],h=i[(o+1)%s];if(this.closed||o+2<s?d=i[(o+2)%s]:(sa.subVectors(i[s-1],i[s-2]).add(i[s-1]),d=sa),this.curveType==="centripetal"||this.curveType==="chordal"){const m=this.curveType==="chordal"?.5:.25;let _=Math.pow(c.distanceToSquared(u),m),v=Math.pow(u.distanceToSquared(h),m),y=Math.pow(h.distanceToSquared(d),m);v<1e-4&&(v=1),_<1e-4&&(_=v),y<1e-4&&(y=v),bo.initNonuniformCatmullRom(c.x,u.x,h.x,d.x,_,v,y),wo.initNonuniformCatmullRom(c.y,u.y,h.y,d.y,_,v,y),Mo.initNonuniformCatmullRom(c.z,u.z,h.z,d.z,_,v,y)}else this.curveType==="catmullrom"&&(bo.initCatmullRom(c.x,u.x,h.x,d.x,this.tension),wo.initCatmullRom(c.y,u.y,h.y,d.y,this.tension),Mo.initCatmullRom(c.z,u.z,h.z,d.z,this.tension));return n.set(bo.calc(l),wo.calc(l),Mo.calc(l)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new P().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}Au.prototype.isCatmullRomCurve3=!0;function nd(r,e,t,n,i){const s=(n-e)*.5,a=(i-t)*.5,o=r*r,l=r*o;return(2*t-2*n+s+a)*l+(-3*t+3*n-2*s-a)*o+s*r+t}function Jv(r,e){const t=1-r;return t*t*e}function Qv(r,e){return 2*(1-r)*r*e}function e0(r,e){return r*r*e}function lr(r,e,t,n){return Jv(r,e)+Qv(r,t)+e0(r,n)}function t0(r,e){const t=1-r;return t*t*t*e}function n0(r,e){const t=1-r;return 3*t*t*r*e}function i0(r,e){return 3*(1-r)*r*r*e}function s0(r,e){return r*r*r*e}function cr(r,e,t,n,i){return t0(r,e)+n0(r,t)+i0(r,n)+s0(r,i)}class dl extends gn{constructor(e=new Ae,t=new Ae,n=new Ae,i=new Ae){super(),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new Ae){const n=t,i=this.v0,s=this.v1,a=this.v2,o=this.v3;return n.set(cr(e,i.x,s.x,a.x,o.x),cr(e,i.y,s.y,a.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}dl.prototype.isCubicBezierCurve=!0;class Lu extends gn{constructor(e=new P,t=new P,n=new P,i=new P){super(),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new P){const n=t,i=this.v0,s=this.v1,a=this.v2,o=this.v3;return n.set(cr(e,i.x,s.x,a.x,o.x),cr(e,i.y,s.y,a.y,o.y),cr(e,i.z,s.z,a.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Lu.prototype.isCubicBezierCurve3=!0;class Aa extends gn{constructor(e=new Ae,t=new Ae){super(),this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Ae){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new Ae;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Aa.prototype.isLineCurve=!0;class r0 extends gn{constructor(e=new P,t=new P){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new P){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class ul extends gn{constructor(e=new Ae,t=new Ae,n=new Ae){super(),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new Ae){const n=t,i=this.v0,s=this.v1,a=this.v2;return n.set(lr(e,i.x,s.x,a.x),lr(e,i.y,s.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}ul.prototype.isQuadraticBezierCurve=!0;class Ru extends gn{constructor(e=new P,t=new P,n=new P){super(),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new P){const n=t,i=this.v0,s=this.v1,a=this.v2;return n.set(lr(e,i.x,s.x,a.x),lr(e,i.y,s.y,a.y),lr(e,i.z,s.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Ru.prototype.isQuadraticBezierCurve3=!0;class hl extends gn{constructor(e=[]){super(),this.type="SplineCurve",this.points=e}getPoint(e,t=new Ae){const n=t,i=this.points,s=(i.length-1)*e,a=Math.floor(s),o=s-a,l=i[a===0?a:a-1],c=i[a],d=i[a>i.length-2?i.length-1:a+1],u=i[a>i.length-3?i.length-1:a+2];return n.set(nd(o,l.x,c.x,d.x,u.x),nd(o,l.y,c.y,d.y,u.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new Ae().fromArray(i))}return this}}hl.prototype.isSplineCurve=!0;var a0=Object.freeze({__proto__:null,ArcCurve:Eu,CatmullRomCurve3:Au,CubicBezierCurve:dl,CubicBezierCurve3:Lu,EllipseCurve:Ea,LineCurve:Aa,LineCurve3:r0,QuadraticBezierCurve:ul,QuadraticBezierCurve3:Ru,SplineCurve:hl});class o0 extends gn{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Aa(t,e))}getPoint(e){const t=e*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=t){const s=n[i]-t,a=this.curves[i],o=a.getLength(),l=o===0?0:1-s/o;return a.getPointAt(l)}i++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let i=0,s=this.curves;i<s.length;i++){const a=s[i],o=a&&a.isEllipseCurve?e*2:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?e*a.points.length:e,l=a.getPoints(o);for(let c=0;c<l.length;c++){const d=l[c];n&&n.equals(d)||(t.push(d),n=d)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new a0[i.type]().fromJSON(i))}return this}}class Ho extends o0{constructor(e){super(),this.type="Path",this.currentPoint=new Ae,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new Aa(this.currentPoint.clone(),new Ae(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){const s=new ul(this.currentPoint.clone(),new Ae(e,t),new Ae(n,i));return this.curves.push(s),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,s,a){const o=new dl(this.currentPoint.clone(),new Ae(e,t),new Ae(n,i),new Ae(s,a));return this.curves.push(o),this.currentPoint.set(s,a),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new hl(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,s,a){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+o,t+l,n,i,s,a),this}absarc(e,t,n,i,s,a){return this.absellipse(e,t,n,n,i,s,a),this}ellipse(e,t,n,i,s,a,o,l){const c=this.currentPoint.x,d=this.currentPoint.y;return this.absellipse(e+c,t+d,n,i,s,a,o,l),this}absellipse(e,t,n,i,s,a,o,l){const c=new Ea(e,t,n,i,s,a,o,l);if(this.curves.length>0){const u=c.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(c);const d=c.getPoint(1);return this.currentPoint.copy(d),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class fl extends Ho{constructor(e){super(e),this.uuid=mn(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new Ho().fromJSON(i))}return this}}class Bn extends ht{constructor(e,t=1){super(),this.type="Light",this.color=new ke(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}Bn.prototype.isLight=!0;class Cu extends Bn{constructor(e,t,n){super(e,n),this.type="HemisphereLight",this.position.copy(ht.DefaultUp),this.updateMatrix(),this.groundColor=new ke(t)}copy(e){return Bn.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}Cu.prototype.isHemisphereLight=!0;const id=new Ve,sd=new P,rd=new P;class pl{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new Ae(512,512),this.map=null,this.mapPass=null,this.matrix=new Ve,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new xa,this._frameExtents=new Ae(1,1),this._viewportCount=1,this._viewports=[new gt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;sd.setFromMatrixPosition(e.matrixWorld),t.position.copy(sd),rd.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(rd),t.updateMatrixWorld(),id.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(id),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class Iu extends pl{constructor(){super(new $t(50,1,.5,500)),this.focus=1}updateMatrices(e){const t=this.camera,n=fr*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(n!==t.fov||i!==t.aspect||s!==t.far)&&(t.fov=n,t.aspect=i,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}Iu.prototype.isSpotLightShadow=!0;class Pu extends Bn{constructor(e,t,n=0,i=Math.PI/3,s=0,a=1){super(e,t),this.type="SpotLight",this.position.copy(ht.DefaultUp),this.updateMatrix(),this.target=new ht,this.distance=n,this.angle=i,this.penumbra=s,this.decay=a,this.shadow=new Iu}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}Pu.prototype.isSpotLight=!0;const ad=new Ve,Zs=new P,So=new P;class Du extends pl{constructor(){super(new $t(90,1,.5,500)),this._frameExtents=new Ae(4,2),this._viewportCount=6,this._viewports=[new gt(2,1,1,1),new gt(0,1,1,1),new gt(3,1,1,1),new gt(1,1,1,1),new gt(3,0,1,1),new gt(1,0,1,1)],this._cubeDirections=[new P(1,0,0),new P(-1,0,0),new P(0,0,1),new P(0,0,-1),new P(0,1,0),new P(0,-1,0)],this._cubeUps=[new P(0,1,0),new P(0,1,0),new P(0,1,0),new P(0,1,0),new P(0,0,1),new P(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,s=e.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),Zs.setFromMatrixPosition(e.matrixWorld),n.position.copy(Zs),So.copy(n.position),So.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(So),n.updateMatrixWorld(),i.makeTranslation(-Zs.x,-Zs.y,-Zs.z),ad.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ad)}}Du.prototype.isPointLightShadow=!0;class La extends Bn{constructor(e,t,n=0,i=1){super(e,t),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new Du}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}La.prototype.isPointLight=!0;class Ra extends Qo{constructor(e=-1,t=1,n=1,i=-1,s=.1,a=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-e,a=n+e,o=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,d=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,a=s+c*this.view.width,o-=d*this.view.offsetY,l=o-d*this.view.height}this.projectionMatrix.makeOrthographic(s,a,o,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}Ra.prototype.isOrthographicCamera=!0;class Nu extends pl{constructor(){super(new Ra(-5,5,5,-5,.5,500))}}Nu.prototype.isDirectionalLightShadow=!0;class Ca extends Bn{constructor(e,t){super(e,t),this.type="DirectionalLight",this.position.copy(ht.DefaultUp),this.updateMatrix(),this.target=new ht,this.shadow=new Nu}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}Ca.prototype.isDirectionalLight=!0;class Fu extends Bn{constructor(e,t){super(e,t),this.type="AmbientLight"}}Fu.prototype.isAmbientLight=!0;class l0 extends Bn{constructor(e,t,n=10,i=10){super(e,t),this.type="RectAreaLight",this.width=n,this.height=i}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}l0.prototype.isRectAreaLight=!0;class Bu{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new P)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,i=e.y,s=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.282095),t.addScaledVector(a[1],.488603*i),t.addScaledVector(a[2],.488603*s),t.addScaledVector(a[3],.488603*n),t.addScaledVector(a[4],1.092548*(n*i)),t.addScaledVector(a[5],1.092548*(i*s)),t.addScaledVector(a[6],.315392*(3*s*s-1)),t.addScaledVector(a[7],1.092548*(n*s)),t.addScaledVector(a[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){const n=e.x,i=e.y,s=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.886227),t.addScaledVector(a[1],2*.511664*i),t.addScaledVector(a[2],2*.511664*s),t.addScaledVector(a[3],2*.511664*n),t.addScaledVector(a[4],2*.429043*n*i),t.addScaledVector(a[5],2*.429043*i*s),t.addScaledVector(a[6],.743125*s*s-.247708),t.addScaledVector(a[7],2*.429043*n*s),t.addScaledVector(a[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const n=e.x,i=e.y,s=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*s,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*n*s,t[8]=.546274*(n*n-i*i)}}Bu.prototype.isSphericalHarmonics3=!0;class ml extends Bn{constructor(e=new Bu,t=1){super(void 0,t),this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}ml.prototype.isLightProbe=!0;class xs{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.substr(0,t+1)}}class c0 extends pt{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}c0.prototype.isInstancedBufferGeometry=!0;class d0 extends Tt{constructor(e,t,n,i){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,n),this.meshPerAttribute=i||1}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}d0.prototype.isInstancedBufferAttribute=!0;class ku extends Zn{constructor(e){super(e),typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=As.get(e);if(a!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(a),s.manager.itemEnd(e)},0),a;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(e,o).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(l){As.add(e,l),t&&t(l),s.manager.itemEnd(e)}).catch(function(l){i&&i(l),s.manager.itemError(e),s.manager.itemEnd(e)}),s.manager.itemStart(e)}}ku.prototype.isImageBitmapLoader=!0;let ra;const u0={getContext:function(){return ra===void 0&&(ra=new(window.AudioContext||window.webkitAudioContext)),ra},setContext:function(r){ra=r}};class h0 extends Zn{constructor(e){super(e)}load(e,t,n,i){const s=this,a=new ol(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(o){try{const l=o.slice(0);u0.getContext().decodeAudioData(l,function(d){t(d)})}catch(l){i?i(l):console.error(l),s.manager.itemError(e)}},n,i)}}class f0 extends ml{constructor(e,t,n=1){super(void 0,n);const i=new ke().set(e),s=new ke().set(t),a=new P(i.r,i.g,i.b),o=new P(s.r,s.g,s.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(o).multiplyScalar(l),this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c)}}f0.prototype.isHemisphereLightProbe=!0;class p0 extends ml{constructor(e,t=1){super(void 0,t);const n=new ke().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}p0.prototype.isAmbientLightProbe=!0;class m0{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=od(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=od();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function od(){return(typeof performance>"u"?Date:performance).now()}class g0 extends ht{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}class y0{constructor(e,t,n){this.binding=e,this.valueSize=n;let i,s,a;switch(t){case"quaternion":i=this._slerp,s=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,s=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,s=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=s,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,i=this.valueSize,s=e*i+i;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==i;++o)n[s+o]=n[o];a=t}else{a+=t;const o=t/a;this._mixBufferRegion(n,s,0,o,i)}this.cumulativeWeight=a}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,i=e*t+t,s=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const l=t*this._origIndex;this._mixBufferRegion(n,i,l,1-s,t)}a>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(n[l]!==n[l+t]){o.setValue(n,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let s=n,a=i;s!==a;++s)t[s]=t[i+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,i,s){if(i>=.5)for(let a=0;a!==s;++a)e[t+a]=e[n+a]}_slerp(e,t,n,i){Ht.slerpFlat(e,t,e,t,e,n,i)}_slerpAdditive(e,t,n,i,s){const a=this._workIndex*s;Ht.multiplyQuaternionsFlat(e,a,e,t,e,n),Ht.slerpFlat(e,t,e,t,e,a,i)}_lerp(e,t,n,i,s){const a=1-i;for(let o=0;o!==s;++o){const l=t+o;e[l]=e[l]*a+e[n+o]*i}}_lerpAdditive(e,t,n,i,s){for(let a=0;a!==s;++a){const o=t+a;e[o]=e[o]+e[n+a]*i}}}const gl="\\[\\]\\.:\\/",_0=new RegExp("["+gl+"]","g"),yl="[^"+gl+"]",v0="[^"+gl.replace("\\.","")+"]",x0=/((?:WC+[\/:])*)/.source.replace("WC",yl),b0=/(WCOD+)?/.source.replace("WCOD",v0),w0=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",yl),M0=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",yl),S0=new RegExp("^"+x0+b0+w0+M0+"$"),T0=["material","materials","bones"];class E0{constructor(e,t,n){const i=n||ft.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=n.length;i!==s;++i)n[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class ft{constructor(e,t,n){this.path=t,this.parsedPath=n||ft.parseTrackName(t),this.node=ft.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new ft.Composite(e,t,n):new ft(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(_0,"")}static parseTrackName(e){const t=S0.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=n.nodeName.substring(i+1);T0.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(!t||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(s){for(let a=0;a<s.length;a++){const o=s[a];if(o.name===t||o.uuid===t)return o;const l=n(o.children);if(l)return l}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.node[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let s=t.propertyIndex;if(e||(e=ft.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let c=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let d=0;d<e.length;d++)if(e[d].name===c){c=d;break}break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const a=e[i];if(a===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}l=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=s}else a.fromArray!==void 0&&a.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(l=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ft.Composite=E0;ft.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};ft.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};ft.prototype.GetterByBindingType=[ft.prototype._getValue_direct,ft.prototype._getValue_array,ft.prototype._getValue_arrayElement,ft.prototype._getValue_toArray];ft.prototype.SetterByBindingTypeAndVersioning=[[ft.prototype._setValue_direct,ft.prototype._setValue_direct_setNeedsUpdate,ft.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[ft.prototype._setValue_array,ft.prototype._setValue_array_setNeedsUpdate,ft.prototype._setValue_array_setMatrixWorldNeedsUpdate],[ft.prototype._setValue_arrayElement,ft.prototype._setValue_arrayElement_setNeedsUpdate,ft.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[ft.prototype._setValue_fromArray,ft.prototype._setValue_fromArray_setNeedsUpdate,ft.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class A0{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;const s=t.tracks,a=s.length,o=new Array(a),l={endingStart:ms,endingEnd:ms};for(let c=0;c!==a;++c){const d=s[c].createInterpolant(null);o[c]=d,d.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=gp,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const i=this._clip.duration,s=e._clip.duration,a=s/i,o=i/s;e.warp(1,a,t),this.warp(o,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const i=this._mixer,s=i.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,c=o.sampleValues;return l[0]=s,l[1]=s+n,c[0]=e/a,c[1]=t/a,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const l=(e-s)*n;if(l<0||n===0)return;this._startTime=null,t=n*l}t*=this._updateTimeScale(e);const a=this._updateTime(t),o=this._updateWeight(e);if(o>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case Ud:for(let d=0,u=l.length;d!==u;++d)l[d].evaluate(a),c[d].accumulateAdditive(o);break;case Yo:default:for(let d=0,u=l.length;d!==u;++d)l[d].evaluate(a),c[d].accumulate(i,o)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let i=this.time+e,s=this._loopCount;const a=n===yp;if(e===0)return s===-1?i:a&&(s&1)===1?t-i:i;if(n===mp){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=t||i<0){const o=Math.floor(i/t);i-=t*o,s+=Math.abs(o);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,a)}else this._setEndings(!1,!1,a);this._loopCount=s,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=i;if(a&&(s&1)===1)return t-i}return i}_setEndings(e,t,n){const i=this._interpolantSettings;n?(i.endingStart=gs,i.endingEnd=gs):(e?i.endingStart=this.zeroSlopeAtStart?gs:ms:i.endingStart=fa,t?i.endingEnd=this.zeroSlopeAtEnd?gs:ms:i.endingEnd=fa)}_scheduleFading(e,t,n){const i=this._mixer,s=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=s,l[0]=t,o[1]=s+e,l[1]=n,this}}class L0 extends xi{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,s=i.length,a=e._propertyBindings,o=e._interpolants,l=n.uuid,c=this._bindingsByRootAndName;let d=c[l];d===void 0&&(d={},c[l]=d);for(let u=0;u!==s;++u){const h=i[u],m=h.name;let _=d[m];if(_!==void 0)a[u]=_;else{if(_=a[u],_!==void 0){_._cacheIndex===null&&(++_.referenceCount,this._addInactiveBinding(_,l,m));continue}const v=t&&t._propertyBindings[u].binding.parsedPath;_=new y0(ft.create(n,m,v),h.ValueTypeName,h.getValueSize()),++_.referenceCount,this._addInactiveBinding(_,l,m),a[u]=_}o[u].resultBuffer=_.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,s=this._actionsByClip[i];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const i=this._actions,s=this._actionsByClip;let a=s[t];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[t]=a;else{const o=a.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=i.length,i.push(e),a.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const s=e._clip.uuid,a=this._actionsByClip,o=a[s],l=o.knownActions,c=l[l.length-1],d=e._byClipCacheIndex;c._byClipCacheIndex=d,l[d]=c,l.pop(),e._byClipCacheIndex=null;const u=o.actionByRoot,h=(e._localRoot||this._root).uuid;delete u[h],l.length===0&&delete a[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_addInactiveBinding(e,t,n){const i=this._bindingsByRootAndName,s=this._bindings;let a=i[t];a===void 0&&(a={},i[t]=a),a[n]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,s=n.path,a=this._bindingsByRootAndName,o=a[i],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete o[s],Object.keys(o).length===0&&delete a[i]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new Mu(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,s=t[i];e.__cacheIndex=i,t[i]=e,s.__cacheIndex=n,t[n]=s}clipAction(e,t,n){const i=t||this._root,s=i.uuid;let a=typeof e=="string"?Uo.findByName(i,e):e;const o=a!==null?a.uuid:e,l=this._actionsByClip[o];let c=null;if(n===void 0&&(a!==null?n=a.blendMode:n=Yo),l!==void 0){const u=l.actionByRoot[s];if(u!==void 0&&u.blendMode===n)return u;c=l.knownActions[0],a===null&&(a=c._clip)}if(a===null)return null;const d=new A0(this,a,t,n);return this._bindAction(d,c),this._addInactiveAction(d,o,s),d}existingAction(e,t){const n=t||this._root,i=n.uuid,s=typeof e=="string"?Uo.findByName(n,e):e,a=s?s.uuid:e,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,s=Math.sign(e),a=this._accuIndex^=1;for(let c=0;c!==n;++c)t[c]._update(i,e,s,a);const o=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)o[c].apply(a);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,s=i[n];if(s!==void 0){const a=s.knownActions;for(let o=0,l=a.length;o!==l;++o){const c=a[o];this._deactivateAction(c);const d=c._cacheIndex,u=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,u._cacheIndex=d,t[d]=u,t.pop(),this._removeInactiveBindingsForAction(c)}delete i[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const a in n){const o=n[a].actionByRoot,l=o[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,s=i[t];if(s!==void 0)for(const a in s){const o=s[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}L0.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class R0 extends bi{constructor(e,t,n=1){super(e,t),this.meshPerAttribute=n||1}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}R0.prototype.isInstancedInterleavedBuffer=!0;class ld{constructor(e,t,n=0,i=1/0){this.ray=new Bi(e,t),this.near=n,this.far=i,this.camera=null,this.layers=new Xd,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!1,n=[]){return Go(e,this,n,t),n.sort(cd),n}intersectObjects(e,t=!1,n=[]){for(let i=0,s=e.length;i<s;i++)Go(e[i],this,n,t);return n.sort(cd),n}}function cd(r,e){return r.distance-e.distance}function Go(r,e,t,n){if(r.layers.test(e.layers)&&r.raycast(e,t),n===!0){const i=r.children;for(let s=0,a=i.length;s<a;s++)Go(i[s],e,t,!0)}}class _s{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(Kt(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class C0 extends ht{constructor(e){super(),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}C0.prototype.isImmediateRenderObject=!0;const oi=new P,aa=new Ve,To=new Ve;class I0 extends wa{constructor(e){const t=Ou(e),n=new pt,i=[],s=[],a=new ke(0,0,1),o=new ke(0,1,0);for(let c=0;c<t.length;c++){const d=t[c];d.parent&&d.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(a.r,a.g,a.b),s.push(o.r,o.g,o.b))}n.setAttribute("position",new Rt(i,3)),n.setAttribute("color",new Rt(s,3));const l=new Oi({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,i=n.getAttribute("position");To.copy(this.root.matrixWorld).invert();for(let s=0,a=0;s<t.length;s++){const o=t[s];o.parent&&o.parent.isBone&&(aa.multiplyMatrices(To,o.matrixWorld),oi.setFromMatrixPosition(aa),i.setXYZ(a,oi.x,oi.y,oi.z),aa.multiplyMatrices(To,o.parent.matrixWorld),oi.setFromMatrixPosition(aa),i.setXYZ(a+1,oi.x,oi.y,oi.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function Ou(r){const e=[];r&&r.isBone&&e.push(r);for(let t=0;t<r.children.length;t++)e.push.apply(e,Ou(r.children[t]));return e}class P0 extends wa{constructor(e=10,t=10,n=4473924,i=8947848){n=new ke(n),i=new ke(i);const s=t/2,a=e/t,o=e/2,l=[],c=[];for(let h=0,m=0,_=-o;h<=t;h++,_+=a){l.push(-o,0,_,o,0,_),l.push(_,0,-o,_,0,o);const v=h===s?n:i;v.toArray(c,m),m+=3,v.toArray(c,m),m+=3,v.toArray(c,m),m+=3,v.toArray(c,m),m+=3}const d=new pt;d.setAttribute("position",new Rt(l,3)),d.setAttribute("color",new Rt(c,3));const u=new Oi({vertexColors:!0,toneMapped:!1});super(d,u),this.type="GridHelper"}}const D0=new Float32Array(1);new Int32Array(D0.buffer);const bs=4,gi=8,Pn=Math.pow(2,gi),zu=[.125,.215,.35,.446,.526,.582],Uu=gi-bs+1+zu.length,cs=20,Fn={[sn]:0,[jn]:1,[Ko]:2,[Gd]:3,[Vd]:4,[Wd]:5,[Zo]:6},Li=new wn({side:Pt,depthWrite:!1,depthTest:!1}),N0=new dt(new _a,Li),Eo=new Ra,{_lodPlanes:Ks,_sizeLods:dd,_sigmas:oa}=k0(),ud=new ke;let Ao=null;const Ri=(1+Math.sqrt(5))/2,ds=1/Ri,hd=[new P(1,1,1),new P(-1,1,1),new P(1,1,-1),new P(-1,1,-1),new P(0,Ri,ds),new P(0,Ri,-ds),new P(ds,0,Ri),new P(-ds,0,Ri),new P(Ri,ds,0),new P(-Ri,ds,0)];function fd(r){const e=Math.max(r.r,r.g,r.b),t=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);return r.multiplyScalar(Math.pow(2,-t)),(t+128)/255}class F0{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=O0(cs),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){Ao=this._renderer.getRenderTarget();const s=this._allocateTargets();return this._sceneToCubeUV(e,n,i,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=gd(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=md(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<Ks.length;e++)Ks[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Ao),e.scissorTest=!1,la(e,0,0,e.width,e.height)}_fromTexture(e){Ao=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:Ft,minFilter:Ft,generateMipmaps:!1,type:wr,format:Pf,encoding:B0(e)?e.encoding:Ko,depthBuffer:!1},n=pd(t);return n.depthBuffer=!e,this._pingPongRenderTarget=pd(t),n}_compileMaterial(e){const t=new dt(Ks[0],e);this._renderer.compile(t,Eo)}_sceneToCubeUV(e,t,n,i){const o=new $t(90,1,t,n),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],d=this._renderer,u=d.autoClear,h=d.outputEncoding,m=d.toneMapping;d.getClearColor(ud),d.toneMapping=Ii,d.outputEncoding=sn,d.autoClear=!1;let _=!1;const v=e.background;if(v){if(v.isColor){Li.color.copy(v).convertSRGBToLinear(),e.background=null;const y=fd(Li.color);Li.opacity=y,_=!0}}else{Li.color.copy(ud).convertSRGBToLinear();const y=fd(Li.color);Li.opacity=y,_=!0}for(let y=0;y<6;y++){const p=y%3;p==0?(o.up.set(0,l[y],0),o.lookAt(c[y],0,0)):p==1?(o.up.set(0,0,l[y]),o.lookAt(0,c[y],0)):(o.up.set(0,l[y],0),o.lookAt(0,0,c[y])),la(i,p*Pn,y>2?Pn:0,Pn,Pn),d.setRenderTarget(i),_&&d.render(N0,o),d.render(e,o)}d.toneMapping=m,d.outputEncoding=h,d.autoClear=u}_textureToCubeUV(e,t){const n=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=gd()):this._equirectShader==null&&(this._equirectShader=md());const i=e.isCubeTexture?this._cubemapShader:this._equirectShader,s=new dt(Ks[0],i),a=i.uniforms;a.envMap.value=e,e.isCubeTexture||a.texelSize.value.set(1/e.image.width,1/e.image.height),a.inputEncoding.value=Fn[e.encoding],a.outputEncoding.value=Fn[t.texture.encoding],la(t,0,0,3*Pn,2*Pn),n.setRenderTarget(t),n.render(s,Eo)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let i=1;i<Uu;i++){const s=Math.sqrt(oa[i]*oa[i]-oa[i-1]*oa[i-1]),a=hd[(i-1)%hd.length];this._blur(e,i-1,i,s,a)}t.autoClear=n}_blur(e,t,n,i,s){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,i,"latitudinal",s),this._halfBlur(a,e,n,n,i,"longitudinal",s)}_halfBlur(e,t,n,i,s,a,o){const l=this._renderer,c=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const d=3,u=new dt(Ks[i],c),h=c.uniforms,m=dd[n]-1,_=isFinite(s)?Math.PI/(2*m):2*Math.PI/(2*cs-1),v=s/_,y=isFinite(s)?1+Math.floor(d*v):cs;y>cs&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${cs}`);const p=[];let f=0;for(let x=0;x<cs;++x){const I=x/v,V=Math.exp(-I*I/2);p.push(V),x==0?f+=V:x<y&&(f+=2*V)}for(let x=0;x<p.length;x++)p[x]=p[x]/f;h.envMap.value=e.texture,h.samples.value=y,h.weights.value=p,h.latitudinal.value=a==="latitudinal",o&&(h.poleAxis.value=o),h.dTheta.value=_,h.mipInt.value=gi-n,h.inputEncoding.value=Fn[e.texture.encoding],h.outputEncoding.value=Fn[e.texture.encoding];const b=dd[i],M=3*Math.max(0,Pn-2*b),S=(i===0?0:2*Pn)+2*b*(i>gi-bs?i-gi+bs:0);la(t,M,S,3*b,2*b),l.setRenderTarget(t),l.render(u,Eo)}}function B0(r){return r===void 0||r.type!==wr?!1:r.encoding===sn||r.encoding===jn||r.encoding===Zo}function k0(){const r=[],e=[],t=[];let n=gi;for(let i=0;i<Uu;i++){const s=Math.pow(2,n);e.push(s);let a=1/s;i>gi-bs?a=zu[i-gi+bs-1]:i==0&&(a=0),t.push(a);const o=1/(s-1),l=-o/2,c=1+o/2,d=[l,l,c,l,c,c,l,l,c,c,l,c],u=6,h=6,m=3,_=2,v=1,y=new Float32Array(m*h*u),p=new Float32Array(_*h*u),f=new Float32Array(v*h*u);for(let M=0;M<u;M++){const S=M%3*2/3-1,x=M>2?0:-1,I=[S,x,0,S+2/3,x,0,S+2/3,x+1,0,S,x,0,S+2/3,x+1,0,S,x+1,0];y.set(I,m*h*M),p.set(d,_*h*M);const V=[M,M,M,M,M,M];f.set(V,v*h*M)}const b=new pt;b.setAttribute("position",new Tt(y,m)),b.setAttribute("uv",new Tt(p,_)),b.setAttribute("faceIndex",new Tt(f,v)),r.push(b),n>bs&&n--}return{_lodPlanes:r,_sizeLods:e,_sigmas:t}}function pd(r){const e=new fi(3*Pn,3*Pn,r);return e.texture.mapping=ya,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function la(r,e,t,n,i){r.viewport.set(e,t,n,i),r.scissor.set(e,t,n,i)}function O0(r){const e=new Float32Array(r),t=new P(0,1,0);return new Ta({name:"SphericalGaussianBlur",defines:{n:r},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:Fn[sn]},outputEncoding:{value:Fn[sn]}},vertexShader:_l(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${vl()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:ui,depthTest:!1,depthWrite:!1})}function md(){const r=new Ae(1,1);return new Ta({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:r},inputEncoding:{value:Fn[sn]},outputEncoding:{value:Fn[sn]}},vertexShader:_l(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${vl()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:ui,depthTest:!1,depthWrite:!1})}function gd(){return new Ta({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Fn[sn]},outputEncoding:{value:Fn[sn]}},vertexShader:_l(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${vl()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:ui,depthTest:!1,depthWrite:!1})}function _l(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function vl(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}gn.create=function(r,e){return console.log("THREE.Curve.create() has been deprecated"),r.prototype=Object.create(gn.prototype),r.prototype.constructor=r,r.prototype.getPoint=e,r};Ho.prototype.fromPoints=function(r){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(r)};P0.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};I0.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Zn.prototype.extractUrlBase=function(r){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),xs.extractUrlBase(r)};Zn.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};on.prototype.center=function(r){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(r)};on.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};on.prototype.isIntersectionBox=function(r){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(r)};on.prototype.isIntersectionSphere=function(r){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(r)};on.prototype.size=function(r){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(r)};Fi.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};xa.prototype.setFromMatrix=function(r){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(r)};Ut.prototype.flattenToArrayOffset=function(r,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(r,e)};Ut.prototype.multiplyVector3=function(r){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),r.applyMatrix3(this)};Ut.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};Ut.prototype.applyToBufferAttribute=function(r){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),r.applyMatrix3(this)};Ut.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};Ut.prototype.getInverse=function(r){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(r).invert()};Ve.prototype.extractPosition=function(r){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(r)};Ve.prototype.flattenToArrayOffset=function(r,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(r,e)};Ve.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new P().setFromMatrixColumn(this,3)};Ve.prototype.setRotationFromQuaternion=function(r){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(r)};Ve.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};Ve.prototype.multiplyVector3=function(r){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Ve.prototype.multiplyVector4=function(r){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Ve.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};Ve.prototype.rotateAxis=function(r){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),r.transformDirection(this)};Ve.prototype.crossVector=function(r){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Ve.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};Ve.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};Ve.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};Ve.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};Ve.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};Ve.prototype.applyToBufferAttribute=function(r){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Ve.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};Ve.prototype.makeFrustum=function(r,e,t,n,i,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(r,e,n,t,i,s)};Ve.prototype.getInverse=function(r){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(r).invert()};Dn.prototype.isIntersectionLine=function(r){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(r)};Ht.prototype.multiplyVector3=function(r){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),r.applyQuaternion(this)};Ht.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};Bi.prototype.isIntersectionBox=function(r){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(r)};Bi.prototype.isIntersectionPlane=function(r){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(r)};Bi.prototype.isIntersectionSphere=function(r){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(r)};Dt.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};Dt.prototype.barycoordFromPoint=function(r,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(r,e)};Dt.prototype.midpoint=function(r){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(r)};Dt.prototypenormal=function(r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(r)};Dt.prototype.plane=function(r){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(r)};Dt.barycoordFromPoint=function(r,e,t,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Dt.getBarycoord(r,e,t,n,i)};Dt.normal=function(r,e,t,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Dt.getNormal(r,e,t,n)};fl.prototype.extractAllPoints=function(r){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(r)};fl.prototype.extrude=function(r){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Sa(this,r)};fl.prototype.makeGeometry=function(r){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new kv(this,r)};Ae.prototype.fromAttribute=function(r,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,e,t)};Ae.prototype.distanceToManhattan=function(r){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(r)};Ae.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};P.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};P.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};P.prototype.getPositionFromMatrix=function(r){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(r)};P.prototype.getScaleFromMatrix=function(r){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(r)};P.prototype.getColumnFromMatrix=function(r,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,r)};P.prototype.applyProjection=function(r){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(r)};P.prototype.fromAttribute=function(r,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,e,t)};P.prototype.distanceToManhattan=function(r){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(r)};P.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};gt.prototype.fromAttribute=function(r,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,e,t)};gt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};ht.prototype.getChildByName=function(r){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(r)};ht.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};ht.prototype.translate=function(r,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,r)};ht.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};ht.prototype.applyMatrix=function(r){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(r)};Object.defineProperties(ht.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(r){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=r}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});dt.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(dt.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),_p},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});nl.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};$t.prototype.setLens=function(r,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(r)};Object.defineProperties(Bn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(r){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=r}},shadowCameraLeft:{set:function(r){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=r}},shadowCameraRight:{set:function(r){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=r}},shadowCameraTop:{set:function(r){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=r}},shadowCameraBottom:{set:function(r){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=r}},shadowCameraNear:{set:function(r){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=r}},shadowCameraFar:{set:function(r){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=r}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(r){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=r}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(r){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=r}},shadowMapHeight:{set:function(r){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=r}}});Object.defineProperties(Tt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===pa},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(pa)}}});Tt.prototype.setDynamic=function(r){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(r===!0?pa:hr),this};Tt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Tt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};pt.prototype.addIndex=function(r){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(r)};pt.prototype.addAttribute=function(r,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(r,new Tt(arguments[1],arguments[2]))):r==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(r,e)};pt.prototype.addDrawCall=function(r,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(r,e)};pt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};pt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};pt.prototype.removeAttribute=function(r){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(r)};pt.prototype.applyMatrix=function(r){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(r)};Object.defineProperties(pt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});bi.prototype.setDynamic=function(r){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(r===!0?pa:hr),this};bi.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Sa.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};Sa.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};Sa.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};ba.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Ct.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new ke}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(r){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=r===Nd}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(r){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=r}}});Object.defineProperties(Di.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(r){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=r}}});yt.prototype.clearTarget=function(r,e,t,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(r),this.clear(e,t,n)};yt.prototype.animate=function(r){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(r)};yt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};yt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};yt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};yt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};yt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};yt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};yt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};yt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};yt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};yt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};yt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};yt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};yt.prototype.enableScissorTest=function(r){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(r)};yt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};yt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};yt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};yt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};yt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};yt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};yt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};yt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};yt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};yt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(yt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(r){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=r}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(r){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=r}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(r){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=r===!0?jn:sn}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(hu.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(fi.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(r){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=r}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(r){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=r}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(r){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=r}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(r){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=r}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(r){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=r}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(r){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=r}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(r){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=r}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(r){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=r}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(r){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=r}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(r){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=r}}});g0.prototype.load=function(r){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new h0().load(r,function(n){e.setBuffer(n)}),this};el.prototype.updateCubeMap=function(r,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(r,e)};el.prototype.clear=function(r,e,t,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(r,e,t,n)};Rs.crossOrigin=void 0;Rs.loadTexture=function(r,e,t,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new ll;i.setCrossOrigin(this.crossOrigin);const s=i.load(r,t,void 0,n);return e&&(s.mapping=e),s};Rs.loadTextureCube=function(r,e,t,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new Kv;i.setCrossOrigin(this.crossOrigin);const s=i.load(r,t,void 0,n);return e&&(s.mapping=e),s};Rs.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Rs.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Id}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Id);const Pi=[{id:"gs_grass",name:"Grass",biomeParent:"Grassland",scale:"Tactical (15ft)",img_pad1:"images/gs_grass_pad1.png",img_pad2:"images/gs_grass_pad2.png",tiles:50,description:"Lush green grassy fields."},{id:"gs_tracks_streams",name:"Tracks and Streams",biomeParent:"Grassland",scale:"Tactical (15ft)",img_pad1:"images/gs_tracks_streams_pad1.png",img_pad2:"images/gs_tracks_streams_pad2.png",tiles:50,description:"Worn paths and flowing streams."},{id:"gs_forest_flora",name:"Forest and Flora",biomeParent:"Grassland",scale:"Tactical (15ft)",img_pad1:"images/gs_forest_flora_pad1.png",img_pad2:"images/gs_forest_flora_pad2.png",tiles:50,description:"Dense woods and varied plant life."},{id:"bl_earth",name:"Earth",biomeParent:"Barrenland",scale:"Tactical (15ft)",img_pad1:"images/bl_earth_pad1.png",img_pad2:"images/bl_earth_pad2.png",tiles:50,description:"Dry, cracked earth."},{id:"bl_tracks_streams",name:"Streams and Tracks",biomeParent:"Barrenland",scale:"Tactical (15ft)",img_pad1:"images/bl_tracks_streams_pad1.png",img_pad2:"images/bl_tracks_streams_pad2.png",tiles:50,description:"Barren paths and dried up riverbeds."},{id:"bl_wasteland_forest",name:"Wasteland Forest",biomeParent:"Barrenland",scale:"Tactical (15ft)",img_pad1:"images/bl_wasteland_forest_pad1.png",img_pad2:"images/bl_wasteland_forest_pad2.png",tiles:50,description:"Petrified or sparse, dead trees."},{id:"mt_stone",name:"Stone",biomeParent:"Mountain",scale:"Tactical (15ft)",img_pad1:"images/mt_stone_pad1.png",img_pad2:"images/mt_stone_pad2.png",tiles:50,description:"Rocky mountain terrain."},{id:"mt_streams_forest",name:"Streams and Forest",biomeParent:"Mountain",scale:"Tactical (15ft)",img_pad1:"images/mt_streams_forest_pad1.png",img_pad2:"images/mt_streams_forest_pad2.png",tiles:50,description:"Mountain streams and alpine forests."},{id:"oc_water",name:"Water",biomeParent:"Oceanic",scale:"Tactical (15ft)",img_pad1:"images/oc_water_pad1.png",img_pad2:"images/oc_water_pad2.png",tiles:50,description:"Open ocean water tiles."},{id:"oc_coastal",name:"Coastal",biomeParent:"Oceanic",scale:"Tactical (15ft)",img_pad1:"images/oc_coastal_pad1.png",img_pad2:"images/oc_coastal_pad2.png",tiles:50,description:"Shorelines, beaches, and coastal features."},{id:"oc_tropical_island",name:"Tropical Island",biomeParent:"Oceanic",scale:"Tactical (15ft)",img_pad1:"images/oc_tropical_island_pad1.png",img_pad2:"images/oc_tropical_island_pad2.png",tiles:50,description:"Lush tropical islands with beaches and vegetation."},{id:"ds_sand",name:"Sand",biomeParent:"Desert",scale:"Tactical (15ft)",img_pad1:"images/ds_sand_pad1.png",img_pad2:"images/ds_sand_pad2.png",tiles:50,description:"Endless rolling sand dunes."},{id:"ds_tracks_ridgelines",name:"Tracks and Ridgelines",biomeParent:"Desert",scale:"Tactical (15ft)",img_pad1:"images/ds_tracks_ridgelines_pad1.png",img_pad2:"images/ds_tracks_ridgelines_pad2.png",tiles:50,description:"Desert paths and rocky ridges."},{id:"ds_ruins_oases",name:"Oases and Ruins",biomeParent:"Desert",scale:"Tactical (15ft)",img_pad1:"images/ds_ruins_oases_pad1.png",img_pad2:"images/ds_ruins_oases_pad2.png",tiles:50,description:"Ancient ruins and life-giving oases."},{id:"ar_snow",name:"Snow",biomeParent:"Arctic",scale:"Tactical (15ft)",img_pad1:"images/ar_snow_pad1.png",img_pad2:"images/ar_snow_pad2.png",tiles:50,description:"Crisp, white snow cover."},{id:"ar_frozen_forest",name:"Frozen Streams and Forest",biomeParent:"Arctic",scale:"Tactical (15ft)",img_pad1:"images/ar_frozen_forest_pad1.png",img_pad2:"images/ar_frozen_forest_pad2.png",tiles:50,description:"Ice-covered trees in a frozen landscape and frozen streams."},{id:"ar_ice_rocks",name:"Ice and Rocks",biomeParent:"Arctic",scale:"Tactical (15ft)",img_pad1:"images/ar_ice_rocks_pad1.png",img_pad2:"images/ar_ice_rocks_pad2.png",tiles:50,description:"Glacial ice and exposed arctic rocks."},{id:"vo_basalt",name:"Basalt",biomeParent:"Volcano",scale:"Tactical (15ft)",img_pad1:"images/vo_basalt_pad1.png",img_pad2:"images/vo_basalt_pad2.png",tiles:50,description:"Hardened volcanic basalt flows."},{id:"vo_volcanic_crater",name:"Volcanic Crater",biomeParent:"Volcano",scale:"Tactical (15ft)",img_pad1:"images/vo_volcanic_crater_pad1.png",img_pad2:"images/vo_volcanic_crater_pad2.png",tiles:50,description:"The rim and interior of a volcanic crater."},{id:"vo_lava_flows",name:"Lava Flows",biomeParent:"Volcano",scale:"Tactical (15ft)",img_pad1:"images/vo_lava_flows_pad1.png",img_pad2:"images/vo_lava_flows_pad2.png",tiles:50,description:"Molten and cooling lava streams."},{id:"ms_marsh",name:"Marsh",biomeParent:"Marshland",scale:"Tactical (15ft)",img_pad1:"images/ms_marsh_pad1.png",img_pad2:"images/ms_marsh_pad2.png",tiles:50,description:"Wet, boggy marsh terrain."},{id:"ms_swamp_streams",name:"Swamp and Streams",biomeParent:"Marshland",scale:"Tactical (15ft)",img_pad1:"images/ms_swamp_streams_pad1.png",img_pad2:"images/ms_swamp_streams_pad2.png",tiles:50,description:"Murky swamp waters and winding streams."},{id:"ms_fetid_forest",name:"Fetid Forest",biomeParent:"Marshland",scale:"Tactical (15ft)",img_pad1:"images/ms_fetid_forest_pad1.png",img_pad2:"images/ms_fetid_forest_pad2.png",tiles:50,description:"Dense, dark, and damp forest."},{id:"tv_walls",name:"Tavern Walls",biomeParent:"Tavern",scale:"Combat (5ft)",img_pad1:"images/tv_walls_pad1.png",img_pad2:"images/tv_walls_pad2.png",tiles:50,description:"Wooden tavern walls."},{id:"tv_floors",name:"Tavern Floors",biomeParent:"Tavern",scale:"Combat (5ft)",img_pad1:"images/tv_floors_pad1.png",img_pad2:"images/tv_floors_pad2.png",tiles:50,description:"Well-trodden tavern floors."},{id:"cv_walls",name:"Cavern Walls",biomeParent:"Cavern",scale:"Combat (5ft)",img_pad1:"images/cv_walls_pad1.png",img_pad2:"images/cv_walls_pad2.png",tiles:50,description:"Rough-hewn cavern walls."},{id:"cv_floors",name:"Cavern Floors",biomeParent:"Cavern",scale:"Combat (5ft)",img_pad1:"images/cv_floors_pad1.png",img_pad2:"images/cv_floors_pad2.png",tiles:50,description:"Uneven cavern floors."},{id:"st_road",name:"Road",biomeParent:"Streets",scale:"Combat (5ft)",img_pad1:"images/st_road_pad1.png",img_pad2:"images/st_road_pad2.png",tiles:50,description:"Cobblestone and dirt roads."},{id:"st_market",name:"Market Square",biomeParent:"Streets",scale:"Combat (5ft)",img_pad1:"images/st_market_pad1.png",img_pad2:"images/st_market_pad2.png",tiles:50,description:"Market stalls and town square elements."},{id:"dg_walls",name:"Dungeon Walls",biomeParent:"Dungeons",scale:"Combat (5ft)",img_pad1:"images/dg_walls_pad1.png",img_pad2:"images/dg_walls_pad2.png",tiles:50,description:"Cold, stone dungeon walls."},{id:"dg_floors",name:"Dungeon Floors",biomeParent:"Dungeons",scale:"Combat (5ft)",img_pad1:"images/dg_floors_pad1.png",img_pad2:"images/dg_floors_pad2.png",tiles:50,description:"Gritty dungeon floors."},{id:"sh_cursed_earth",name:"Cursed Earth",biomeParent:"Shadowlands",scale:"Tactical (15ft)",img_pad1:"images/sh_cursed_earth_pad1.png",img_pad2:"images/sh_cursed_earth_pad2.png",tiles:50,description:"Dark, cursed earth that saps the strength of those who tread upon it."},{id:"sh_dead_forest",name:"Dead Forest",biomeParent:"Shadowlands",scale:"Tactical (15ft)",img_pad1:"images/sh_dead_forest_pad1.png",img_pad2:"images/sh_dead_forest_pad2.png",tiles:50,description:"A forest of twisted, lifeless trees that seem to whisper secrets of the past."},{id:"sh_twisted_roads_and_ruins",name:"Twisted Roads and Ruins",biomeParent:"Shadowlands",scale:"Tactical (15ft)",img_pad1:"images/sh_twisted_roads_and_ruins_pad1.png",img_pad2:"images/sh_twisted_roads_and_ruins_pad2.png",tiles:50,description:"Ancient roads and crumbling ruins that hold dark secrets."},{id:"mc_concrete",name:"Concrete",biomeParent:"Modern City",scale:"Tactical (15ft)",img_pad1:"images/mc_concrete_pad1.png",img_pad2:"images/mc_concrete_pad2.png",tiles:50,description:"Concrete surfaces."},{id:"mc_streets",name:"Side Streets",biomeParent:"Modern City",scale:"Tactical (15ft)",img_pad1:"images/mc_side_streets_pad1.png",img_pad2:"images/mc_side_streets_pad2.png",tiles:50,description:"Narrower back alleys and side streets, perfect for tight urban encounters.",isUpdated:!0},{id:"mc_pavement",name:"Large Streets",biomeParent:"Modern City",scale:"Tactical (15ft)",img_pad1:"images/mc_large_streets_pad1.png",img_pad2:"images/mc_large_streets_pad2.png",tiles:50,description:"Wide arterial roads and major thoroughfares for a sprawling concrete jungle.",isUpdated:!0},{id:"cb_walls",name:"Castle Buildings Walls",biomeParent:"Castle Buildings",scale:"Tactical (15ft)",img_pad1:"images/cb_walls_pad1.png",img_pad2:"images/cb_walls_pad2.png",tiles:50,description:"Sturdy castle walls."},{id:"cb_floors",name:"Castle Buildings Floors",biomeParent:"Castle Buildings",scale:"Tactical (15ft)",img_pad1:"images/cb_floors_pad1.png",img_pad2:"images/cb_floors_pad2.png",tiles:50,description:"Stone castle floors."},{id:"bk_brown",name:"Blank Pads Brown",biomeParent:"Blank Pads",scale:"Tactical (15ft)",img_pad1:"images/bk_brown_pad1.png",img_pad2:"images/bk_brown_pad2.png",tiles:50,description:"Brown blank pads for custom designs."},{id:"bk_gray",name:"Blank Pads Gray",biomeParent:"Blank Pads",scale:"Tactical (15ft)",img_pad1:"images/bk_gray_pad1.png",img_pad2:"images/bk_gray_pad2.png",tiles:50,description:"Gray blank pads for custom designs."}],Xn=[{id:"ep_grassland_150",name:"Grassland (150)",type:"150-tile",scale:"Tactical (15ft)",img_main:"images/ep_grassland_150_main.png",img_map_example:"images/maps/ep_grassland_150_map.png",description:"A grassland scene with grass, streams, forests and other features.",totalTiles:150,components:[{setId:"gs_grass",quantity:1},{setId:"gs_tracks_streams",quantity:1},{setId:"gs_forest_flora",quantity:1}]},{id:"ep_barrenland_150",name:"Barrenland (150)",type:"150-tile",scale:"Tactical (15ft)",img_main:"images/ep_barrenland_150_main.png",img_map_example:"images/maps/ep_barrenland_150_map.png",description:"A dry landscape with barren earth, paths, and dead forest.",totalTiles:150,components:[{setId:"bl_earth",quantity:1},{setId:"bl_tracks_streams",quantity:1},{setId:"bl_wasteland_forest",quantity:1}]},{id:"ep_mountain_150",name:"Mountains (150)",type:"150-tile",scale:"Tactical (15ft)",img_main:"images/ep_mountain_150_main.png",img_map_example:"images/maps/ep_mountain_150_map.png",description:"A rugged mountain map with streams and forest.",totalTiles:150,components:[{setId:"mt_stone",quantity:1},{setId:"mt_streams_forest",quantity:2}]},{id:"ep_desert_150",name:"Desert (150)",type:"150-tile",scale:"Tactical (15ft)",img_main:"images/ep_desert_150_main.png",img_map_example:"images/maps/ep_desert_150_map.png",description:"A desert expanse promising adventure or hiding sheltered oases.",totalTiles:150,components:[{setId:"ds_sand",quantity:1},{setId:"ds_tracks_ridgelines",quantity:1},{setId:"ds_ruins_oases",quantity:1}]},{id:"ep_oceanic_150",name:"Oceanic (150)",type:"150-tile",scale:"Tactical (15ft)",img_main:"images/ep_oceanic_150_main.png",img_map_example:"images/maps/ep_oceanic_150_map.png",description:"A coastline or a series of small islands with grass, forest and rocks.",totalTiles:150,components:[{setId:"oc_water",quantity:1},{setId:"oc_coastal",quantity:1},{setId:"oc_tropical_island",quantity:1}]},{id:"ep_arctic_150",name:"Arctic (150)",type:"150-tile",scale:"Tactical (15ft)",img_main:"images/ep_arctic_150_main.png",img_map_example:"images/maps/ep_arctic_150_map.png",description:"A frozen landscape of ice, thick snow and trees.",totalTiles:150,components:[{setId:"ar_snow",quantity:1},{setId:"ar_frozen_forest",quantity:1},{setId:"ar_ice_rocks",quantity:1}]},{id:"ep_volcano_150",name:"Volcano (150)",type:"150-tile",scale:"Tactical (15ft)",img_main:"images/ep_volcano_150_main.png",img_map_example:"images/maps/ep_volcano_150_map.jpg",description:"A hellscape of lava and smoking rock.",totalTiles:150,components:[{setId:"vo_basalt",quantity:1},{setId:"vo_volcanic_crater",quantity:1},{setId:"vo_lava_flows",quantity:1}]},{id:"ep_marshland_150",name:"Marshland (150)",type:"150-tile",scale:"Tactical (15ft)",img_main:"images/ep_marshland_150_main.png",img_map_example:"images/maps/ep_marshland_150_map.png",description:"A wet marshland with pools of mire and stagnant pools.",totalTiles:150,components:[{setId:"ms_marsh",quantity:1},{setId:"ms_swamp_streams",quantity:1},{setId:"ms_fetid_forest",quantity:1}]},{id:"ep_tavern_150",name:"Tavern (150)",type:"150-tile",scale:"Combat (5ft)",img_main:"images/ep_tavern_150_main.png",img_map_example:"images/maps/ep_tavern_150_map.jpg",description:"A cozy tavern scene for encounters or as a place to call home.",totalTiles:150,components:[{setId:"tv_walls",quantity:2},{setId:"tv_floors",quantity:1}]},{id:"ep_caverns_150",name:"Caverns (150)",type:"150-tile",scale:"Combat (5ft)",img_main:"images/ep_caverns_150_main.png",img_map_example:"images/maps/ep_caverns_150_map.jpg",description:"A dark, foreboding set of small trails, or the dark remains of those that fell before.",totalTiles:150,components:[{setId:"cv_walls",quantity:2},{setId:"cv_floors",quantity:1}]},{id:"ep_streets_150",name:"Streets (150)",type:"150-tile",scale:"Combat (5ft)",img_main:"images/ep_streets_150_main.png",img_map_example:"images/maps/ep_streets_150_map.jpg",description:"Paved streets and a market square provide a versatile urban terrain to mix with other scenes.",totalTiles:150,components:[{setId:"st_road",quantity:2},{setId:"st_market",quantity:1}]},{id:"ep_dungeons_150",name:"Dungeons (150)",type:"150-tile",scale:"Combat (5ft)",img_main:"images/ep_dungeons_150_main.png",img_map_example:"images/maps/ep_dungeons_150_map.jpg",description:"The classic RPG combat map setting. Dark, dangerous, and full of loot and adventure.",totalTiles:150,components:[{setId:"dg_walls",quantity:2},{setId:"dg_floors",quantity:1}]},{id:"ep_shadowlands_150",name:"Shadowlands (150)",type:"150-tile",scale:"Tactical (15ft)",img_main:"images/ep_shadowlands_150_main.png",img_map_example:"images/maps/ep_shadowlands_150_map.jpg",description:"The twisted underworld realm. Nothing lives here amoung the warpen ruins and eldritch magic.",totalTiles:150,components:[{setId:"sh_cursed_earth",quantity:1},{setId:"sh_dead_forest",quantity:1},{setId:"sh_twisted_roads_and_ruins",quantity:1}]},{id:"ep_modern_city_150",name:"Modern City (150)",type:"150-tile",scale:"Tactical (15ft)",img_main:"images/ep_modern_city_150_main.png",img_map_example:"images/maps/ep_modern_city_150_map.jpg",description:"The concrete jungle, a perfect standalone companion for creating modern or future combat maps.",totalTiles:150,components:[{setId:"mc_streets",quantity:1},{setId:"mc_pavement",quantity:1},{setId:"mc_concrete",quantity:1}],isUpdated:!0},{id:"ep_castle_buildings_150",name:"Castle Buildings (150)",type:"150-tile",scale:"Combat (5ft)",img_main:"images/ep_castle_buildings_150_main.png",img_map_example:"images/maps/ep_castle_buildings_150_map.jpg",description:"Castle style buildings with stone walls and floors.",totalTiles:150,components:[{setId:"cb_walls",quantity:2},{setId:"cb_floors",quantity:1}]},{id:"ep_temperate_plains_300",name:"Temperate Plains (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Standard",img_main:"images/ep_temperate_plains_300_main.png",img_map_example:"images/maps/ep_temperate_plains_300_map.png",description:"Ideal for expansive grasslands with tracks, streams, forests, and more.",totalTiles:300,components:[{setId:"gs_grass",quantity:2},{setId:"bl_earth",quantity:1},{setId:"oc_coastal",quantity:1},{setId:"gs_tracks_streams",quantity:1},{setId:"gs_forest_flora",quantity:1}]},{id:"ep_alpine_valley_300",name:"Alpine Valley (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Standard",img_main:"images/ep_alpine_valley_300_main.png",img_map_example:"images/maps/ep_alpine_valley_300_map.png",description:"Mountain passes, alpine forests, and verdant valleys.",totalTiles:300,components:[{setId:"mt_stone",quantity:2},{setId:"gs_grass",quantity:1},{setId:"gs_tracks_streams",quantity:1},{setId:"gs_forest_flora",quantity:1},{setId:"mt_streams_forest",quantity:1}]},{id:"ep_desolate_shore_300",name:"Desolate Shore (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Standard",img_main:"images/ep_desolate_shore_300_main.png",img_map_example:"images/maps/ep_desolate_shore_300_map.png",description:"Desert dunes, oases, tracks and ridges, coastal features.",totalTiles:300,components:[{setId:"ds_sand",quantity:3},{setId:"oc_coastal",quantity:1},{setId:"ds_tracks_ridgelines",quantity:1},{setId:"ds_ruins_oases",quantity:1}]},{id:"ep_rocky_plateau_300",name:"Rocky Plateau (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Standard",img_main:"images/ep_rocky_plateau_300_main.png",img_map_example:"images/maps/ep_rocky_plateau_300_map.png",description:"Cracked earth, barren features, rocky cliffs, paths and barren earth.",totalTiles:300,components:[{setId:"mt_stone",quantity:3},{setId:"bl_earth",quantity:1},{setId:"bl_wasteland_forest",quantity:1},{setId:"mt_streams_forest",quantity:1}]},{id:"ep_wastelands_300",name:"Wastelands (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Standard",img_main:"images/ep_wastelands_300_main.png",img_map_example:"images/maps/ep_wastelands_300_map.png",description:"Expansive maps of dead forest, arid ground, and barren badlands.",totalTiles:300,components:[{setId:"bl_earth",quantity:3},{setId:"mt_stone",quantity:1},{setId:"bl_wasteland_forest",quantity:1},{setId:"bl_tracks_streams",quantity:1}]},{id:"ep_sunkissed_archipelago_300",name:"Sunkissed Archipelago (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Standard",img_main:"images/ep_sunkissed_archipelago_300_main.png",img_map_example:"images/maps/ep_sunkissed_archipelago_300_map.png",description:"Chains of islands or vast coastal areas for naval battlemap.",totalTiles:300,components:[{setId:"oc_water",quantity:2},{setId:"oc_coastal",quantity:2},{setId:"ds_sand",quantity:1},{setId:"oc_tropical_island",quantity:1}]},{id:"ep_arctic_highland_300",name:"Arctic Highland (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Standard",img_main:"images/ep_arctic_highland_300_main.png",img_map_example:"images/maps/ep_arctic_highland_300_map.png",description:"Perfect for winter scenes, snow-covered mountains and glacial regions.",totalTiles:300,components:[{setId:"ar_snow",quantity:2},{setId:"mt_stone",quantity:1},{setId:"ar_frozen_forest",quantity:1},{setId:"ar_ice_rocks",quantity:1},{setId:"mt_streams_forest",quantity:1}]},{id:"ep_chaos_realm_300",name:"Chaos Realm (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Standard",img_main:"images/ep_chaos_realm_300_main.png",img_map_example:"images/maps/ep_chaos_realm_300_map.png",description:"Combined Volcanic and Barrenland sets to portray a truly destroyed hellscape, or corrupted land.",totalTiles:300,components:[{setId:"vo_basalt",quantity:2},{setId:"bl_earth",quantity:1},{setId:"bl_wasteland_forest",quantity:1},{setId:"vo_volcanic_crater",quantity:1},{setId:"vo_lava_flows",quantity:1}]},{id:"ep_gloomy_mire_300",name:"Gloomy Wetlands (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Standard",img_main:"images/ep_gloomy_mire_300_main.png",img_map_example:"images/maps/ep_gloomy_mire_300_map.jpg",description:"Lush marshland, murky swamps, fetid woods, and grassland sets, perfect for mysterious adventures.",totalTiles:300,components:[{setId:"ms_marsh",quantity:2},{setId:"ms_swamp_streams",quantity:1},{setId:"ms_fetid_forest",quantity:1},{setId:"gs_grass",quantity:1},{setId:"gs_tracks_streams",quantity:1}]},{id:"ep_grassland_battlefield_300",name:"Grassland Battlefield (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Battlefield",img_main:"images/ep_grassland_battlefield_300_main.png",img_map_example:"images/maps/ep_grassland_battlefield_300_map.jpng",description:"With some forest to act as cover, this set gives a lot of openness for big encounters.",totalTiles:300,components:[{setId:"gs_grass",quantity:5},{setId:"gs_forest_flora",quantity:1}]},{id:"ep_barren_battlefield_300",name:"Barren Battlefield (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Battlefield",img_main:"images/ep_barren_battlefield_300_main.png",img_map_example:"images/maps/ep_barren_battlefield_300_map.png",description:"Open area with a few dead forest to act as cover.",totalTiles:300,components:[{setId:"bl_earth",quantity:4},{setId:"mt_stone",quantity:1},{setId:"bl_wasteland_forest",quantity:1}]},{id:"ep_desert_battlefield_300",name:"Desert Battlefield (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Battlefield",img_main:"images/ep_desert_battlefield_300_main.png",img_map_example:"images/maps/ep_desert_battlefield_300_map.png",description:"The endless sands of the desert dotted with a few ridgelines and tracks.",totalTiles:300,components:[{setId:"ds_sand",quantity:5},{setId:"ds_tracks_ridgelines",quantity:1}]},{id:"ep_mountain_battlefield_300",name:"Mountain Battlefield (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Battlefield",img_main:"images/ep_mountain_battlefield_300_main.png",img_map_example:"images/maps/ep_mountain_battlefield_300_map.png",description:"A few stone cliffs and the same amount of trees and streams to add some detail, some barren earth.",totalTiles:300,components:[{setId:"mt_stone",quantity:4},{setId:"bl_earth",quantity:1},{setId:"mt_streams_forest",quantity:1}]},{id:"ep_oceanic_battlefield_300",name:"Oceanic Battlefield (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Battlefield",img_main:"images/ep_oceanic_battlefield_300_main.png",img_map_example:"images/maps/ep_oceanic_battlefield_300_map.png",description:"Water for the clash of fleets, coastal features.",totalTiles:300,components:[{setId:"oc_water",quantity:4},{setId:"oc_coastal",quantity:1},{setId:"oc_tropical_island",quantity:1}]},{id:"ep_urban_battlefield_300",name:"Urban Battlefield (300)",type:"300-tile",scale:"Tactical (15ft)",subType:"Battlefield",img_main:"images/ep_urban_battlefield_300_main.png",img_map_example:"images/maps/ep_urban_battlefield_300_map.png",description:"A cityscape with streets for urban combat.",totalTiles:300,components:[{setId:"mc_concrete",quantity:1},{setId:"bl_earth",quantity:1},{setId:"mc_pavement",quantity:2},{setId:"mc_streets",quantity:2}],isUpdated:!0}],Hu="lorescape:debug:enabled",Gu="lorescape:debug:namespaces",bt={enabled:!1,namespaces:new Set,listeners:new Set};function Vu(r){return r?Array.isArray(r)?r.filter(Boolean):String(r).split(/[\s,]+/u).map(t=>t.trim()).filter(Boolean):[]}function z0(r){try{typeof localStorage<"u"&&localStorage.setItem(Hu,r?"1":"0")}catch(e){console.warn("debugLogger: failed to persist enabled state",e)}}function U0(r){try{if(typeof localStorage<"u"){const e=r.size?[...r].join(","):"";localStorage.setItem(Gu,e)}}catch(e){console.warn("debugLogger: failed to persist namespaces",e)}}function Wu(){bt.listeners.forEach(r=>{try{r({enabled:bt.enabled,namespaces:new Set(bt.namespaces)})}catch(e){console.warn("debugLogger: listener callback error",e)}})}function qn(r){return bt.enabled?bt.namespaces.size?r&&bt.namespaces.has(r):!0:!1}function qu(r){const e=r||"app",t=`[${e}]`;return{log:(...i)=>{qn(e)&&console.log(t,...i)},group:(...i)=>{qn(e)&&console.group(t,...i)},groupCollapsed:(...i)=>{qn(e)&&console.groupCollapsed(t,...i)},groupEnd:()=>{qn(e)&&console.groupEnd()},table:(...i)=>{qn(e)&&console.table(...i)},time:i=>{qn(e)&&console.time(`${t} ${i??""}`.trim())},timeEnd:i=>{qn(e)&&console.timeEnd(`${t} ${i??""}`.trim())},isEnabled:()=>qn(e),child:i=>qu(`${e}:${i}`)}}function ws(r,{persist:e=!0}={}){const t=!!r;return bt.enabled===t||(bt.enabled=t,e&&z0(bt.enabled),Wu()),bt.enabled}function ma(r,{persist:e=!0}={}){const t=new Set(Vu(r));return t.size===bt.namespaces.size&&[...t].every(s=>bt.namespaces.has(s))?new Set(bt.namespaces):(bt.namespaces=t,e&&U0(bt.namespaces),Wu(),new Set(bt.namespaces))}function H0(r){return ma([],r)}function G0(r){return typeof r!="function"?()=>{}:(bt.listeners.add(r),()=>bt.listeners.delete(r))}function Kn(r){return qu(r)}function V0(r){return r?qn(r):bt.enabled}function W0(){try{if(typeof localStorage<"u"){localStorage.getItem(Hu)==="1"&&(bt.enabled=!0);const e=localStorage.getItem(Gu);e&&(bt.namespaces=new Set(Vu(e)))}}catch(r){console.warn("debugLogger: failed to hydrate from storage",r)}}function q0(){if(!(typeof location>"u"))try{const r=new URLSearchParams(location.search);if(r.has("debug")){const e=r.get("debug"),t=(e??"").toLowerCase();!e||t==="1"||t==="true"||t==="on"?ws(!0,{persist:!1}):t==="0"||t==="false"||t==="off"?ws(!1,{persist:!1}):(ws(!0,{persist:!1}),ma(e,{persist:!1}))}r.has("debugNamespaces")&&ma(r.get("debugNamespaces"),{persist:!1})}catch(r){console.warn("debugLogger: failed to hydrate from location",r)}}W0();q0();if(typeof window<"u"){const r={enable:()=>ws(!0),disable:()=>ws(!1),toggle:()=>ws(!bt.enabled),setNamespaces:e=>ma(e),clearNamespaces:()=>H0(),getState:()=>({enabled:bt.enabled,namespaces:[...bt.namespaces]}),isEnabled:e=>V0(e),onChange:G0};try{Object.defineProperty(window,"lorescapeDebug",{value:r,configurable:!1,enumerable:!1,writable:!1})}catch(e){console.warn("debugLogger: failed to attach window.lorescapeDebug",e)}}const In=Kn("state");function $0({getPlacementMode:r}){if(typeof r!="function")throw new Error("createStateManager requires a getPlacementMode function");const e={packCounts:new Map,standaloneBiomeSetCounts:new Map,perBiomeDenominator:new Map,tileInstanceLimits:new Map,placedTiles:new Map};let t=()=>{},n=()=>{};function i({updateHeaderStats:p,updateRightPanelStats:f}={}){t=typeof p=="function"?p:()=>{},n=typeof f=="function"?f:()=>{}}function s(){t(),n()}function a(p){let f=0;return Xn.forEach(b=>{const M=e.packCounts.get(b.id)||0;M>0&&b.components.some(S=>S.setId===p)&&(f+=M)}),f}function o(p){if(r()!=="limited")return 0;const f=new Map;e.placedTiles.forEach(x=>{if(x.instanceId&&x.instanceId.startsWith(p+"_")){const I=parseInt(x.instanceId.split("_")[2]);if(!isNaN(I)){const V=f.get(I)||0;f.set(I,V+1)}}});let b=0;f.forEach(x=>{x>b&&(b=x)});const S=Array.from(f.keys()).sort((x,I)=>x-I).map(x=>`${x}(${f.get(x)})`);return In.log(` Biome ${p}: used tiles [${S.join(", ")}], max required sets ${b}`),b}function l(p,f){var S;In.log(` Setting pack ${p} count to: ${f}`);const b=Math.max(0,parseInt(f)||0),M=e.packCounts.get(p)||0;if(b<M&&r()==="limited"){const x=Xn.find(I=>I.id===p);if(x)for(const I of x.components){const V=I.setId,Y=a(V),j=e.standaloneBiomeSetCounts.get(V)||0,G=M*I.quantity,q=b*I.quantity,C=Y-G+q+j,W=o(V);if(C<W){const z=((S=Pi.find(E=>E.id===V))==null?void 0:S.name)||V;return alert(` Cannot decrease "${x.name}" quantity to ${b}.

Reason: You have "${z}" tiles from ${W} different sets placed on the map.

Current total for this biome: ${Y+j} sets
Would become: ${C} sets
Minimum required: ${W} sets

Please remove some "${z}" tiles from the map first.`),In.warn(` Blocked pack count decrease: ${x.name} would reduce ${z} below required ${W} sets`),M}}}if(b===0?e.packCounts.delete(p):e.packCounts.set(p,b),r()==="limited"){const x=Xn.find(I=>I.id===p);x&&x.components&&x.components.forEach(I=>{m(I.setId)})}return s(),In.log(` Pack ${p} count updated to: ${b}`),b}function c(p,f){var S;In.log(` Setting standalone biome set ${p} count to: ${f}`);const b=Math.max(0,parseInt(f)||0),M=e.standaloneBiomeSetCounts.get(p)||0;if(b<M&&r()==="limited"){const x=a(p),I=x+b,V=o(p);if(I<V){const Y=((S=Pi.find(j=>j.id===p))==null?void 0:S.name)||p;return alert(` Cannot reduce "${Y}" standalone biome sets to ${b}.

You have tiles from ${V} different sets placed on the map.

Current total: ${x+M} sets
Would become: ${I} sets
Minimum required: ${V} sets

Please remove some "${Y}" tiles from the map first.`),M}}return b===0?e.standaloneBiomeSetCounts.delete(p):e.standaloneBiomeSetCounts.set(p,b),r()==="limited"&&m(p),s(),In.log(` Standalone biome set ${p} count updated to: ${b}`),b}function d(p,f,b,M=0){In.log(` Placing tile: ${f}_${b} at ${p.q},${p.r} level ${M}`);const S=`q:${p.q},r:${p.r},y:${M}`,x={biomeId:f,tileNumber:b,hexCoords:p,yLevel:M,name:f};return e.placedTiles.set(S,x),s(),In.log(` Tile placed at ${S}`),x}function u(p,f=0){In.log(` Removing tile at ${p.q},${p.r} level ${f}`);const b=`q:${p.q},r:${p.r},y:${f}`,M=e.placedTiles.delete(b);return s(),In.log(` Tile removed from ${b}: ${M}`),M}function h(p){let f=0;return Xn.forEach(b=>{const M=e.packCounts.get(b.id)||0;M>0&&b.components.some(S=>S.setId===p)&&(f+=M)}),f+=e.standaloneBiomeSetCounts.get(p)||0,f}function m(p){if(r()!=="limited")return;const f=h(p),b=e.perBiomeDenominator.get(p)||0;for(let M=1;M<=50;M++){const S=`${p}_${M}`,x=e.tileInstanceLimits.get(S)||0;if(!e.tileInstanceLimits.has(S))e.tileInstanceLimits.set(S,f);else if(f!==b){const I=b-x,V=Math.max(0,f-I);e.tileInstanceLimits.set(S,V)}}e.perBiomeDenominator.set(p,f)}function _(){if(r()==="unlimited"){let f=0;const b={};e.placedTiles.forEach(M=>{b[M.name]=(b[M.name]||0)+1});for(const M in b)f+=Math.ceil(b[M]/50);return f}let p=0;return Pi.forEach(f=>{const b=h(f.id);if(b>0){let M=0;for(let S=1;S<=50;S++){const x=`${f.id}_${S}`,I=e.tileInstanceLimits.get(x)||b;M+=b-I}p+=M/50}}),p}function v(){let p=0;return e.packCounts.forEach(f=>p+=f),e.standaloneBiomeSetCounts.forEach(f=>p+=f),p}function y(){if(e.placedTiles.size===0)return"0-0";let p=1/0,f=-1/0;return e.placedTiles.forEach((b,M)=>{const S=parseInt(M.split(",y:")[1]);p=Math.min(p,S),f=Math.max(f,S)}),`${p}-${f}`}return{packCounts:e.packCounts,standaloneBiomeSetCounts:e.standaloneBiomeSetCounts,perBiomeDenominator:e.perBiomeDenominator,tileInstanceLimits:e.tileInstanceLimits,placedTiles:e.placedTiles,setUpdateCallbacks:i,setPackCount:l,setStandaloneBiomeSetCount:c,placeTile:d,removeTile:u,calculateMinRequiredSets:o,getBiomeTotalSets:h,ensureBiomeInitialized:m,getTotalFromPacks:a,calculateTotalSetsUsed:_,calculateTotalSetsOwned:v,calculateHeightRange:y}}const us=Kn("scene:textures");function X0({scene:r,getAdvancedLightingEnabled:e,maxSupportedAnisotropy:t=1,basePlasticColorHex:n,getTileColor:i,getSelectedTileInfo:s,getGhostTile:a,getGridTexturePath:o}){if(typeof e!="function")throw new Error("createMaterialManager requires getAdvancedLightingEnabled()");if(typeof s!="function")throw new Error("createMaterialManager requires getSelectedTileInfo()");if(typeof a!="function")throw new Error("createMaterialManager requires getGhostTile()");if(typeof i!="function")throw new Error("createMaterialManager requires getTileColor()");const l=new ll,c=new Map,d=new Map;let u={profile:null,materials:null};const h=new Map,m=new Map,_=new ke(n).convertSRGBToLinear(),v={};let y=!1;function p(...T){y&&us.log(...T)}function f(...T){y&&us.groupCollapsed(...T)}function b(){y&&us.groupEnd()}function M(T){y=!!T,typeof window<"u"&&(window.DEBUG_TEXTURES=y);try{localStorage.setItem("debugTextures",y?"1":"0")}catch(O){console.warn("Failed to persist texture debug flag",O)}us.log(` Texture debug ${y?"ENABLED":"disabled"}`)}try{const T=typeof window<"u"?window.DEBUG_TEXTURES:void 0,O=typeof localStorage<"u"&&localStorage.getItem("debugTextures")==="1",H=typeof location<"u"&&new URLSearchParams(location.search).get("debug")==="1";M(T===!0||O||H),typeof window<"u"&&(window.enableTextureDebug=()=>M(!0),window.disableTextureDebug=()=>M(!1))}catch(T){console.warn("Failed to initialize texture debug flag from environment",T)}us.log(" Clearing texture and material caches..."),c.clear(),d.clear();let S=(()=>{const T=parseFloat(typeof localStorage<"u"?localStorage.getItem("ghost:opacity:top"):"");return isFinite(T)?Math.min(1,Math.max(0,T)):.75})(),x=(()=>{const T=parseFloat(typeof localStorage<"u"?localStorage.getItem("ghost:opacity:side"):"");return isFinite(T)?Math.min(1,Math.max(0,T)):.5})();function I(){return{top:S,side:x}}function V(T){if(v[T])return v[T];const O=typeof o=="function"?o(T):null;return O&&O.gridTexture?{type:"grid",path:O.gridTexture,gridSize:O.gridSize||{cols:5,rows:10},tileSize:{width:450,height:450}}:null}function Y(T,O=null){if(c.has(T)){const ee=c.get(T);p(` Using cached texture: ${T}`);const B=!!(ee.image&&ee.image.complete);if(O)if(B)setTimeout(()=>O(ee),0);else{const ne=h.get(T)||[];ne.push(O),h.set(T,ne),p(` Registered waiter for ${T}; waiting count: ${ne.length}`)}return ee}p(` Loading texture: ${T}`),m.set(T,{state:"loading"});const H=l.load(T,function(B){const{width:ne,height:Q}=B.image||{};if(m.set(T,{state:"ready",width:ne,height:Q}),p(` Texture loaded successfully: ${T}`,B),ne&&Q&&p(` Texture dimensions: ${ne}x${Q}`),O)try{O(B)}catch(re){console.error(" onLoadCallback error:",re)}const se=h.get(T)||[];se.length&&p(` Flushing ${se.length} waiter(s) for ${T}`);for(const re of se)try{re(B)}catch(be){console.error(" waiter callback error:",be)}h.delete(T)},function(B){p(` Loading progress for ${T}:`,(B==null?void 0:B.loaded)!==void 0?`${B.loaded}/${B.total}`:B)},function(B){m.set(T,{state:"error"}),console.error(` Error loading texture ${T}:`,B);const ne=h.get(T)||[];for(const Q of ne)try{Q(null)}catch(se){console.error(" waiter callback error:",se)}h.delete(T)});return H.wrapS=_i,H.wrapT=_i,H.flipY=!1,c.set(T,H),H}function j(){p(" Clearing material cache"),d.clear(),u={profile:null,materials:null}}function G(T,O){p(` Creating tile texture from grid: ${T.path}, tile: ${O}`);const H=Y(T.path,()=>{p(` Grid texture loaded callback for tile ${O}`),se()}),ee=O-1,B=ee%T.gridSize.cols,ne=Math.floor(ee/T.gridSize.cols);p(` Grid position for tile ${O}: index=${ee}, col=${B}, row=${ne} (row-major)`);const Q=new Bt,se=()=>{if(!H.image){p(" Base texture image not ready yet");return}const re=H.image;p(` Base texture dimensions: ${re.width}x${re.height}`),p(` Expected grid: ${T.gridSize.cols}x${T.gridSize.rows} tiles`);const be=document.createElement("canvas"),me=be.getContext("2d");be.width=T.tileSize.width,be.height=T.tileSize.height;const Ne=B*T.tileSize.width,ue=ne*T.tileSize.height;p(` Extracting tile from source: x=${Ne}, y=${ue}, w=${T.tileSize.width}, h=${T.tileSize.height}`),me.drawImage(H.image,Ne,ue,T.tileSize.width,T.tileSize.height,0,0,be.width,be.height),O===1&&p(" DEBUG: First tile canvas data:",{width:be.width,height:be.height,srcX:Ne,srcY:ue,canvasData:me.getImageData(0,0,50,50).data.slice(0,20)}),Q.image=be,Q.needsUpdate=!0,Q.rotation=Math.PI/6,Q.center.set(.5,.5),setTimeout(()=>{Q.needsUpdate=!0,p(` Forced texture update for tile ${O} after extraction`)},50)};return H.image&&H.image.complete?(p(` Base texture already loaded for tile ${O}, extracting immediately`),se()):p(` Base texture not loaded yet for tile ${O}, waiting for callback`),Q.wrapS=tn,Q.wrapT=tn,Q.flipY=!1,Q.userData={source:T.path,tileNumber:O,col:B,row:ne},p(` Created tile texture ${O}: col=${B}, row=${ne} | wrapS=${Q.wrapS}, wrapT=${Q.wrapT}, flipY=${Q.flipY}`),Q}function q(T,O=1){const H=e()?"pbr":"lambert",ee=`${H}:${T}_${O}`;if(p(` Creating materials for biome: ${T}, tile: ${O}, key: ${ee}, profile=${H}`),d.has(ee))return p(` Using cached material for ${ee}`),d.get(ee);let B,ne;const Q=V(T);p(` Texture config for ${T}:`,Q);const se=H==="pbr",re=se?Mn:ir,be=se?Mn:ir,me=(le={})=>se?Object.assign({roughness:.52,metalness:.05,envMap:r.environment||null,envMapIntensity:.7},le):le;if(Q){let le=null;Q.type==="grid"?(p(` Using grid texture system for ${T}`),le=G(Q,O)):(p(` Using legacy single texture system for ${T}`),le=Y(Q),le&&(le.rotation=Math.PI/6,le.center.set(.5,.5))),le&&(le.encoding=jn,se&&le.anisotropy!==void 0&&(le.anisotropy=Math.max(le.anisotropy||1,t)));const ae=me({map:le||null,color:16777215});se||(ae.color=new ke(16777215).convertSRGBToLinear()),se&&(ae.roughness=.42,ae.metalness=.07,ae.envMapIntensity=.78),B=new re(ae)}else{p(` No texture config found for ${T}, using fallback color`);const le=i(T)||n,ae=new ke(le).convertSRGBToLinear(),Le=me({color:ae});B=new re(Le),p(` Fallback color material for ${T}: #${le.toString(16)}`)}const Ne=me({color:_.clone()});se&&(Ne.roughness=.6,Ne.metalness=.05,Ne.envMapIntensity=.58),ne=new be(Ne);const ue=[B,ne];return d.set(ee,ue),p(` Cached new materials for ${ee}`),ue}function C(T,O){if(!T||!O||O.length===0)return;let H=0;T.traverse(ee=>{ee.isMesh&&(ee.material=O[H]||O[0],ee.material.needsUpdate=!0,ee.castShadow=e(),ee.receiveShadow=!0,H++)})}function W(T){const O=V(T);O&&(O.type==="grid"&&O.path?(p(` Preloading grid texture for ${T}: ${O.path}`),Y(O.path)):typeof O=="string"&&(p(` Preloading single texture for ${T}: ${O}`),Y(O)))}function z(){var T,O;try{const H=Array.from(c.keys());f(` Texture Debug: ${H.length} cached`);for(const ee of H){const B=c.get(ee),ne=m.get(ee);us.log(` ${ee}`,{ready:!!(B!=null&&B.image&&B.image.complete),width:(T=B==null?void 0:B.image)==null?void 0:T.width,height:(O=B==null?void 0:B.image)==null?void 0:O.height,status:ne})}b()}catch(H){console.error("dumpTextureDebug error",H)}}typeof window<"u"&&(window.dumpTextureDebug=z);function E(T=s()){const O=e(),H=O?Mn:ir,ee={color:16777215,transparent:!0,depthWrite:!1},B=Object.assign({},ee,{opacity:x});O&&(B.roughness=.2,B.metalness=0,B.envMap=r.environment||null,B.envMapIntensity=.25);const ne=new H(B),Q=Object.assign({},ee,{opacity:S});O&&(Q.roughness=.15,Q.metalness=0,Q.envMap=r.environment||null,Q.envMapIntensity=.3);let se=new H(Q);try{if(T&&T.biomeId&&T.tileNumber!=null){const re=q(T.biomeId,T.tileNumber),be=re&&re[0];be&&be.map?(Q.map=be.map,se=new H(Q),p(` Ghost overlay using texture for ${T.biomeId}_${T.tileNumber}`)):p(` Ghost overlay fallback (no texture) for ${T.biomeId}_${T.tileNumber}`)}}catch(re){console.warn("Ghost material creation failed, falling back to plain white:",re)}return[se,ne]}function N(){const T=e()?"pbr":"lambert";if(u.profile===T&&u.materials)return u.materials;const O=T==="pbr",H=O?Mn:ir,ee=re=>{const be=new ke(re);return O||be.convertSRGBToLinear(),be},B={color:ee(16739179),transparent:!0,opacity:.65,depthWrite:!1,side:yi},ne={color:ee(13377311),transparent:!0,opacity:.4,depthWrite:!1,side:yi};if(O){const re=new ke(3342336);B.roughness=.42,B.metalness=.08,B.envMap=r.environment||null,B.envMapIntensity=.65,B.emissive=re,B.emissiveIntensity=.28,ne.roughness=.5,ne.metalness=.05,ne.envMap=r.environment||null,ne.envMapIntensity=.5,ne.emissive=re,ne.emissiveIntensity=.18}const Q=new H(B),se=new H(ne);return u={profile:T,materials:[Q,se]},u.materials}function K(){const T=a();if(!T)return;const O=E();let H=0;T.traverse(ee=>{ee.isMesh&&(ee.material=O[H]||O[0],ee.material.needsUpdate=!0,ee.castShadow=!1,ee.receiveShadow=e(),H++)})}function J(){const T=document.getElementById("ghost-top-opacity"),O=document.getElementById("ghost-side-opacity"),H=document.getElementById("ghost-top-opacity-value"),ee=document.getElementById("ghost-side-opacity-value");if(!T||!O||!H||!ee)return;const B=()=>{T.value=String(S),O.value=String(x),H.textContent=S.toFixed(2),ee.textContent=x.toFixed(2)};B();const ne=()=>{S=parseFloat(T.value),x=parseFloat(O.value),isFinite(S)||(S=.75),isFinite(x)||(x=.5);try{localStorage.setItem("ghost:opacity:top",String(S)),localStorage.setItem("ghost:opacity:side",String(x))}catch(Q){console.warn("Ghost opacity persistence failed",Q)}B(),K()};T.addEventListener("input",ne),O.addEventListener("input",ne)}return{createTileMaterials:q,applyMaterialsToTileObject:C,createGhostMaterials:E,refreshGhostMaterials:K,preloadBiomeTexture:W,setupGhostOpacityControls:J,dumpTextureDebug:z,setTextureDebug:M,getGhostOpacities:I,getCollisionMaterials:N,clearCache:j}}function j0(r){return X0(r)}class Y0 extends ba{constructor(){super();const e=new _a;e.deleteAttribute("uv");const t=new Mn({side:Pt}),n=new Mn,i=new La(16777215,5,28,2);i.position.set(.418,16.199,.3),this.add(i);const s=new dt(e,t);s.position.set(-.757,13.219,.717),s.scale.set(31.713,28.305,28.591),this.add(s);const a=new dt(e,n);a.position.set(-10.906,2.009,1.846),a.rotation.set(0,-.195,0),a.scale.set(2.328,7.905,4.651),this.add(a);const o=new dt(e,n);o.position.set(-5.607,-.754,-.758),o.rotation.set(0,.994,0),o.scale.set(1.97,1.534,3.955),this.add(o);const l=new dt(e,n);l.position.set(6.167,.857,7.803),l.rotation.set(0,.561,0),l.scale.set(3.927,6.285,3.687),this.add(l);const c=new dt(e,n);c.position.set(-2.017,.018,6.124),c.rotation.set(0,.333,0),c.scale.set(2.002,4.566,2.064),this.add(c);const d=new dt(e,n);d.position.set(2.291,-.756,-2.621),d.rotation.set(0,-.286,0),d.scale.set(1.546,1.552,1.496),this.add(d);const u=new dt(e,n);u.position.set(-2.193,-.369,-5.547),u.rotation.set(0,.516,0),u.scale.set(3.875,3.487,2.986),this.add(u);const h=new dt(e,hs(50));h.position.set(-16.116,14.37,8.208),h.scale.set(.1,2.428,2.739),this.add(h);const m=new dt(e,hs(50));m.position.set(-16.109,18.021,-8.207),m.scale.set(.1,2.425,2.751),this.add(m);const _=new dt(e,hs(17));_.position.set(14.904,12.198,-1.832),_.scale.set(.15,4.265,6.331),this.add(_);const v=new dt(e,hs(43));v.position.set(-.462,8.89,14.52),v.scale.set(4.38,5.441,.088),this.add(v);const y=new dt(e,hs(20));y.position.set(3.235,11.486,-12.541),y.scale.set(2.5,2,.1),this.add(y);const p=new dt(e,hs(100));p.position.set(0,20,0),p.scale.set(1,.1,1),this.add(p)}}function hs(r){const e=new wn;return e.color.setScalar(r),e}function Z0({scene:r,renderer:e,ambientLight:t,dirLight:n,baseAmbientIntensity:i,baseAmbientColor:s,baseDirIntensity:a,baseDirColor:o,baseDirPosition:l,storageKey:c,placedTiles:d,getHexTileModel:u,createTileMaterials:h,applyMaterialsToTileObject:m,refreshGhostMaterials:_,clearMaterialCache:v}){if(!r||!e||!t||!n)throw new Error("createLightingController: scene, renderer, ambientLight, and dirLight are required.");const y=typeof u=="function"?u:()=>null,p=typeof h=="function"?h:null,f=typeof m=="function"?m:null,b=typeof _=="function"?_:null,M=typeof v=="function"?v:null;let S=!0,x=null,I=null,V=null,Y=null;const j={hemi:null,fill:null,rim:null};let G=null,q=null;function C(){I||(I=new F0(e),I.compileEquirectangularShader())}function W(){if(C(),!j.hemi){const H=new Cu(16776176,1710618,.55);H.castShadow=!1,j.hemi=H}if(!j.fill){const H=new Ca(16766883,.35);H.position.set(-8,6,-6),H.castShadow=!1,j.fill=H}if(!j.rim){const H=new La(8370943,.35,60,2);H.position.set(0,8,-10),H.castShadow=!1,j.rim=H}if(G)r.children.includes(G)||r.add(G);else{const H=new tl(80,80),ee=new wu({opacity:.35}),B=new dt(H,ee);B.rotation.x=-Math.PI/2,B.position.y=-.02,B.receiveShadow=!0,B.visible=!1,B.name="ShadowCatcher",G=B,r.add(G)}V||z()}function z(){if(V)return V;C();const H=new Y0,ee=I.fromScene(H,.04);return Y=ee,V=ee.texture,V&&(V.encoding=jn),typeof H.dispose=="function"&&H.dispose(),V}function E(){try{Y&&typeof Y.dispose=="function"&&Y.dispose()}catch{}Y=null,V=null;try{I&&typeof I.dispose=="function"&&I.dispose()}catch{}I=null}function N(){if(W(),S){e.physicallyCorrectLights=!0,e.toneMapping=kd,e.toneMappingExposure=.95,e.shadowMap.enabled=!0,t.intensity=.21,t.color.setHex(15785935),n.intensity=1.12,n.color.setHex(16767936),n.position.set(11,17,8.5),n.castShadow=!0,n.shadow.mapSize.set(2048,2048),n.shadow.bias=-4e-4,n.shadow.camera.near=1,n.shadow.camera.far=80,n.shadow.camera.left=-40,n.shadow.camera.right=40,n.shadow.camera.top=40,n.shadow.camera.bottom=-40,n.target.position.set(0,0,0),r.add(n.target);const H=z();r.environment=H,j.hemi&&(j.hemi.intensity=.43,j.hemi.color.setHex(16776176),r.add(j.hemi)),j.fill&&(j.fill.intensity=.27,j.fill.color.setHex(16766883),j.fill.castShadow=!1,r.add(j.fill)),j.rim&&(j.rim.intensity=.29,j.rim.color.setHex(8370943),j.rim.castShadow=!1,r.add(j.rim)),G&&(G.visible=!0,G.material&&(G.material.opacity=.35))}else e.physicallyCorrectLights=!1,e.toneMapping=Ii,e.toneMappingExposure=.92,e.shadowMap.enabled=!1,typeof i=="number"&&(t.intensity=i),s&&t.color.copy(s),typeof a=="number"&&(n.intensity=a),o&&n.color.copy(o),l&&n.position.copy(l),n.castShadow=!1,n.shadow&&(n.shadow.bias=0),r.environment=null,["hemi","fill","rim"].forEach(H=>{j[H]&&r.remove(j[H])}),G&&(G.visible=!1);q&&(q.receiveShadow=S)}function K(){M==null||M();const H=y();H&&H.traverse(ee=>{ee.isMesh&&(ee.castShadow=S,ee.receiveShadow=!0)}),d&&typeof d.forEach=="function"&&p&&f&&d.forEach(ee=>{if(!ee||!ee.object)return;const B=p(ee.biomeId,ee.tileNumber||1);f(ee.object,B)}),b==null||b()}function J(){x&&(x.classList.toggle("is-active",S),x.setAttribute("aria-pressed",S?"true":"false"))}function T(H,ee={}){const{skipPersistence:B=!1,force:ne=!1}=ee,Q=!!H;if(!ne&&S===Q){J();return}if(S=Q,!B&&c)try{localStorage.setItem(c,S?"1":"0")}catch{}N(),K(),J()}function O(){W(),x=document.getElementById("toggle-advanced-lighting"),x&&x.addEventListener("click",()=>{T(!S)});let H=!0;try{const ee=localStorage.getItem(c);ee==="1"?H=!0:ee==="0"&&(H=!1)}catch{H=!0}T(H,{skipPersistence:!0,force:!0})}return{isEnabled:()=>S,setAdvancedLighting:T,setupToggle:O,refreshForLightingMode:K,dispose:E,setGroundPlaneReference:H=>{q=H||null,q&&(q.receiveShadow=S)}}}const K0=Kn("analytics:header");class J0{constructor(e){this.analytics=e}update(){this.updateTotalTiles(),this.updateSetsUsed(),this.updateMapSize()}updateTotalTiles(){var t;const e=document.getElementById("total-tiles");if(e){e.textContent=this.analytics.placedTiles.size;const n=(t=e.parentElement)==null?void 0:t.querySelector(".stat-label");n&&(n.textContent="TOTAL TILES")}}updateSetsUsed(){var t;const e=document.getElementById("sets-used");if(e){if(this.analytics.getPlacementMode()==="unlimited"){const s=this.calculateRequiredSetsForUnlimited(),a=this.analytics.calculateTotalSetsOwned();e.textContent=`${s}/${a}`}else{const s=this.calculateActualUsedSets(),a=this.analytics.calculateTotalSetsOwned();e.textContent=`${s}/${a}`}const i=(t=e.parentElement)==null?void 0:t.querySelector(".stat-label");i&&(i.textContent="SETS/PACKS USED"),e.title="Required Sets / Owned Packs"}}calculateActualUsedSets(){let e=0;return this.analytics.biomeSets.forEach(t=>{e+=this.analytics.calculateMinRequiredSets(t.id)}),e}calculateRequiredSetsForUnlimited(){return this.analytics.calculateTotalSetsUsed()}updateMapSize(){let e=document.getElementById("map-size");e||(this.addMapSizeElement(),e=document.getElementById("map-size")),e&&(e.textContent=this.analytics.calculateMapDimensions())}addMapSizeElement(){const e=document.querySelector(".header-stats");if(e){if(document.getElementById("map-size"))return;const t=document.createElement("div");t.className="stat-item",t.innerHTML=`
        <span class="stat-label">MAP SIZE</span>
        <span class="stat-value" id="map-size">0x0</span>
      `,e.appendChild(t),K0.log(" Added Map Size element to header")}}}const li=Kn("analytics:metrics");class Q0{constructor(e){this.analytics=e}updateOverview(){const e=document.getElementById("map-stats");if(!e)return;const t=this.analytics.placedTiles.size,n=this.analytics.calculateMapDimensions(),i=this.analytics.calculateHeightRange(),s=this.calculateHeightLevels(),a=this.calculateUniqueBiomes(),o=this.calculateSetsRequired();e.innerHTML=`
      <div class="stat-box">
        <div class="stat-number">${t}</div>
        <div class="stat-label">Total Tiles</div>
      </div>
      <div class="stat-box">
        <div class="stat-number">${n}</div>
        <div class="stat-label">Map Size</div>
      </div>
      <div class="stat-box">
        <div class="stat-number">${a}</div>
        <div class="stat-label">Biome Sets</div>
      </div>
      <div class="stat-box">
        <div class="stat-number">${s}</div>
        <div class="stat-label">Height Levels</div>
      </div>
      <div class="stat-box">
        <div class="stat-number">${i}</div>
        <div class="stat-label">Max Level</div>
      </div>
      <div class="stat-box">
        <div class="stat-number">${o}</div>
        <div class="stat-label">Packs Required</div>
      </div>
    `}calculateHeightLevels(){if(this.analytics.placedTiles.size===0)return 0;const e=new Set;return this.analytics.placedTiles.forEach((t,n)=>{const i=parseInt(n.split(",y:")[1]);e.add(i)}),e.size}calculateUniqueBiomes(){const e=new Set;return this.analytics.placedTiles.forEach(t=>{const n=t.biomeId||t.name;n&&e.add(n)}),e.size}calculateSetsRequired(){const e=this.analytics.groupTilesByBiome();li.log(" DEBUG biomeCounts:",e);const t=new Set;if(Object.entries(e).forEach(([s,a])=>{if(a>0){const o=this.analytics.biomeSets.find(l=>l.name===s||l.id===s);o?(t.add(o.id),li.log(` Mapped "${s}" to biome set ID: ${o.id}`)):li.log(` Could not find biome set for key: ${s}`)}}),li.log(" DEBUG neededBiomeSets (actual IDs):",Array.from(t)),t.size===0)return 0;const n=new Set(t),i=[];for(;n.size>0;){let s=null,a=0;for(const o of this.analytics.environmentPacks){const c=o.components.map(d=>d.setId).filter(d=>n.has(d)).length;c>a&&(a=c,s=o)}if(s&&a>0)i.push(s),li.log(` Selected pack ${s.name} covering ${a} sets`),s.components.forEach(o=>{n.has(o.setId)&&(n.delete(o.setId),li.log(` Covered biome set: ${o.setId}`))});else{li.log(" No pack found to cover remaining sets:",Array.from(n));break}}return li.log(` DEBUG minimum packs required: ${i.length}`),i.length}calculateDetailedMapDimensions(){const e=Array.from(this.analytics.placedTiles.keys()).map(d=>{const u=d.match(/q:(-?\d+),r:(-?\d+),y:(-?\d+)/);return u?{q:parseInt(u[1]),r:parseInt(u[2]),y:parseInt(u[3])}:null}).filter(Boolean);if(e.length===0)return{width:0,height:0,minQ:0,maxQ:0,minR:0,maxR:0,minY:0,maxY:0,area:0};const t=Math.min(...e.map(d=>d.q)),n=Math.max(...e.map(d=>d.q)),i=Math.min(...e.map(d=>d.r)),s=Math.max(...e.map(d=>d.r)),a=Math.min(...e.map(d=>d.y)),o=Math.max(...e.map(d=>d.y)),l=n-t+1,c=s-i+1;return{width:l,height:c,minQ:t,maxQ:n,minR:i,maxR:s,minY:a,maxY:o,area:l*c}}}class ex{constructor(e){this.analytics=e}updateBreakdown(){const e=document.getElementById("biome-breakdown");if(!e)return;const t=this.analytics.groupTilesByBiome();if(Object.keys(t).length===0){e.innerHTML=`
        <div class="empty-state">No tiles placed yet</div>
      `;return}const n=this.renderAllBiomes(t);e.innerHTML=`
      <div class="biome-breakdown-content">
        <div class="biome-scrollable">
          ${n}
        </div>
      </div>
    `,this.setupToggleListeners(e)}setupToggleListeners(e){e.querySelectorAll(".biome-main-info").forEach(n=>{n.addEventListener("click",i=>{const a=n.closest(".biome-item-detailed").querySelector(".environment-packs");if(a){const o=a.style.display!=="none";a.style.display=o?"none":"block";const l=n.querySelector(".expand-indicator");l&&(l.textContent=o?"":"")}})})}renderAllBiomes(e){return Object.entries(e).sort(([,i],[,s])=>s-i).map(([i,s])=>{const a=this.getBiomeName(i),o=this.findBiomeData(i),l=(s/this.analytics.placedTiles.size*100).toFixed(1),c=this.analytics.calculateMinRequiredSets((o==null?void 0:o.id)||i),d=this.analytics.environmentPacks.filter(u=>u.components&&u.components.some(h=>h.setId===(o==null?void 0:o.id)));return`
        <div class="biome-item-detailed">
          <div class="biome-main-info">
            <div class="biome-name-section">
              <span class="biome-name">${a}</span>
              <span class="biome-parent">${o?o.biomeParent:""}</span>
            </div>
            <div class="biome-stats-section">
              <div class="biome-count-small">${s} tiles (${l}%)</div>
              <div class="biome-sets-info">
                <span class="sets-required-large">Required: ${c}</span>
              </div>
            </div>
            ${d.length>0?'<span class="expand-indicator"></span>':""}
          </div>
          ${this.renderEnvironmentPacks(o)}
        </div>
      `}).join("")}renderEnvironmentPacks(e){if(!e)return"";const t=this.analytics.environmentPacks.filter(i=>i.components&&i.components.some(s=>s.setId===e.id));return t.length===0?"":`
      <div class="environment-packs" style="display: none;">
        <div class="packs-header">Available in Environment Packs:</div>
        <div class="packs-list">
          ${t.map(i=>{const s=i.components.find(o=>o.setId===e.id),a=s?s.quantity:1;return`
        <div class="pack-item">
          <span class="pack-name">${i.name}</span>
          <span class="pack-quantity">${a}</span>
        </div>
      `}).join("")}
        </div>
      </div>
    `}getBiomeName(e){const t=this.findBiomeData(e);return t?t.name:e}findBiomeData(e){let t=this.analytics.biomeSets.find(n=>n.id===e);return t||(t=this.analytics.biomeSets.find(n=>n.name===e)),t}generateSetUsageAnalysis(){const e={biomesUsed:{},packsUsed:{},standaloneUsed:{},efficiency:{}},t=this.analytics.groupTilesByBiome();return Object.entries(t).forEach(([n,i])=>{const s=this.findBiomeData(n);if(s){const a=Math.ceil(i/50),o=this.analytics.getBiomeTotalSets(s.id),l=o>0?a/o*100:0;e.biomesUsed[s.id]={name:s.name,tilesUsed:i,setsRequired:a,setsOwned:o,efficiency:l.toFixed(1)}}}),e}}class tx{constructor(e){this.analytics=e}update(){const e=document.getElementById("efficiency-metrics");if(!e)return;this.analytics.getPlacementMode()==="unlimited"?this.renderUnlimitedMode(e):this.renderLimitedMode(e)}renderUnlimitedMode(e){const t=this.analytics.calculateTotalSetsUsed();e.innerHTML=`
      <div class="empty-state">
        <div class="mode-info">
          <h4><i class="fas fa-infinity"></i> Unlimited Mode</h4>
          <p>Sets Required: <strong>${t.toFixed(1)}</strong></p>
          <small>Efficiency metrics available only in Limited mode</small>
        </div>
      </div>
    `}renderLimitedMode(e){if(this.analytics.placedTiles.size===0){e.innerHTML='<div class="empty-state">No tiles placed yet</div>';return}const t=this.calculateAllMetrics(),n=this.analytics.calculateTotalSetsOwned(),i=this.analytics.placedTiles.size,s=n*50;e.innerHTML=`
      <div class="efficiency-content">
        <div class="metric-item">
          <div class="metric-label">
            <i class="fas fa-percentage"></i>
            <span>Set Efficiency</span>
      <div class="metric-help" title="Percentage of owned sets currently required (min sets needed per biome based on duplicate tile usage)"></div>
          </div>
          <div class="metric-value">${t.setEfficiency}%</div>
        </div>
  <div class="stat-subtle" style="padding: 0 var(--spacing-sm) var(--spacing-xs);">Tiles ${i} / Capacity ${s}</div>
        <div style="padding: 0 var(--spacing-sm) var(--spacing-sm) var(--spacing-sm);">
          <div class="progress ${this.classByPercent(t.setEfficiency)}">
            <div class="bar ${parseFloat(t.setEfficiency)>0?"has-value":""}" style="width:${t.setEfficiency}%"></div>
          </div>
        </div>
        
        <div class="metric-item">
          <div class="metric-label">
            <i class="fas fa-chart-bar"></i>
            <span>Tile Utilization</span>
            <div class="metric-help" title="Percentage of tiles used from sets that contain used tiles"></div>
          </div>
          <div class="metric-value">${t.tileUtilization}%</div>
        </div>
        <div style="padding: 0 var(--spacing-sm) var(--spacing-sm) var(--spacing-sm);">
          <div class="progress ${this.classByPercent(t.tileUtilization)}">
            <div class="bar ${parseFloat(t.tileUtilization)>0?"has-value":""}" style="width:${t.tileUtilization}%"></div>
          </div>
        </div>
        
        <div class="metric-item">
          <div class="metric-label">
            <i class="fas fa-exclamation-triangle"></i>
            <span>Unused Tiles</span>
            <div class="metric-help" title="Number of tiles in used sets that remain unused"></div>
          </div>
          <div class="metric-value">${t.unusedTiles} tiles</div>
        </div>
      </div>
    `}calculateAllMetrics(){const e=this.calculateSetEfficiency(),t=this.calculateTileUtilization(),n=this.calculateUnusedTiles(),i=this.calculateCostEfficiency(e,t);return{setEfficiency:e.toFixed(1),tileUtilization:t.toFixed(1),unusedTiles:n,costEfficiencyText:i.text,costEfficiencyClass:i.class}}calculateSetEfficiency(){const e=this.analytics.calculateTotalSetsOwned(),t=this.analytics.placedTiles.size,n=e*50;return n>0?t/n*100:0}calculateTileUtilization(){if(this.analytics.placedTiles.size===0)return 0;const e=this.analytics.groupTilesByBiome();let t=0,n=0;return Object.entries(e).forEach(([i,s])=>{if(this.analytics.biomeSets.find(o=>o.id===i||o.name===i)){const o=Math.ceil(s/50);t+=o*50,n+=s}}),t>0?n/t*100:0}calculateUnusedTiles(){const e=this.analytics.groupTilesByBiome();let t=0;return Object.entries(e).forEach(([n,i])=>{if(this.analytics.biomeSets.find(a=>a.id===n||a.name===n)){const o=Math.ceil(i/50)*50;t+=o-i}}),t}calculateCostEfficiency(e,t){const n=(e+t)/2;return n>=80?{text:"Excellent",class:"excellent"}:n>=60?{text:"Good",class:"good"}:n>=40?{text:"Fair",class:"fair"}:n>=20?{text:"Poor",class:"poor"}:{text:"Very Poor",class:"very-poor"}}classByPercent(e){const t=parseFloat(e);return t>=75?"gray-4":t>=50?"gray-3":t>=25?"gray-2":"gray-1"}generateDetailedReport(){const e={summary:this.calculateAllMetrics(),biomesAnalysis:{},recommendations:[]},t=this.analytics.groupTilesByBiome();return Object.entries(t).forEach(([n,i])=>{const s=this.analytics.biomeSets.find(a=>a.id===n||a.name===n);if(s){const a=Math.ceil(i/50),o=a*50,l=o-i,c=i/o*100;e.biomesAnalysis[s.id]={name:s.name,tilesUsed:i,setsUsed:a,utilization:c.toFixed(1),unused:l},c<50&&l>25&&e.recommendations.push({type:"efficiency",biome:s.name,message:`Consider using more ${s.name} tiles to improve efficiency (${l} unused tiles)`})}}),e}}const yd=Kn("analytics");class nx{constructor(e,t,n,i,s,a,o){this.placedTiles=e,this.packCounts=t,this.standaloneBiomeSetCounts=n,this.biomeSets=i,this.environmentPacks=s,this.getPlacementMode=a,this.tileInstanceLimits=o,this.headerStats=new J0(this),this.mapMetrics=new Q0(this),this.biomeAnalysis=new ex(this),this.efficiencyMetrics=new tx(this),yd.log(" MapAnalytics initialized")}updateAll(){yd.log(" Updating all analytics..."),this.updateHeaderStats(),this.updateRightPanelStats()}updateHeaderStats(){this.headerStats.update()}updateRightPanelStats(){this.updateMapOverview(),this.updateBiomeBreakdown(),this.updateEfficiencyMetrics()}updateMapOverview(){this.mapMetrics.updateOverview()}updateBiomeBreakdown(){this.biomeAnalysis.updateBreakdown()}updateEfficiencyMetrics(){this.efficiencyMetrics.update()}calculateTotalSetsUsed(){if(this.getPlacementMode()==="unlimited"){let t=0;return this.biomeSets.forEach(n=>{t+=this.calculateMinRequiredSets(n.id)}),t}else{let t=0;return this.biomeSets.forEach(n=>{t+=this.calculateMinRequiredSets(n.id)}),t}}calculateTotalSetsOwned(){const e=new Map;this.packCounts.forEach((n,i)=>{const s=this.environmentPacks.find(a=>a.id===i);s&&s.components&&s.components.forEach(a=>{e.set(a.setId,(e.get(a.setId)||0)+n*a.quantity)})}),this.standaloneBiomeSetCounts.forEach((n,i)=>{e.set(i,(e.get(i)||0)+n)});let t=0;return e.forEach(n=>{t+=n}),t}calculateHeightRange(){if(this.placedTiles.size===0)return"0";let e=-1/0;return this.placedTiles.forEach((t,n)=>{const i=parseInt(n.split(",y:")[1]);e=Math.max(e,i)}),`${e+1}`}calculateMapDimensions(){const e=Array.from(this.placedTiles.keys()).map(o=>{const l=o.match(/q:(-?\d+),r:(-?\d+),y:(-?\d+)/);return l?{q:parseInt(l[1]),r:parseInt(l[2]),y:parseInt(l[3])}:null}).filter(Boolean);if(e.length===0)return"0x0";const t=Math.min(...e.map(o=>o.r)),i=Math.max(...e.map(o=>o.r))-t+1,s=new Set;return e.forEach(o=>{const l=o.q+o.r*.5;s.add(Math.round(l*2))}),`${s.size}x${i}`}getBiomeTotalSets(e){let t=0;return this.packCounts.forEach((n,i)=>{const s=this.environmentPacks.find(a=>a.id===i);if(s&&s.components){const a=s.components.find(o=>o.setId===e);a&&(t+=n*a.quantity)}}),t+=this.standaloneBiomeSetCounts.get(e)||0,t}calculateMinRequiredSets(e){const t={};this.placedTiles.forEach(i=>{i.biomeId===e&&i.tileNumber!=null&&(t[i.tileNumber]=(t[i.tileNumber]||0)+1)});let n=0;return Object.values(t).forEach(i=>{n=Math.max(n,i)}),n}groupTilesByBiome(){const e={};return this.placedTiles.forEach(t=>{const n=t.biomeId||t.name;e[n]=(e[n]||0)+1}),e}}function ix(r){const{stateManager:e,biomeSets:t,environmentPacks:n,getPlacementMode:i,onHeaderStatsUpdated:s,onRightPanelStatsUpdated:a}=r;if(!e)throw new Error("createAnalyticsController requires a stateManager instance");const{packCounts:o,standaloneBiomeSetCounts:l,perBiomeDenominator:c,tileInstanceLimits:d,placedTiles:u,setUpdateCallbacks:h,ensureBiomeInitialized:m,getBiomeTotalSets:_}=e;let v=null,y=!1,p=!1;const f=()=>{if(v&&!y){y=!0;try{v.updateHeaderStats(),s==null||s()}finally{y=!1}}},b=()=>{if(v&&!p){p=!0;try{v.updateRightPanelStats(),a==null||a()}finally{p=!1}}},M=()=>{f(),b()},S=(E,N,K)=>Math.min(K,Math.max(N,E));function x(){return v=new nx(u,o,l,t,n,i,d),h({updateHeaderStats:f,updateRightPanelStats:b}),v}function I({biomeId:E,instanceId:N,delta:K=0,silent:J=!1}){if(((i==null?void 0:i())??"limited")!=="limited"||!N||!E)return J||M(),{remaining:null,originalTotal:null,usedUp:!1};m==null||m(E);const O=c.get(E)||(_==null?void 0:_(E))||0,H=d.get(N),B=S((typeof H=="number"?H:O)+K,0,O);return d.set(N,B),J||M(),{remaining:B,originalTotal:O,usedUp:B===0}}function V({biomeId:E,instanceId:N,silent:K=!1}={}){return I({biomeId:E,instanceId:N,delta:-1,silent:K})}function Y({biomeId:E,instanceId:N,silent:K=!1}={}){return I({biomeId:E,instanceId:N,delta:1,silent:K})}function j({biomeId:E,instanceId:N,value:K,silent:J=!1}={}){if(((i==null?void 0:i())??"limited")!=="limited"||!N||!E)return J||M(),{remaining:null,originalTotal:null,usedUp:!1};m==null||m(E);const O=c.get(E)||(_==null?void 0:_(E))||0,H=S(K??O,0,O);return d.set(N,H),J||M(),{remaining:H,originalTotal:O,usedUp:H===0}}function G(E,{silent:N=!1}={}){E&&(E.forEach((K,J)=>{const[T]=J.split("_");T&&j({biomeId:T,instanceId:J,value:K,silent:!0})}),N||M())}function q({reinitialize:E=!0,silent:N=!1}={}){d.clear(),E&&(i==null?void 0:i())==="limited"&&t.forEach(K=>m==null?void 0:m(K.id)),N||M()}function C({silent:E=!1}={}){q({reinitialize:!0,silent:!0}),u.forEach(N=>{if(!N)return;const K=N.instanceId;if(!K)return;const J=N.biomeId||N.name||K.split("_").slice(0,-1).join("_");J&&V({biomeId:J,instanceId:K,silent:!0})}),E||M()}function W(){M()}function z(){return v}return{initialize:x,getAnalytics:z,updateHeaderStats:f,updateRightPanelStats:b,notifyStateChange:W,decrementTileAvailability:V,incrementTileAvailability:Y,setTileAvailability:j,applyTileLimitsSnapshot:G,resetTileAvailability:q,recomputeTileAvailabilityFromPlacedTiles:C}}const hn=Kn("ui");function sx(r){const{environmentPacks:e,biomeSets:t,packCounts:n,standaloneBiomeSetCounts:i,tileInstanceLimits:s,ensureBiomeInitialized:a,setPackCount:o,setStandaloneBiomeSetCount:l,getBiomeTotalSets:c,getTotalFromPacks:d,getPlacementMode:u,setPlacementMode:h,resetPlacementRotation:m,createOrUpdateGhostTile:_,getSelectedTileInfo:v,setSelectedTileInfo:y,setSelectedTile:p,updateHeaderStats:f,updateRightPanelStats:b,updateUndoRedoButtons:M,getGhostOpacities:S,setupGhostOpacityControls:x,placeholderSprite:I,getGridTexturePath:V}=r;let Y="packs",j=null,G=!1,q="",C="grid",W=!1,z=!1,E=!1;const N=I,K=new Map,J=new Map;function T(g){const A=K.get(g);if(A&&A.isConnected)return A;const R=document.getElementById(g);return R?K.set(g,R):K.delete(g),R}function O(g){const A=J.get(g);if(A&&A.every(F=>F.isConnected))return A;const R=Array.from(document.querySelectorAll(g));return J.set(g,R),R}function H(){B(),Q(),ce(),re(),Be(),x==null||x(),f==null||f(),b==null||b(),M==null||M(),Ne(Y),Yt(),W||(window.addEventListener("keydown",ee),W=!0),hn.log(" Modern interface fully initialized!")}function ee(g){const A=g.target&&g.target.tagName?g.target.tagName.toLowerCase():"";if(!(g.target&&(g.target.isContentEditable||A==="input"||A==="textarea"||A==="select"))&&!(g.ctrlKey||g.metaKey||g.altKey)&&(g.code==="NumpadMultiply"||g.key==="*"&&g.location===KeyboardEvent.DOM_KEY_LOCATION_NUMPAD)){const F=T("ghost-opacity-controls");if(!F)return;if(F.classList.toggle("hidden"),!F.classList.contains("hidden")){const te=T("ghost-top-opacity"),he=T("ghost-side-opacity"),ie=T("ghost-top-opacity-value"),ge=T("ghost-side-opacity-value");if(te&&he&&ie&&ge){const{top:Ee,side:Me}=S();te.value=String(Ee),he.value=String(Me),ie.textContent=Ee.toFixed(2),ge.textContent=Me.toFixed(2)}}}}function B(){const g=O('input[name="buildMode"]');if(!g.length){hn.warn("UIController: No build mode radio buttons found.");return}g.forEach(A=>{A.addEventListener("change",R=>{const F=R.target.value;h==null||h(F),hn.log(`Build mode changed to: ${F}`),m==null||m(),ne(),f==null||f(),b==null||b(),ue()})}),ne()}function ne(){const g=(u==null?void 0:u())||"limited";document.querySelectorAll(".badge").forEach(R=>{R.style.display=g==="unlimited"?"none":"block"})}function Q(){const g=O(".tab-btn"),A=O(".tab-content");if(!g.length||!A.length){hn.warn("UIController: Expected tab navigation elements were not found.");return}g.forEach(R=>{R.addEventListener("click",F=>{const te=F.currentTarget.dataset.tab;se(te)})}),se("packs")}function se(g){if(!g||Y===g)return;Y=g;const A=O(".tab-btn"),R=O(".tab-content");A.forEach(F=>{F.classList.toggle("active",F.dataset.tab===g)}),R.forEach(F=>{F.classList.toggle("active",F.id===`tab-${g}`)}),Ne(g),Yt()}function re(){const g=T("search-input"),A=T("search-clear");if(!g){hn.warn("UIController: Search input field was not found.");return}if(!g.dataset.controllerBound){let R;g.addEventListener("input",F=>{clearTimeout(R),R=window.setTimeout(()=>{q=F.target.value.toLowerCase().trim(),be(),me()},300)}),g.addEventListener("keydown",F=>{F.key==="Enter"&&(F.preventDefault(),q=F.target.value.toLowerCase().trim(),be())}),g.dataset.controllerBound="true"}A&&!A.dataset.controllerBound&&(A.addEventListener("click",()=>{q="",g&&(g.value="",g.focus()),be(),me()}),A.dataset.controllerBound="true"),me()}function be(){switch(Y){case"packs":le();break;case"biomes":de();break;default:D();break}}function me(){const g=T("search-clear");g&&(g.style.display=q?"block":"none")}function Ne(g){switch(g){case"packs":Le();break;case"biomes":ve();break;default:hn.warn(`UIController: Unknown tab requested: ${g}`)}}function ue(){if(Y==="packs"&&!z){Le({force:!0});return}Ne(Y)}function le(){if(!z){Le({force:!0});return}const g=document.querySelectorAll(".pack-card");let A=0;g.forEach(R=>{var ge;const F=R.dataset.packId,te=e.find(Ee=>Ee.id===F);if(!te){R.style.display="none";return}const he=((ge=te.components)==null?void 0:ge.map(Ee=>{const Me=t.find(Oe=>Oe.id===Ee.setId);return Me?Me.name:Ee.setId}).join(" "))||"",ie=`${te.name} ${he}`.toLowerCase();!q||ie.includes(q)?(R.style.display="",A+=1):R.style.display="none"}),L("packs",A,e.length)}function ae(g){const A=Math.min(4,Math.max(2,Math.round(window.innerHeight/220))),R=document.createDocumentFragment();for(let F=0;F<A;F+=1){const te=document.createElement("div");te.className="card pack-card skeleton",te.innerHTML=`
        <div class="card-left">
          <div class="pack-image skeleton-thumb"></div>
        </div>
        <div class="card-right">
          <div class="skeleton-line short"></div>
          <div class="skeleton-line"></div>
          <div class="skeleton-line"></div>
        </div>
      `,R.appendChild(te)}g.innerHTML="",g.appendChild(R)}function Le({force:g=!1}={}){if(z){U();return}if(E)g&&(E=!1,U());else{const A=document.getElementById("packs-grid");A&&ae(A),E=!0,(typeof window.requestIdleCallback=="function"?F=>window.requestIdleCallback(F,{timeout:g?120:2e3}):F=>window.setTimeout(F,g?120:400))(()=>{E=!1,U()})}}function de(){const g=document.querySelectorAll(".biome-card");let A=0;g.forEach(R=>{const F=R.dataset.biomeId,te=t.find(ie=>ie.id===F);if(!te){R.style.display="none";return}const he=te.name.toLowerCase();!q||he.includes(q)?(R.style.display="",A+=1):R.style.display="none"}),L("biomes",A,t.length)}function D(){const g=T("biome-select");if(!g){hn.warn("UIController: Biome select element missing while searching tiles.");return}const A=g.querySelectorAll("option");let R=0;A.forEach(F=>{if(!F.value)return;const te=t.find(ge=>ge.id===F.value);if(!te)return;const he=te.name.toLowerCase(),ie=!q||he.includes(q);F.style.display=ie?"block":"none",ie&&(R+=1)}),L("tiles",R,Mi().length)}function L(g,A,R){const F=document.querySelector(`#tab-${g} .section-header .count`);if(F&&(F.textContent=q?`${A} of ${R} (filtered)`:`${R} available`),g==="packs"||g==="biomes"){const te=g==="packs"?"packs-grid":"biomes-grid",he=document.getElementById(te);if(he){const ie=he.querySelector(".asset-empty-state"),ge=he.querySelector(".cards-grid");ie&&(ie.style.display=A===0?"flex":"none"),ge&&(ge.style.display=A===0?"none":"")}}}function ce(){const g=document.getElementById("left-panel"),A=document.getElementById("right-panel"),R=document.getElementById("edge-toggle-left"),F=document.getElementById("edge-toggle-right"),te=window.matchMedia("(max-width: 740px)"),he=()=>te.matches;let ie=null;const ge=()=>{const we=g?g.getBoundingClientRect():{right:0,bottom:0},ze=A?A.getBoundingClientRect():{left:window.innerWidth,bottom:0},Ce=24,tt=10;if(R){R.style.top="",R.style.right="";const Ge=Math.max(0,window.innerHeight-we.bottom)+tt;R.style.bottom=`${Math.round(Ge)}px`;const st=Math.max(0,Math.round(we.right-1));R.style.left=`${st}px`,R.classList.add("edge-bottom")}if(F){F.style.top="",F.style.right="";const Ge=Math.max(0,window.innerHeight-ze.bottom)+tt;F.style.bottom=`${Math.round(Ge)}px`;const st=Math.min(window.innerWidth-Ce,Math.round(ze.left-Ce));F.style.left=`${st}px`,F.classList.add("edge-bottom")}},Ee=we=>we?he()?we.classList.contains("open"):!we.classList.contains("collapsed"):!1,Me=()=>{if(R){const we=R.querySelector("i");Ee(g)?(we.className="fas fa-chevron-left",R.classList.add("edge-offset")):(we.className="fas fa-chevron-right",R.classList.remove("edge-offset"))}if(F){const we=F.querySelector("i");Ee(A)?(we.className="fas fa-chevron-right",F.classList.add("edge-offset")):(we.className="fas fa-chevron-left",F.classList.remove("edge-offset"))}ge()},Oe=we=>{ie&&cancelAnimationFrame(ie);const ze=()=>{we(),ie=requestAnimationFrame(ze)};ze(),setTimeout(()=>{ie&&(cancelAnimationFrame(ie),ie=null),we()},240)},Fe=()=>{g&&(he()?(g.classList.toggle("open"),g.classList.remove("collapsed")):(g.classList.toggle("collapsed"),g.classList.remove("open")),Me(),Oe(ge),setTimeout(()=>window.dispatchEvent(new Event("resize")),260))},Ue=()=>{A&&(he()?(A.classList.toggle("open"),A.classList.remove("collapsed")):(A.classList.toggle("collapsed"),A.classList.remove("open")),Me(),Oe(ge),setTimeout(()=>window.dispatchEvent(new Event("resize")),260))};if(R==null||R.addEventListener("click",Fe),F==null||F.addEventListener("click",Ue),Me(),ge(),window.addEventListener("resize",()=>{ge()}),window.ResizeObserver){const we=new ResizeObserver(()=>{ge()});g&&we.observe(g),A&&we.observe(A)}oe();const Je=(we,ze,{minWidth:Ce,maxWidth:tt,computeWidth:Ge}={})=>{if(!we||!ze||typeof Ge!="function")return;let st=!1,kt=0,Et=0;const Zt=typeof Ce=="function"?Ce:()=>Ce,At=typeof tt=="function"?tt:()=>tt,Mt=$e=>{if(!st)return;const Ot=Ge({event:$e,startX:kt,startWidth:Et}),Gt=Math.min(At(),Math.max(Zt(),Ot));ze.style.width=`${Gt}px`,ge()},Qe=()=>{st&&(st=!1,document.removeEventListener("mousemove",Mt),document.removeEventListener("mouseup",Qe),setTimeout(()=>window.dispatchEvent(new Event("resize")),0))};we.addEventListener("mousedown",$e=>{ze.classList.contains("collapsed")||(st=!0,kt=$e.clientX,Et=ze.getBoundingClientRect().width,document.addEventListener("mousemove",Mt),document.addEventListener("mouseup",Qe),$e.preventDefault())})},je=document.getElementById("right-resize-handle");Je(je,A,{minWidth:240,maxWidth:()=>Math.round(window.innerWidth*.5),computeWidth:({event:we,startX:ze,startWidth:Ce})=>Ce+(ze-we.clientX)});const Ke=document.getElementById("left-resize-handle");Je(Ke,g,{minWidth:280,maxWidth:()=>Math.round(window.innerWidth*.6),computeWidth:({event:we,startX:ze,startWidth:Ce})=>Ce+(we.clientX-ze)})}function oe(){const g=window.matchMedia("(max-width: 740px)");function A(R){const F=document.getElementById("left-panel"),te=document.getElementById("right-panel");R.matches?(F==null||F.classList.add("mobile"),te==null||te.classList.add("mobile"),F==null||F.classList.remove("collapsed"),te==null||te.classList.remove("collapsed"),F==null||F.classList.remove("open"),te==null||te.classList.remove("open")):(F==null||F.classList.remove("mobile"),te==null||te.classList.remove("mobile"),F==null||F.classList.remove("open"),te==null||te.classList.remove("open"))}typeof g.addEventListener=="function"?g.addEventListener("change",A):typeof g.addListener=="function"&&g.addListener(A),A(g)}function Te(){const g=document.createElement("div");g.className="view-toggle asset-view-toggle",g.setAttribute("role","group"),g.setAttribute("aria-label","Toggle asset view");const A=document.createElement("button");A.className="view-toggle-btn",A.type="button",A.dataset.view="grid",A.title="Grid view",A.innerHTML=`
      <i class="fas fa-table-cells-large" aria-hidden="true"></i>
      <span class="view-label">Grid</span>
    `,g.appendChild(A);const R=document.createElement("button");return R.className="view-toggle-btn",R.type="button",R.dataset.view="list",R.title="List view",R.innerHTML=`
      <i class="fas fa-list" aria-hidden="true"></i>
      <span class="view-label">List</span>
    `,g.appendChild(R),g}function Be(){const g=document.querySelectorAll(".view-toggle-btn");g.length&&(g.forEach(A=>{A.dataset.toggleBound!=="true"&&(A.addEventListener("click",R=>{var te,he;const F=(he=(te=R.currentTarget)==null?void 0:te.dataset)==null?void 0:he.view;F&&qe(F)}),A.dataset.toggleBound="true")}),X())}function qe(g){if(!(g!=="grid"&&g!=="list")){if(C===g){X();return}C=g,X(),be()}}function X(){[document.getElementById("packs-grid"),document.getElementById("biomes-grid")].forEach(R=>{R&&(R.classList.remove("asset-view-grid","asset-view-list"),R.classList.add(C==="list"?"asset-view-list":"asset-view-grid"))}),document.querySelectorAll(".view-toggle-btn").forEach(R=>{const F=R.dataset.view===C;R.classList.toggle("active",F),R.setAttribute("aria-pressed",F?"true":"false")})}function U(){const g=document.getElementById("packs-grid");if(!g){hn.error(" packs-grid container not found!");return}E=!1,z=!0,g.innerHTML="";const A=document.createElement("div");A.className="section-header section-header--with-controls";const R=document.createElement("div");R.className="section-heading",R.innerHTML=`
      <h3>Environment Packs</h3>
      <span class="count">${e.length} available</span>
    `,A.appendChild(R);const F=document.createElement("div");F.className="section-controls",F.appendChild(Te()),A.appendChild(F),g.appendChild(A),Be();const te=document.createElement("div");te.className="cards-grid",g.appendChild(te);const he=document.createElement("div");he.className="asset-empty-state",he.innerHTML='<i class="fas fa-search"></i><span>No environment packs match your search.</span>',g.appendChild(he),e.forEach(ie=>{const ge=_e(ie);te.appendChild(ge)}),X(),q?le():L("packs",e.length,e.length)}function _e(g){const A=document.createElement("div");A.className="card pack-card",A.dataset.packId=g.id;const R=n.get(g.id)||0,F=R>0;F&&A.classList.add("selected");const te=document.createElement("div");te.className="card-left";const he=document.createElement("div");he.className="card-image",he.setAttribute("role","button"),he.tabIndex=0;const ie=Qn("pack",g.id);he.style.backgroundImage=`url('${ie}')`;const ge=document.createElement("div");ge.className="card-title-overlay",ge.textContent=g.name,he.appendChild(ge);const Ee=document.createElement("div");Ee.className="click-indicator",Ee.innerHTML='<i class="fas fa-check"></i>',he.appendChild(Ee);const Me=document.createElement("div");Me.className="selection-indicator",Me.innerHTML='<i class="fas fa-check"></i>',he.appendChild(Me),te.appendChild(he),A.appendChild(te);const Oe=document.createElement("div");Oe.className="card-right";const Fe=g.components.map(Qe=>{const $e=t.find(Ot=>Ot.id===Qe.setId);return $e?$e.name:Qe.setId}),Ue=Fe.join(", "),Je=Fe.length,je=[];if(Number.isFinite(g.totalTiles)){const Qe=g.totalTiles===1?"tile":"tiles";je.push(`${g.totalTiles} ${Qe}`)}je.push(`${Je} ${Je===1?"biome":"biomes"}`),g.type&&je.push(g.type),g.scale&&je.push(g.scale);const Ke=je.slice(0,2).join("  "),we=[g.name];Ue&&we.push(`Contains: ${Ue}`),Ke&&we.push(Ke);const ze=we.join(`
`);ze?(he.title=`${ze}

Click to toggle selection.`,he.setAttribute("aria-label",`${we.join(". ")}. Click to toggle selection.`)):(he.title="Click to select/deselect this pack",he.setAttribute("aria-label","Select pack: click to toggle"));const Ce=document.createElement("button");Ce.type="button",Ce.className="card-list-entry",Ce.setAttribute("aria-pressed",F?"true":"false");const tt=document.createElement("img");tt.className="entry-thumb",tt.src=ie,tt.loading="lazy",tt.decoding="async",tt.alt=Ue?`${g.name} preview showing ${Ue}`:`${g.name} preview image`,tt.onerror=()=>{tt.onerror=null,tt.src="images/grids/placeholder-grid-biome-set.png"},Ce.appendChild(tt);const Ge=document.createElement("span");if(Ge.className="entry-title",Ge.textContent=g.name,Ce.appendChild(Ge),Ke){const Qe=document.createElement("span");Qe.className="entry-meta",Qe.textContent=Ke,Ce.appendChild(Qe)}ze?(Ce.title=ze,Ce.setAttribute("aria-label",`${we.join(". ")}. Click to toggle selection.`)):(Ce.title=g.name,Ce.setAttribute("aria-label",`Select ${g.name}`)),Oe.appendChild(Ce);const st=document.createElement("div");st.className="pack-components",st.innerHTML=`
      <span class="components-label">Contains:</span>
      <span class="components-list">${Ue}</span>
    `,st.title=`Contains: ${Ue}`,Oe.appendChild(st);const kt=document.createElement("div");kt.className="card-controls";const Et=document.createElement("div");Et.className="quantity-container";const Zt=document.createElement("label");Zt.textContent="Quantity:",Zt.htmlFor=`pack-qty-${g.id}`;const At=document.createElement("input");if(At.type="number",At.id=`pack-qty-${g.id}`,At.min="0",At.step="1",At.value=R.toString(),At.dataset.lastValidValue=At.value,At.disabled=!1,At.addEventListener("change",Qe=>{const $e=Qe.target.value,Ot=Math.max(0,parseInt($e,10)||0),Gt=n.get(g.id)||0,cn=at=>{const _t=(Number.isFinite(at)?at:Gt).toString();return Qe.target.value!==_t&&(Qe.target.value=_t),Qe.target.dataset.lastValidValue=_t,_t};if(Ot===Gt){cn(Gt);return}cn(Gt);const Sn=De(g.id,Ot),Vt=n.get(g.id);cn(Vt!==void 0?Vt:Sn)}),At.addEventListener("keydown",Qe=>{Qe.key==="Enter"&&Qe.target.blur()}),Et.appendChild(Zt),Et.appendChild(At),kt.appendChild(Et),Oe.appendChild(kt),A.appendChild(Oe),((u==null?void 0:u())||"limited")==="limited"&&F){const Qe=document.createElement("div");Qe.className="badge quantity-badge",Qe.textContent=R.toString(),A.appendChild(Qe)}const Mt=()=>{var Ot;if((n.get(g.id)||0)>0)De(g.id,0);else{const Gt=parseInt(((Ot=document.getElementById(`pack-qty-${g.id}`))==null?void 0:Ot.value)||"1",10);De(g.id,Math.max(1,Gt))}};return he.addEventListener("click",Mt),he.addEventListener("keydown",Qe=>{(Qe.key==="Enter"||Qe.key===" ")&&(Qe.preventDefault(),Mt())}),Ce.addEventListener("click",Qe=>{Qe.preventDefault(),Mt()}),A}function Se(g){const A=document.querySelector(`[data-pack-id="${g}"]`);if(!A)return;const R=n.get(g)||0,F=R>0,te=(u==null?void 0:u())||"limited";A.classList.toggle("selected",F);let he=A.querySelector(".quantity-badge");te==="limited"&&F?(he||(he=document.createElement("div"),he.className="badge quantity-badge",A.appendChild(he)),he.textContent=R.toString(),he.style.display="block"):he&&(he.style.display="none");const ie=A.querySelector('input[type="number"]');if(ie){const Ee=R.toString();ie.value!==Ee&&(ie.value=Ee),ie.dataset.lastValidValue=Ee,ie.disabled=!1}const ge=A.querySelector(".card-list-entry");ge&&ge.setAttribute("aria-pressed",F?"true":"false")}function De(g,A){const R=o(g,A);return Se(g),Y==="biomes"&&ve(),Yt(),f==null||f(),b==null||b(),R}function ve(){hn.log("Rendering Biome Sets...");const g=document.getElementById("biomes-grid");if(!g)return;g.innerHTML="";const A=document.createElement("div");A.className="section-header section-header--with-controls";const R=document.createElement("div");R.className="section-heading",R.innerHTML=`
      <h3>Biome Sets</h3>
      <span class="count">${t.length} available</span>
    `,A.appendChild(R);const F=document.createElement("div");F.className="section-controls",F.appendChild(Te()),A.appendChild(F),g.appendChild(A),Be();const te=document.createElement("div");te.className="cards-grid",g.appendChild(te);const he=document.createElement("div");he.className="asset-empty-state",he.innerHTML='<i class="fas fa-search"></i><span>No biome sets match your search.</span>',g.appendChild(he),t.forEach(ie=>{const ge=it(ie);te.appendChild(ge)}),X(),q?de():L("biomes",t.length,t.length)}function We(g,{availableFromPacks:A,totalFromPacks:R=0,currentCount:F=0}){if(!g)return;const te=Math.max(0,Number(R)||0),he=A&&te>0,ie=he?te:0,ge=Math.max(0,Number(F)||0);g.classList.toggle("packs-available",he),g.classList.toggle("packs-unavailable",!he),g.dataset.packSets=String(ie),g.dataset.standaloneSets=String(ge),g.setAttribute("role","group"),g.setAttribute("aria-label","Selection breakdown");const Ee=he?`Sets available from selected packs: ${ie}`:"No selected packs currently include this biome set.",Me=`Standalone sets selected: ${ge}`;g.innerHTML=`
      <span class="availability-chip pack-chip" aria-label="Sets from packs: ${ie}" title="${Ee}">
        <span class="chip-label">Packs</span>
        <span class="chip-value">${ie}</span>
      </span>
      <span class="availability-chip standalone-chip${ge?" is-active":""}" aria-label="Standalone sets: ${ge}" title="${Me}">
        <span class="chip-label">Standalone</span>
        <span class="chip-value">${ge}</span>
      </span>
    `}function it(g){const A=document.createElement("div");A.className="card biome-card",A.dataset.biomeId=g.id;const R=i.get(g.id)||0,F=R>0,te=Si(g.id);F&&A.classList.add("selected"),A.classList.add(te?"available-from-packs":"unavailable");const he=document.createElement("div");he.className="card-left";const ie=document.createElement("div");ie.className="card-image",ie.setAttribute("role","button"),ie.tabIndex=0;const ge=Qn("biome",g.id);ie.style.backgroundImage=`url('${ge}')`;const Ee=new Image;Ee.onerror=()=>{ie.style.backgroundImage="url('images/grids/placeholder-grid-biome-set.png')"},Ee.src=ge;const Me=document.createElement("div");Me.className="card-title-overlay",Me.textContent=g.name,ie.appendChild(Me);const Oe=document.createElement("div");Oe.className="click-indicator",Oe.innerHTML='<i class="fas fa-check"></i>',ie.appendChild(Oe);const Fe=document.createElement("div");if(Fe.className="selection-indicator",Fe.innerHTML='<i class="fas fa-check"></i>',ie.appendChild(Fe),te){const $e=document.createElement("div");$e.className="pack-indicator",$e.innerHTML='<i class="fas fa-box"></i>',$e.title="Available from Environment Packs",ie.appendChild($e)}he.appendChild(ie),A.appendChild(he);const Ue=document.createElement("div");Ue.className="card-right";const Je=[],je=[];if(g.biomeParent&&(Je.push(g.biomeParent),je.push(`<span class="meta-item"><i class="fas fa-globe" aria-hidden="true"></i>${g.biomeParent}</span>`)),Number.isFinite(g.tiles)){const $e=g.tiles===1?"tile":"tiles";Je.push(`${g.tiles} ${$e}`),je.push(`<span class="meta-item"><i class="fas fa-th-large" aria-hidden="true"></i>${g.tiles} ${$e}</span>`)}g.scale&&(Je.push(g.scale),je.push(`<span class="meta-item"><i class="fas fa-ruler" aria-hidden="true"></i>${g.scale}</span>`));const Ke=te?d(g.id):0,we=document.createElement("button");we.type="button",we.className="card-list-entry",we.setAttribute("aria-pressed",F?"true":"false");const ze=document.createElement("img");ze.className="entry-thumb",ze.src=ge,ze.loading="lazy",ze.decoding="async",ze.alt=`${g.name} preview image`,ze.onerror=()=>{ze.onerror=null,ze.src="images/grids/placeholder-grid-biome-set.png"},we.appendChild(ze);const Ce=document.createElement("span");Ce.className="entry-title",Ce.textContent=g.name,we.appendChild(Ce);const tt=Je.slice(0,2).join("  ");if(tt){const $e=document.createElement("span");$e.className="entry-meta",$e.textContent=tt,we.appendChild($e),ze.alt=`${g.name} preview  ${tt}`}const Ge=[g.name];tt&&Ge.push(tt),te&&Ge.push(`In packs: ${Ke}`);const st=Ge.join(`
`);we.title=st,we.setAttribute("aria-label",`${Ge.join(". ")}. Click to toggle selection.`),st?(ie.title=`${st}

Click to toggle selection.`,ie.setAttribute("aria-label",`${Ge.join(". ")}. Click to toggle selection.`)):(ie.title="Click to select/deselect this biome set",ie.setAttribute("aria-label","Select biome set: click to toggle")),Ue.appendChild(we);const kt=document.createElement("div");if(kt.className="biome-availability",We(kt,{availableFromPacks:te,totalFromPacks:Ke,currentCount:R}),Ue.appendChild(kt),g.description){const $e=document.createElement("p");$e.className="card-summary",$e.textContent=g.description,Ue.appendChild($e)}if(je.length){const $e=document.createElement("div");$e.className="card-meta",$e.innerHTML=je.join(""),Ue.appendChild($e)}const Et=document.createElement("div");Et.className="card-controls";const Zt=document.createElement("div");Zt.className="quantity-container";const At=document.createElement("label");At.textContent="Standalone Quantity:",At.htmlFor=`biome-qty-${g.id}`;const Mt=document.createElement("input");if(Mt.type="number",Mt.id=`biome-qty-${g.id}`,Mt.min="0",Mt.step="1",Mt.value=R.toString(),Mt.dataset.lastValidValue=Mt.value,Mt.disabled=!1,Mt.addEventListener("change",$e=>{const Ot=$e.target.value,Gt=Math.max(0,parseInt(Ot,10)||0),cn=i.get(g.id)||0;if(Gt!==cn){const Sn=vt(g.id,Gt),Vt=Number.isFinite(Sn)?Sn:cn,_t=(i.get(g.id)??Vt).toString();$e.target.value!==_t&&($e.target.value=_t),$e.target.dataset.lastValidValue=_t}else{const Sn=cn.toString();Ot!==Sn&&($e.target.value=Sn),$e.target.dataset.lastValidValue=Sn}}),Mt.addEventListener("keydown",$e=>{$e.key==="Enter"&&$e.target.blur()}),Zt.appendChild(At),Zt.appendChild(Mt),Et.appendChild(Zt),Ue.appendChild(Et),A.appendChild(Ue),((u==null?void 0:u())||"limited")==="limited"&&(F||te)){const $e=document.createElement("div");$e.className="badge quantity-badge";const Ot=c(g.id);$e.textContent=Ot.toString(),A.appendChild($e)}const Qe=()=>{var Gt;if((i.get(g.id)||0)>0)vt(g.id,0);else{const cn=parseInt(((Gt=document.getElementById(`biome-qty-${g.id}`))==null?void 0:Gt.value)||"1",10);vt(g.id,Math.max(1,cn))}};return ie.addEventListener("click",Qe),ie.addEventListener("keydown",$e=>{($e.key==="Enter"||$e.key===" ")&&($e.preventDefault(),Qe())}),we.addEventListener("click",$e=>{$e.preventDefault(),Qe()}),A}function rt(g){const A=document.querySelector(`[data-biome-id="${g}"]`);if(!A)return;const R=i.get(g)||0,F=R>0,te=Pe(g),he=c(g);A.classList.toggle("selected",F),A.classList.toggle("available-from-packs",te),A.classList.toggle("unavailable",!te);const ie=A.querySelector(".biome-availability");if(ie){const Oe=te?d(g):0;We(ie,{availableFromPacks:te,totalFromPacks:Oe,currentCount:R})}let ge=A.querySelector(".quantity-badge");((u==null?void 0:u())||"limited")==="limited"&&(F||te)?(ge||(ge=document.createElement("div"),ge.className="badge quantity-badge",A.appendChild(ge)),ge.textContent=he.toString(),ge.style.display="block"):ge&&(ge.style.display="none");const Ee=A.querySelector('input[type="number"]');if(Ee){const Oe=R.toString();Ee.value!==Oe&&(Ee.value=Oe),Ee.dataset.lastValidValue=Oe,Ee.disabled=!1}const Me=A.querySelector(".card-list-entry");Me&&Me.setAttribute("aria-pressed",F?"true":"false")}function vt(g,A){const R=l(g,A);return rt(g),mt(),Yt(),f==null||f(),b==null||b(),R}function mt(){j&&(G||(G=!0,It(j),G=!1))}function It(g){if(!g)return;j=g,a==null||a(g.id);const A=document.getElementById("tile-grid-wrapper");if(!A){hn.error(" tile-grid-wrapper container not found!");return}A.innerHTML="";const R=(u==null?void 0:u())||"limited",F=(c==null?void 0:c(g.id))??0,te=Jn(g.id),he=R==="unlimited"?"":Math.max(0,F*50-te),ie=document.createElement("div");ie.className="grid-info-panel",ie.innerHTML=`
      <span class="info-compact">Sets: ${F}, Tiles: ${te} used, ${he} available</span>
    `,A.appendChild(ie);const ge=document.createElement("div");ge.className="enhanced-tile-grid";const Ee=document.createElement("div");Ee.className="tile-grid modern-grid",Ee.id="main-tile-grid";const Oe=`url('${ln(g)}')`;for(let Je=0;Je<50;Je++)Ee.appendChild(jt(g,Je,Oe));ge.appendChild(Ee),A.appendChild(ge);const Fe=v==null?void 0:v();!Fe||Fe.biomeId!==g.id?Ui(g):wi();const Ue=document.getElementById("biome-select");Ue&&(Ue.value=g.id)}function jt(g,A,R){const F=(u==null?void 0:u())||"limited",te=A+1,he=`${g.id}_${te}`,ie=document.createElement("div");ie.className="tile-slot enhanced-slot",ie.dataset.slotIndex=String(A),ie.dataset.slotKey=he,ie.dataset.biomeId=g.id,ie.setAttribute("tabindex","0");let ge=5,Ee=10;if(typeof V=="function"){const Ge=V(g.id);Ge&&Ge.gridSize&&(ge=Ge.gridSize.cols||5,Ee=Ge.gridSize.rows||10)}const Me=A%ge,Oe=Math.floor(A/ge),Fe=ge===1?0:Me/(ge-1)*100,Ue=Ee===1?0:Oe/(Ee-1)*100;ie.style.backgroundImage=R,ie.style.backgroundSize=`${ge*100}% ${Ee*100}%`,ie.style.backgroundPosition=`${Fe}% ${Ue}%`,a==null||a(g.id);const Je=(c==null?void 0:c(g.id))??0,je=F==="limited"?s.get(he)??Je:1/0,Ke=F==="unlimited"||je>0,we=F==="limited"&&je<Je;Ke||ie.classList.add("used-up"),we&&ie.classList.add("partially-used"),Ke&&ie.classList.add("available");const ze=document.createElement("div");if(ze.className="slot-number",ze.textContent=String(te),ie.appendChild(ze),F==="limited"){const Ge=document.createElement("div");Ge.className="quantity-badge slot-badge",Ge.textContent=`${je}/${Je}`,je===0?Ge.classList.add("depleted"):je<Je&&Ge.classList.add("partial"),ie.appendChild(Ge)}const Ce=document.createElement("div");Ce.className="slot-selection-indicator",Ce.innerHTML='<i class="fas fa-check-circle"></i>',ie.appendChild(Ce);const tt=document.createElement("div");return tt.className="slot-tooltip",F==="limited"?tt.innerHTML=`
        <strong>Slot ${te}</strong><br>
        Available: ${je}/${Je}<br>
        Status: ${Ke?we?"Partially Used":"Available":"Used Up"}
      `:tt.innerHTML=`
        <strong>Slot ${te}</strong><br>
        Status: Unlimited
      `,ie.appendChild(tt),ie.addEventListener("click",Ge=>{Ge.preventDefault(),!(F==="limited"&&!Ke)&&yn(g,A,he)}),ie.addEventListener("keydown",Ge=>{var Zt,At;const st=parseInt(ie.dataset.slotIndex||"0",10),kt=5;["ArrowRight","ArrowLeft","ArrowUp","ArrowDown","Home","End","Enter"," "].includes(Ge.key)&&Ge.preventDefault();let Et=st;if(Ge.key==="ArrowRight"&&(Et=Math.min(49,st+1)),Ge.key==="ArrowLeft"&&(Et=Math.max(0,st-1)),Ge.key==="ArrowDown"&&(Et=Math.min(49,st+kt)),Ge.key==="ArrowUp"&&(Et=Math.max(0,st-kt)),Ge.key==="Home"&&(Et=0),Ge.key==="End"&&(Et=49),Et!==st&&!["Enter"," "].includes(Ge.key)&&((At=(Zt=ie.parentElement)==null?void 0:Zt.querySelector(`[data-slot-index="${Et}"]`))==null||At.focus()),["Enter"," "].includes(Ge.key)){if(F==="limited"&&!Ke)return;yn(g,A,he)}}),ie.addEventListener("mouseenter",()=>{Ke&&ie.classList.add("hover")}),ie.addEventListener("mouseleave",()=>{ie.classList.remove("hover")}),ie}function yn(g,A,R){const F=A+1,te=g.name.split(" ")[0];y==null||y({type:te,name:g.name,biomeId:g.id,instanceId:R,slotNumber:F,tileNumber:F}),p==null||p({biomeId:g.id,tileNumber:F,instanceId:R,type:te}),m==null||m(),_==null||_(),wi()}function wi(){var R;document.querySelectorAll(".tile-slot").forEach(F=>{F.classList.remove("selected")});const g=v==null?void 0:v();if(!g)return;const A=document.querySelector(`[data-slot-key="${g.instanceId}"]`);if(A){A.classList.add("selected");try{A.focus({preventScroll:!0})}catch{(R=A.focus)==null||R.call(A)}}}function zi(g){const A=g.target.value;if(!A){j=null;const F=document.getElementById("tile-grid-wrapper");F&&(F.innerHTML='<div class="empty-state">Select a biome above to view tiles</div>');return}const R=t.find(F=>F.id===A);R&&It(R)}function Yt(){const g=document.getElementById("biome-select");if(!g)return;g.dataset.controllerBound||(g.addEventListener("change",zi),g.dataset.controllerBound="true"),g.innerHTML='<option value="">Select a biome to view tiles</option>';const A=Mi();if(!A.length){const Ee=document.getElementById("tile-grid-wrapper");Ee&&(Ee.innerHTML='<div class="empty-state">Select packs or standalone biomes to unlock tile previews.</div>');return}const R=(u==null?void 0:u())||"limited",F=Ee=>{const Me=(Ee||"").toString().toLowerCase();return/grass|grassland/.test(Me)?"":/desert|sand|dune/.test(Me)?"":/alpine|valley/.test(Me)?"":/mountain|plateau|rocky/.test(Me)?"":/arctic|snow|ice|frozen/.test(Me)?"":/ocean|shore|archipelago|island/.test(Me)?"":/marsh|mire|swamp/.test(Me)?"":/wasteland|barren/.test(Me)?"":/volcano|lava/.test(Me)?"":/urban|city|streets|modern/.test(Me)?"":/castle|tavern|ruins/.test(Me)?"":/cavern|cave|dungeon/.test(Me)?"":/shadow|gloom/.test(Me)?"":/battlefield|battle/.test(Me)?"":""},te=Ee=>{if(!Ee)return"";const Me=F(Ee.id);if(Me!=="")return Me;const Oe=F(Ee.biomeParent);return Oe!==""?Oe:F(Ee.name)},he=document.createElement("optgroup");he.label="Available from packs";const ie=document.createElement("optgroup");ie.label="Standalone only",A.forEach(Ee=>{const Me=document.createElement("option");Me.value=Ee.id;const Oe=(c==null?void 0:c(Ee.id))??0,Fe=(d==null?void 0:d(Ee.id))??0,Ue=i.get(Ee.id)||0,Je=e.filter(ze=>{var Ce;return(n.get(ze.id)||0)>0&&((Ce=ze.components)==null?void 0:Ce.some(tt=>tt.setId===Ee.id))});let je="";R==="limited"?Fe>0&&Ue>0?je=` (${Fe} from packs + ${Ue} standalone = ${Oe} total)`:Fe>0?je=` (${Fe} from packs)`:Ue>0&&(je=` (${Ue} standalone)`):je=" (unlimited)";const Ke=`${te(Ee)} `;let we=Ke;if(Fe>0)if(Je.length>0){const ze=Je[0];we=`${F(ze.id||ze.name)}${Je.length>1?`${Je.length} `:" "}`,Me.title=`From packs: ${Je.map(tt=>tt.name).join(", ")}`}else we=Ke;else Ue>0&&(Me.title=`Standalone sets: ${Ue}`);Me.textContent=`${we}${Ee.name}${je}`,Fe>0?he.appendChild(Me):ie.appendChild(Me)}),he.children.length&&g.appendChild(he),ie.children.length&&g.appendChild(ie);const ge=j==null?void 0:j.id;if(ge&&A.some(Ee=>Ee.id===ge))g.value=ge,It(j);else{j=null;const Ee=document.getElementById("tile-grid-wrapper");Ee&&(Ee.innerHTML='<div class="empty-state">Select a biome above to view tiles</div>')}}function Mi(){const g=new Map;return e.forEach(A=>{var F;(n.get(A.id)||0)>0&&((F=A.components)==null||F.forEach(te=>{const he=t.find(ie=>ie.id===te.setId);he&&!g.has(he.id)&&g.set(he.id,he)}))}),i.forEach((A,R)=>{if(A>0&&!g.has(R)){const F=t.find(te=>te.id===R);F&&g.set(F.id,F)}}),Array.from(g.values()).sort((A,R)=>A.name.localeCompare(R.name))}function Si(g){return g?e.some(F=>{var he;return(n.get(F.id)||0)<=0?!1:(he=F.components)==null?void 0:he.some(ie=>ie.setId===g)})?!0:(i.get(g)||0)>0:!1}function Ui(g){const A=(u==null?void 0:u())||"limited",R=(c==null?void 0:c(g.id))??0;for(let F=0;F<50;F++){const te=`${g.id}_${F+1}`,he=A==="limited"?s.get(te)??R:1;if(A==="unlimited"||he>0){yn(g,F,te);return}}}function Jn(g){const A=(c==null?void 0:c(g))??0;let R=0;for(let F=1;F<=50;F++){const te=`${g}_${F}`,he=s.get(te)??A,ie=A-he;R+=Math.max(0,ie)}return R}function Pe(g){return e.some(A=>(n.get(A.id)||0)>0&&A.components.some(F=>F.setId===g))}function On(g,A){if(!g)return!1;const R=(u==null?void 0:u())||"limited",F=A?parseInt(A.split("_").pop(),10)%50:0;for(let he=1;he<=50;he++){const ie=(F+he-1)%50+1,ge=`${g}_${ie}`,Ee=R==="limited"?s.get(ge)??c(g):1/0;if(R==="unlimited"||Ee>0){const Me=t.find(Fe=>Fe.id===g);if(!Me)break;const Oe=Me.name.split(" ")[0];return y==null||y({type:Oe,name:Me.name,biomeId:g,instanceId:ge,slotNumber:ie,tileNumber:ie}),p==null||p({biomeId:g,tileNumber:ie,instanceId:ge,type:Oe}),mt(),_==null||_(),!0}}const te=t.find(he=>he.id===g);return alert(`All available tiles in the ${te?te.name:g} Biome Set are used.`),!1}function Qn(g,A){if(g==="pack"){const R=e.find(F=>F.id===A);return R?R.img_main:N}if(g==="biome"){const R=t.find(F=>F.id===A);return R?R.img_pad1:N}return N}function ln(g){if(!g)return I;if(typeof V=="function"){const A=V(g.id);if(A&&A.gridTexture)return hn.log(` Using grid texture for ${g.id}: ${A.gridTexture}`),A.gridTexture}return hn.warn(` No grid texture found for biome ${g.id}, using placeholder`),I}return{initialize:H,renderEnvironmentPacks:U,renderBiomeSets:ve,refreshBiomeGridUI:mt,refreshCurrentTab:ue,updateTileSelection:Yt,applyPackCount:De,applyStandaloneBiomeSetCount:vt,updatePackCardDisplay:Se,updateBiomeCardDisplay:rt,showBiomeTileGrid:It,advanceToNextAvailableInstance:On,switchToTab:se,getActiveBiomeForGrid:()=>j,getActiveTab:()=>Y,getSearchQuery:()=>q}}const _d={type:"change"},Lo={type:"start"},Ro={type:"end"};class rx extends xi{constructor(e,t){super(),t===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.enabled=!0,this.target=new P,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:Wi.ROTATE,MIDDLE:Wi.DOLLY,RIGHT:Wi.PAN},this.touches={ONE:qi.ROTATE,TWO:qi.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return o.phi},this.getAzimuthalAngle=function(){return o.theta},this.listenToKeyEvents=function(X){X.addEventListener("keydown",ce),this._domElementKeyEvents=X},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(_d),n.update(),s=i.NONE},this.update=function(){const X=new P,U=new Ht().setFromUnitVectors(e.up,new P(0,1,0)),_e=U.clone().invert(),Se=new P,De=new Ht,ve=2*Math.PI;return function(){const it=n.object.position;X.copy(it).sub(n.target),X.applyQuaternion(U),o.setFromVector3(X),n.autoRotate&&s===i.NONE&&I(S()),n.enableDamping?(o.theta+=l.theta*n.dampingFactor,o.phi+=l.phi*n.dampingFactor):(o.theta+=l.theta,o.phi+=l.phi);let rt=n.minAzimuthAngle,vt=n.maxAzimuthAngle;return isFinite(rt)&&isFinite(vt)&&(rt<-Math.PI?rt+=ve:rt>Math.PI&&(rt-=ve),vt<-Math.PI?vt+=ve:vt>Math.PI&&(vt-=ve),rt<=vt?o.theta=Math.max(rt,Math.min(vt,o.theta)):o.theta=o.theta>(rt+vt)/2?Math.max(rt,o.theta):Math.min(vt,o.theta)),o.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,o.phi)),o.makeSafe(),o.radius*=c,o.radius=Math.max(n.minDistance,Math.min(n.maxDistance,o.radius)),n.enableDamping===!0?n.target.addScaledVector(d,n.dampingFactor):n.target.add(d),X.setFromSpherical(o),X.applyQuaternion(_e),it.copy(n.target).add(X),n.object.lookAt(n.target),n.enableDamping===!0?(l.theta*=1-n.dampingFactor,l.phi*=1-n.dampingFactor,d.multiplyScalar(1-n.dampingFactor)):(l.set(0,0,0),d.set(0,0,0)),c=1,u||Se.distanceToSquared(n.object.position)>a||8*(1-De.dot(n.object.quaternion))>a?(n.dispatchEvent(_d),Se.copy(n.object.position),De.copy(n.object.quaternion),u=!1,!0):!1}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",qe),n.domElement.removeEventListener("pointerdown",ue),n.domElement.removeEventListener("wheel",L),n.domElement.removeEventListener("touchstart",oe),n.domElement.removeEventListener("touchend",Be),n.domElement.removeEventListener("touchmove",Te),n.domElement.ownerDocument.removeEventListener("pointermove",le),n.domElement.ownerDocument.removeEventListener("pointerup",ae),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",ce)};const n=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=i.NONE;const a=1e-6,o=new _s,l=new _s;let c=1;const d=new P;let u=!1;const h=new Ae,m=new Ae,_=new Ae,v=new Ae,y=new Ae,p=new Ae,f=new Ae,b=new Ae,M=new Ae;function S(){return 2*Math.PI/60/60*n.autoRotateSpeed}function x(){return Math.pow(.95,n.zoomSpeed)}function I(X){l.theta-=X}function V(X){l.phi-=X}const Y=function(){const X=new P;return function(_e,Se){X.setFromMatrixColumn(Se,0),X.multiplyScalar(-_e),d.add(X)}}(),j=function(){const X=new P;return function(_e,Se){n.screenSpacePanning===!0?X.setFromMatrixColumn(Se,1):(X.setFromMatrixColumn(Se,0),X.crossVectors(n.object.up,X)),X.multiplyScalar(_e),d.add(X)}}(),G=function(){const X=new P;return function(_e,Se){const De=n.domElement;if(n.object.isPerspectiveCamera){const ve=n.object.position;X.copy(ve).sub(n.target);let We=X.length();We*=Math.tan(n.object.fov/2*Math.PI/180),Y(2*_e*We/De.clientHeight,n.object.matrix),j(2*Se*We/De.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(Y(_e*(n.object.right-n.object.left)/n.object.zoom/De.clientWidth,n.object.matrix),j(Se*(n.object.top-n.object.bottom)/n.object.zoom/De.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function q(X){n.object.isPerspectiveCamera?c/=X:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*X)),n.object.updateProjectionMatrix(),u=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function C(X){n.object.isPerspectiveCamera?c*=X:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/X)),n.object.updateProjectionMatrix(),u=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function W(X){h.set(X.clientX,X.clientY)}function z(X){f.set(X.clientX,X.clientY)}function E(X){v.set(X.clientX,X.clientY)}function N(X){m.set(X.clientX,X.clientY),_.subVectors(m,h).multiplyScalar(n.rotateSpeed);const U=n.domElement;I(2*Math.PI*_.x/U.clientHeight),V(2*Math.PI*_.y/U.clientHeight),h.copy(m),n.update()}function K(X){b.set(X.clientX,X.clientY),M.subVectors(b,f),M.y>0?q(x()):M.y<0&&C(x()),f.copy(b),n.update()}function J(X){y.set(X.clientX,X.clientY),p.subVectors(y,v).multiplyScalar(n.panSpeed),G(p.x,p.y),v.copy(y),n.update()}function T(X){X.deltaY<0?C(x()):X.deltaY>0&&q(x()),n.update()}function O(X){let U=!1;switch(X.code){case n.keys.UP:G(0,n.keyPanSpeed),U=!0;break;case n.keys.BOTTOM:G(0,-n.keyPanSpeed),U=!0;break;case n.keys.LEFT:G(n.keyPanSpeed,0),U=!0;break;case n.keys.RIGHT:G(-n.keyPanSpeed,0),U=!0;break}U&&(X.preventDefault(),n.update())}function H(X){if(X.touches.length==1)h.set(X.touches[0].pageX,X.touches[0].pageY);else{const U=.5*(X.touches[0].pageX+X.touches[1].pageX),_e=.5*(X.touches[0].pageY+X.touches[1].pageY);h.set(U,_e)}}function ee(X){if(X.touches.length==1)v.set(X.touches[0].pageX,X.touches[0].pageY);else{const U=.5*(X.touches[0].pageX+X.touches[1].pageX),_e=.5*(X.touches[0].pageY+X.touches[1].pageY);v.set(U,_e)}}function B(X){const U=X.touches[0].pageX-X.touches[1].pageX,_e=X.touches[0].pageY-X.touches[1].pageY,Se=Math.sqrt(U*U+_e*_e);f.set(0,Se)}function ne(X){n.enableZoom&&B(X),n.enablePan&&ee(X)}function Q(X){n.enableZoom&&B(X),n.enableRotate&&H(X)}function se(X){if(X.touches.length==1)m.set(X.touches[0].pageX,X.touches[0].pageY);else{const _e=.5*(X.touches[0].pageX+X.touches[1].pageX),Se=.5*(X.touches[0].pageY+X.touches[1].pageY);m.set(_e,Se)}_.subVectors(m,h).multiplyScalar(n.rotateSpeed);const U=n.domElement;I(2*Math.PI*_.x/U.clientHeight),V(2*Math.PI*_.y/U.clientHeight),h.copy(m)}function re(X){if(X.touches.length==1)y.set(X.touches[0].pageX,X.touches[0].pageY);else{const U=.5*(X.touches[0].pageX+X.touches[1].pageX),_e=.5*(X.touches[0].pageY+X.touches[1].pageY);y.set(U,_e)}p.subVectors(y,v).multiplyScalar(n.panSpeed),G(p.x,p.y),v.copy(y)}function be(X){const U=X.touches[0].pageX-X.touches[1].pageX,_e=X.touches[0].pageY-X.touches[1].pageY,Se=Math.sqrt(U*U+_e*_e);b.set(0,Se),M.set(0,Math.pow(b.y/f.y,n.zoomSpeed)),q(M.y),f.copy(b)}function me(X){n.enableZoom&&be(X),n.enablePan&&re(X)}function Ne(X){n.enableZoom&&be(X),n.enableRotate&&se(X)}function ue(X){if(n.enabled!==!1)switch(X.pointerType){case"mouse":case"pen":Le(X);break}}function le(X){if(n.enabled!==!1)switch(X.pointerType){case"mouse":case"pen":de(X);break}}function ae(X){switch(X.pointerType){case"mouse":case"pen":D();break}}function Le(X){X.preventDefault(),n.domElement.focus?n.domElement.focus():window.focus();let U;switch(X.button){case 0:U=n.mouseButtons.LEFT;break;case 1:U=n.mouseButtons.MIDDLE;break;case 2:U=n.mouseButtons.RIGHT;break;default:U=-1}switch(U){case Wi.DOLLY:if(n.enableZoom===!1)return;z(X),s=i.DOLLY;break;case Wi.ROTATE:if(X.ctrlKey||X.metaKey||X.shiftKey){if(n.enablePan===!1)return;E(X),s=i.PAN}else{if(n.enableRotate===!1)return;W(X),s=i.ROTATE}break;case Wi.PAN:if(X.ctrlKey||X.metaKey||X.shiftKey){if(n.enableRotate===!1)return;W(X),s=i.ROTATE}else{if(n.enablePan===!1)return;E(X),s=i.PAN}break;default:s=i.NONE}s!==i.NONE&&(n.domElement.ownerDocument.addEventListener("pointermove",le),n.domElement.ownerDocument.addEventListener("pointerup",ae),n.dispatchEvent(Lo))}function de(X){if(n.enabled!==!1)switch(X.preventDefault(),s){case i.ROTATE:if(n.enableRotate===!1)return;N(X);break;case i.DOLLY:if(n.enableZoom===!1)return;K(X);break;case i.PAN:if(n.enablePan===!1)return;J(X);break}}function D(X){n.domElement.ownerDocument.removeEventListener("pointermove",le),n.domElement.ownerDocument.removeEventListener("pointerup",ae),n.enabled!==!1&&(n.dispatchEvent(Ro),s=i.NONE)}function L(X){n.enabled===!1||n.enableZoom===!1||s!==i.NONE&&s!==i.ROTATE||(X.preventDefault(),n.dispatchEvent(Lo),T(X),n.dispatchEvent(Ro))}function ce(X){n.enabled===!1||n.enablePan===!1||O(X)}function oe(X){if(n.enabled!==!1){switch(X.preventDefault(),X.touches.length){case 1:switch(n.touches.ONE){case qi.ROTATE:if(n.enableRotate===!1)return;H(X),s=i.TOUCH_ROTATE;break;case qi.PAN:if(n.enablePan===!1)return;ee(X),s=i.TOUCH_PAN;break;default:s=i.NONE}break;case 2:switch(n.touches.TWO){case qi.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;ne(X),s=i.TOUCH_DOLLY_PAN;break;case qi.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;Q(X),s=i.TOUCH_DOLLY_ROTATE;break;default:s=i.NONE}break;default:s=i.NONE}s!==i.NONE&&n.dispatchEvent(Lo)}}function Te(X){if(n.enabled!==!1)switch(X.preventDefault(),s){case i.TOUCH_ROTATE:if(n.enableRotate===!1)return;se(X),n.update();break;case i.TOUCH_PAN:if(n.enablePan===!1)return;re(X),n.update();break;case i.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;me(X),n.update();break;case i.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;Ne(X),n.update();break;default:s=i.NONE}}function Be(X){n.enabled!==!1&&(n.dispatchEvent(Ro),s=i.NONE)}function qe(X){n.enabled!==!1&&X.preventDefault()}n.domElement.addEventListener("contextmenu",qe),n.domElement.addEventListener("pointerdown",ue),n.domElement.addEventListener("wheel",L,{passive:!1}),n.domElement.addEventListener("touchstart",oe,{passive:!1}),n.domElement.addEventListener("touchend",Be),n.domElement.addEventListener("touchmove",Te,{passive:!1}),this.update()}}function ax({container:r,backgroundColor:e=5660781,antialias:t=!0}={}){if(!r)throw new Error("createScene: container element is required");const n=new ba;n.background=new ke(e);const i=r.clientWidth||1,s=r.clientHeight||1,a=new $t(60,i/s,.1,1e3),o=new yt({antialias:t});o.setSize(i,s),r.appendChild(o.domElement),o.outputEncoding=jn,o.shadowMap.enabled=!1,o.shadowMap.type=Dd;const l=new rx(a,o.domElement);return l.enableDamping=!0,{scene:n,camera:a,renderer:o,controls:l,resizeRenderer:()=>{const u=r.clientWidth||1,h=r.clientHeight||1;a.aspect=u/h,a.updateProjectionMatrix(),o.setSize(u,h)},getMaxAnisotropy:()=>o.capabilities&&typeof o.capabilities.getMaxAnisotropy=="function"?o.capabilities.getMaxAnisotropy():1}}const ox="rgba(56, 171, 25, 0.14)",lx="rgba(116, 201, 87, 0.12)";function cx(r){if(typeof r!="string")return null;const e=r.trim();if(!e)return null;const t=e.match(/^#([0-9a-f]{3,8})$/i);if(t){let i=t[1];if((i.length===3||i.length===4)&&(i=i.split("").map(s=>s+s).join("")),i.length===6||i.length===8)return{r:parseInt(i.substring(0,2),16),g:parseInt(i.substring(2,4),16),b:parseInt(i.substring(4,6),16)}}const n=e.match(/^rgba?\(([^)]+)\)$/i);if(n){const i=n[1].split(",").map(s=>Number.parseFloat(s.trim())).filter(s=>Number.isFinite(s));if(i.length>=3)return{r:Math.round(i[0]),g:Math.round(i[1]),b:Math.round(i[2])}}return null}function Ms(r){return Math.max(0,Math.min(255,Math.round(r)))}function dx(r,e){if(!r)return null;const t=Math.max(0,Math.min(1,e));return{r:Ms(r.r+(255-r.r)*t),g:Ms(r.g+(255-r.g)*t),b:Ms(r.b+(255-r.b)*t)}}function vd(r,e,t){return r?`rgba(${Ms(r.r)}, ${Ms(r.g)}, ${Ms(r.b)}, ${e})`:t}function ux({instructionsLog:r,biomeSets:e,placedTiles:t}){async function n(y){const p=v(),f=p.container,b=document.createElement("div");b.className="instr-header";const M=document.createElement("div");M.className="instr-title-row",M.innerHTML=`
      <h2 class="instr-title"><i class="fas fa-map"></i> Map Build Instructions</h2>
      <div class="instr-header-actions">
        <button class="btn-icon" id="instr-close" title="Close instructions (ESC)" aria-label="Close instructions">
          <i class="fas fa-times"></i>
        </button>
      </div>
    `;const S=document.createElement("div");S.className="instr-stats",S.innerHTML=`
      <div class="instr-stat-item">
        <i class="fas fa-border-all"></i>
        <span class="label">Map Size:</span>
        <span class="value">${y.mapWidth}${y.mapHeight}</span>
      </div>
      <div class="instr-stat-separator"></div>
      <div class="instr-stat-item">
        <i class="fas fa-layer-group"></i>
        <span class="label">Layers:</span>
        <span class="value">${y.layers.length}</span>
      </div>
      <div class="instr-stat-separator"></div>
      <div class="instr-stat-item">
        <i class="fas fa-puzzle-piece"></i>
        <span class="label">Total Tiles:</span>
        <span class="value">${t.size}</span>
      </div>
    `,b.appendChild(M),b.appendChild(S),f.appendChild(b);const x={simple:!0,showAxes:!0,showTextures:!0,showLabels:!1},I=[],V=H=>{typeof H=="function"&&I.push(H)},Y=()=>I.forEach(H=>H()),j=document.createElement("div");j.className="instr-toolbar sticky";const G=()=>{requestAnimationFrame(()=>{try{const H=f.querySelectorAll(".axis-frame");let ee=0;if(H.forEach(B=>{ee=Math.max(ee,B.offsetWidth||0)}),ee>0){const ne=window.innerWidth*.9,Q=Math.min(ne,ee+48),se=parseFloat(f.style.width)||0,re=Math.min(ne,Math.max(se,Q));f.style.width=re+"px"}}catch(H){r.warn("Failed to adjust modal width",H)}})},q=({label:H,key:ee,hint:B,icon:ne})=>{const Q=document.createElement("label");Q.className="view-toggle",B&&(Q.title=B);const se=document.createElement("input");se.type="checkbox",se.className="view-toggle-input",se.checked=!!x[ee],se.setAttribute("aria-label",H);const re=document.createElement("span");re.className="view-toggle-switch";const be=document.createElement("i");be.className=`view-toggle-icon ${ne}`;const me=document.createElement("span");me.className="view-toggle-label",me.textContent=H;const Ne=()=>{Q.classList.toggle("is-active",se.checked)};return Ne(),se.addEventListener("change",()=>{x[ee]=se.checked,Ne(),Y(),G()}),Q.append(se,be,me,re),Q},C=document.createElement("div");C.className="instr-toolbar-section view-options";const W=document.createElement("div");W.className="section-title",W.innerHTML='<i class="fas fa-eye"></i> View Options';const z=document.createElement("div");z.className="view-toggles";const E=[{key:"simple",label:"Simple view",icon:"fas fa-eye-slash",hint:"Reduce shading overlays for a clean, flat layout."},{key:"showAxes",label:"Show axes",icon:"fas fa-arrows-alt",hint:"Display Q/R axis guides around the map."},{key:"showTextures",label:"Show textures",icon:"fas fa-image",hint:"Render tile textures instead of solid fills."},{key:"showLabels",label:"Show labels",icon:"fas fa-tags",hint:"Display tile identifiers on the layer."}].map(q);z.append(...E),C.appendChild(W),C.appendChild(z);const N=document.createElement("div");N.className="instr-toolbar-section export-actions";const K=document.createElement("div");K.className="section-title",K.innerHTML='<i class="fas fa-download"></i> Export';const J=document.createElement("div");J.className="export-buttons",J.innerHTML=`
      <button class="btn btn-primary btn-compact" onclick="printInstructions()" title="Print or save as PDF (Ctrl+P)">
        <i class="fas fa-print"></i>
        <span>Print / PDF</span>
      </button>
      <button class="btn btn-secondary btn-compact" onclick="downloadAllLayerImages()" title="Download all layer images as PNG (Ctrl+S)">
        <i class="fas fa-images"></i>
        <span>Save All PNG</span>
      </button>
    `,N.appendChild(K),N.appendChild(J),j.appendChild(C),j.appendChild(N),f.appendChild(j);const T=document.createElement("div");T.className="instr-layers-container";for(let H=0;H<y.layers.length;H++){const ee=y.layers[H],B=y.layerData.get(ee);r.log(` Rendering layer ${ee} with ${B.length} tiles...`);const ne=await i(ee,B,y,H+1,x,V);T.appendChild(ne)}f.appendChild(T),requestAnimationFrame(()=>{try{const H=f.querySelectorAll(".axis-frame");let ee=0;if(H.forEach(B=>{ee=Math.max(ee,B.offsetWidth||0)}),ee>0){const ne=window.innerWidth*.9,Q=Math.min(ne,ee+48),se=parseFloat(f.style.width)||0,re=Math.min(ne,Math.max(se,Q));f.style.width=re+"px"}}catch(H){r.warn("Instructions modal resize failed",H)}}),p.overlay.addEventListener("keydown",H=>{var ee;if(H.key==="Escape")document.body.removeChild(p.overlay);else if(H.ctrlKey&&H.key==="p")H.preventDefault(),window.print();else if(H.ctrlKey&&H.key==="s")H.preventDefault(),(ee=window.downloadAllLayerImages)==null||ee.call(window);else if(H.ctrlKey&&H.key==="e"){H.preventDefault();const B=f.querySelectorAll("details"),ne=Array.from(B).some(Q=>Q.open);B.forEach(Q=>{Q.open=!ne})}});const O=b.querySelector("#instr-close");O==null||O.addEventListener("click",()=>{window.closeInstructions&&window.closeInstructions()}),r.log(" Build instructions generated!")}async function i(y,p,f,b,M,S){const x=document.createElement("div");x.className="instr-layer",x.dataset.layerNumber=String(b);const I=document.createElement("div");I.className="instr-layer-header";const V=document.createElement("div");V.className="layer-title-group",V.innerHTML=`
      <h3 class="layer-title">
        <i class="fas fa-layer-group"></i>
        <span class="layer-name">Layer ${b}</span>
        <span class="layer-level">${y===0?"(Ground Level)":`(+${y})`}</span>
      </h3>
      <div class="layer-info">
        <span class="tile-count"><i class="fas fa-puzzle-piece"></i> ${p.length} tiles</span>
      </div>
    `;const Y=document.createElement("div");Y.className="layer-actions",Y.innerHTML=`
      <button type="button" class="btn btn-icon layer-save" data-layer="${b}" title="Save this layer as PNG">
        <i class="fas fa-download"></i>
      </button>
    `,I.appendChild(V),I.appendChild(Y),x.appendChild(I);const j=document.createElement("div");j.className="instr-canvas-wrap";const G=document.createElement("canvas");G.className="layer-canvas";const q=30,C=q*2,W=q*Math.sqrt(3),z=q*.25,E=2;let N=1/0,K=-1/0,J=1/0,T=-1/0;f.layerData.forEach(le=>{le.forEach(ae=>{const Le=q*(1.5*ae.q),de=q*(Math.sqrt(3)/2*ae.q+Math.sqrt(3)*ae.r);N=Math.min(N,Le),K=Math.max(K,Le),J=Math.min(J,de),T=Math.max(T,de)})});const O=E*q*1.5,H=E*W,ee=K-N+C+O*2+z*2,B=T-J+W+H*2+z*2;G.width=Math.ceil(ee),G.height=Math.ceil(B),G.style.maxWidth="100%",G.style.height="auto";try{const ae=(getComputedStyle(document.body).getPropertyValue("--border-color")||"#333").trim()||"#333";G.style.border=`2px solid ${ae}`,G.style.backgroundColor="#f8f8f8"}catch{G.style.border="2px solid #333",G.style.backgroundColor="#f8f8f8"}r.log(`Canvas dimensions: ${G.width}x${G.height} for GLOBAL bounds Q:${f.bounds.minQ}-${f.bounds.maxQ}, R:${f.bounds.minR}-${f.bounds.maxR} (Layer ${y}: ${p.length} tiles)`),r.log(` Using GLOBAL positioning: minPixelX=${N.toFixed(1)}, minPixelY=${J.toFixed(1)} - ALL LAYERS CENTERED TO SAME POINT`);const ne=G.getContext("2d");j.style.width=`${G.width}px`,j.style.height=`${G.height}px`,j.appendChild(G);const Q=document.createElement("div");Q.className="axis-frame";const se=document.createElement("div");se.className="axis-left";const re=document.createElement("div");re.className="axis-bottom",Q.appendChild(se),Q.appendChild(j),Q.appendChild(re),x.appendChild(Q);const be=I.querySelector(".layer-save");be==null||be.addEventListener("click",async le=>{le.preventDefault();try{const ae=document.getElementById("map-name-input-toolbar"),de=`${((ae==null?void 0:ae.value)||"map").trim().replace(/[^a-z0-9-_]+/gi,"_").toLowerCase()||"map"}_layer-${b}.png`;if(G.toBlob)G.toBlob(D=>{const L=URL.createObjectURL(D),ce=document.createElement("a");ce.href=L,ce.download=de,document.body.appendChild(ce),ce.click(),ce.remove(),URL.revokeObjectURL(L)},"image/png");else{const D=G.toDataURL("image/png"),L=document.createElement("a");L.href=D,L.download=de,document.body.appendChild(L),L.click(),L.remove()}}catch(ae){console.error("Failed to save layer image:",ae),alert("Could not save the image.")}});const me=()=>{const le=x.closest(".instructions-container");le&&requestAnimationFrame(()=>{const ae=le.querySelectorAll(".axis-frame");let Le=0;if(ae.forEach(de=>{Le=Math.max(Le,de.offsetWidth||0)}),Le>0){const D=window.innerWidth*.9,L=Math.min(D,Le+48),ce=parseFloat(le.style.width)||0,oe=Math.min(D,Math.max(ce,L));le.style.width=oe+"px"}})};async function Ne(){if(ne.clearRect(0,0,G.width,G.height),ne.__drawBands=!M.simple,ne.__showRef=!1,ne.__showLabels=!!M.showLabels,await o(ne,f,q,z),y!==0&&await l(ne,f,y,q,z),M.showTextures?await c(ne,p,f,q,z):await d(ne,p,f,q,z),se.innerHTML="",re.innerHTML="",M.showAxes){const le=f.bounds||s(p),ae=document.createElement("div");ae.className="axis-label r",ae.textContent=`R:${le.minR}`;const Le=document.createElement("div");Le.className="axis-label r",Le.textContent=`R:${le.maxR}`,se.append(ae,Le);const de=document.createElement("div");de.className="axis-label q",de.textContent=`Q:${le.minQ}`;const D=document.createElement("div");D.className="axis-label q",D.textContent=`Q:${le.maxQ}`,re.append(de,D),a(ne,f,q,z)}me()}await Ne(),S&&S(Ne);const ue=_(p,y);return x.appendChild(ue),x}function s(y){if(!Array.isArray(y)||y.length===0)return{minQ:0,maxQ:0,minR:0,maxR:0};let p=Number.POSITIVE_INFINITY,f=Number.NEGATIVE_INFINITY,b=Number.POSITIVE_INFINITY,M=Number.NEGATIVE_INFINITY;return y.forEach(S=>{if(!S)return;const{q:x=0,r:I=0}=S;p=Math.min(p,x),f=Math.max(f,x),b=Math.min(b,I),M=Math.max(M,I)}),{minQ:p,maxQ:f,minR:b,maxR:M}}function a(y,p,f,b){const M=y.canvas.width,S=y.canvas.height,x=Math.max(12,Math.min(28,b+10)),I=Math.max(x,14),V=S-Math.max(x+2,20),Y=Math.cos(Math.PI/6),j=Math.sin(Math.PI/6),G=Math.max(26,Math.min(44,Math.min(M,S)*.085)),q=M-x-I,C=V-x,W=S-x-V,z=Math.min(q/Y,C/j),E=Math.min(q/Y,W/j),N=6,K=Math.max(18,Math.min(G,z-N)),J=Math.max(18,Math.min(G,E-N)),T={x:Y*K,y:-j*K},O={x:Y*J,y:j*J},H=(ee,B,ne,Q,se,re)=>{y.save(),y.strokeStyle=se,y.fillStyle=se,y.lineWidth=2,y.beginPath(),y.moveTo(Math.round(ee)+.5,Math.round(B)+.5),y.lineTo(Math.round(ne)+.5,Math.round(Q)+.5),y.stroke();const be=Math.atan2(Q-B,ne-ee),me=4.5;y.beginPath(),y.moveTo(ne,Q),y.lineTo(ne-me*Math.cos(be-Math.PI/6),Q-me*Math.sin(be-Math.PI/6)),y.lineTo(ne-me*Math.cos(be+Math.PI/6),Q-me*Math.sin(be+Math.PI/6)),y.closePath(),y.fill(),y.font="bold 9px Arial",y.textAlign="left",y.textBaseline="middle",y.fillText(re,ne+3,Q),y.restore()};H(I,V,I+T.x,V+T.y,"#38AB19","Q+"),H(I,V,I+O.x,V+O.y,"#272727","R+")}async function o(y,p,f,b){r.log(" drawHexagonalGrid called - START");let M=1/0,S=1/0;p.layerData.forEach(Q=>{Q.forEach(se=>{const re=f*(1.5*se.q),be=f*(Math.sqrt(3)/2*se.q+Math.sqrt(3)*se.r);M=Math.min(M,re),S=Math.min(S,be)})}),r.log(` GRID: Using GLOBAL positioning: minPixelX=${M.toFixed(1)}, minPixelY=${S.toFixed(1)} - ALL LAYERS CENTERED TO SAME POINT`);let x=1/0,I=-1/0,V=1/0,Y=-1/0;p.layerData.forEach(Q=>{Q.forEach(se=>{x=Math.min(x,se.q),I=Math.max(I,se.q),V=Math.min(V,se.r),Y=Math.max(Y,se.r)})}),r.log(` Content hex bounds: Q(${x} to ${I}), R(${V} to ${Y})`);const j=4,G=Math.max(Math.abs(x),Math.abs(I))+j,q=Math.max(Math.abs(V),Math.abs(Y))+j;r.log(` Grid with buffer: q range ${G}, r range ${q} (buffer: ${j} hexes)`);function C(Q,se,re,be,me="#ddd",Ne=1){se=Math.round(se)+.5,re=Math.round(re)+.5,Q.beginPath();for(let ue=0;ue<6;ue++){const le=Math.PI/3*ue,ae=se+be*Math.cos(le),Le=re+be*Math.sin(le);ue===0?Q.moveTo(Math.round(ae)+.5,Math.round(Le)+.5):Q.lineTo(Math.round(ae)+.5,Math.round(Le)+.5)}Q.closePath(),Q.strokeStyle=me,Q.lineWidth=Ne,Q.stroke()}const z=getComputedStyle(document.documentElement).getPropertyValue("--primary-color")||"#38ab19",E=cx(z)||{r:56,g:171,b:25},N=dx(E,.35)||E,K=vd(E,.18,ox),J=vd(N,.16,lx),T=f*.98,O=2,H=O*f*1.5,ee=O*f*Math.sqrt(3);let B=0;const ne=new Set;for(let Q=-G;Q<=G;Q++)for(let se=-q;se<=q;se++){if(Math.abs(Q+se)>Math.max(G,q))continue;const re=f*(3/2*Q),be=f*(Math.sqrt(3)/2*Q+Math.sqrt(3)*se),me=re-M+H+b,Ne=be-S+ee+b,ue=me+f,le=Ne+f;if(ue>-f&&ue<y.canvas.width+f&&le>-f&&le<y.canvas.height+f){const ae=`${Math.round(ue)},${Math.round(le)}`;if(ne.has(ae)?console.warn(` DUPLICATE hex position detected: ${ae} (q:${Q}, r:${se})`):ne.add(ae),y.__drawBands&&Math.abs(Q)%2===0){y.fillStyle=K,y.beginPath();for(let Le=0;Le<6;Le++){const de=Math.PI/3*Le,D=ue+T*Math.cos(de),L=le+T*Math.sin(de);Le===0?y.moveTo(D,L):y.lineTo(D,L)}y.closePath(),y.fill()}if(y.__drawBands&&Math.abs(se)%2===0){y.fillStyle=J,y.beginPath();for(let Le=0;Le<6;Le++){const de=Math.PI/3*Le,D=ue+T*Math.cos(de),L=le+T*Math.sin(de);Le===0?y.moveTo(D,L):y.lineTo(D,L)}y.closePath(),y.fill()}C(y,ue,le,T,"#ddd",.8),B++,y.__showRef&&Q%5===0&&se%5===0&&(y.fillStyle="#999",y.font="10px Arial",y.textAlign="center",y.fillText(`${Q},${se}`,ue,le+3))}}r.log(`Grid drawing completed - drew ${B} hexagons, unique positions: ${ne.size}`)}async function l(y,p,f,b,M){if(r.log(` Drawing shadows from layers below ${f}`),f===0){r.log(" Ground level - no shadows to draw");return}let S=1/0,x=1/0;p.layerData.forEach(G=>{G.forEach(q=>{const C=b*(1.5*q.q),W=b*(Math.sqrt(3)/2*q.q+Math.sqrt(3)*q.r);S=Math.min(S,C),x=Math.min(x,W)})});const I=2,V=I*b*1.5,Y=I*b*Math.sqrt(3);let j=0;for(let G=0;G<f;G++){const q=p.layerData.get(G);if(!q||q.length===0)continue;const C=f-G,W=Math.max(.1,.4/C);r.log(` Drawing ${q.length} shadows from layer ${G} with opacity ${W.toFixed(2)}`);for(const z of q){const E=b*(1.5*z.q),N=b*(Math.sqrt(3)/2*z.q+Math.sqrt(3)*z.r),K=E-S+V+M,J=N-x+Y+M,T=K+b,O=J+b;y.save(),y.globalAlpha=W,y.beginPath();for(let H=0;H<6;H++){const ee=Math.PI/3*H,B=T+b*.9*Math.cos(ee),ne=O+b*.9*Math.sin(ee);H===0?y.moveTo(B,ne):y.lineTo(B,ne)}y.closePath(),y.fillStyle="#E6E6E6",y.fill(),y.strokeStyle="#9a9a9a",y.lineWidth=1.25,y.setLineDash([3,3]),y.stroke(),y.setLineDash([]),y.fillStyle="#5b5b5b",y.font="bold 9px Arial",y.textAlign="center",y.shadowColor="rgba(255,255,255,0.8)",y.shadowBlur=1;try{let H=1;if(Array.isArray(p.layers)){const ee=p.layers.indexOf(G);H=ee>=0?ee+1:G+1}else H=G+1;y.fillText(`L${H}`,T,O+3)}catch{y.fillText(`L${G+1}`,T,O+3)}y.shadowBlur=0,y.restore(),j++}}r.log(` Drew ${j} shadow hexagons from lower layers`)}async function c(y,p,f,b,M){const S=b*Math.sqrt(3);r.log(`Drawing ${p.length} tiles in hexagonal layout`);let x=1/0,I=1/0;f.layerData.forEach(G=>{G.forEach(q=>{const C=b*(1.5*q.q),W=b*(Math.sqrt(3)/2*q.q+Math.sqrt(3)*q.r);x=Math.min(x,C),I=Math.min(I,W)})}),r.log(` TILES: Using GLOBAL positioning: minPixelX=${x.toFixed(1)}, minPixelY=${I.toFixed(1)} - ALL LAYERS CENTERED TO SAME POINT`);const V=new Map;async function Y(G,q){const C=`${G}_${q}`;if(V.has(C))return V.get(C);const W=h(G);if(!W)return r.log(`No grid texture config found for biome: ${G}`),null;const z=await m(W.gridTexture,q,W);return z?(V.set(C,z),r.log(` Extracted texture for ${G} tile ${q}`)):r.log(` Failed to extract texture for ${G} tile ${q}`),z}function j(G,q,C,W,z=null,E="#333"){G.beginPath();for(let N=0;N<6;N++){const K=Math.PI/3*N,J=q+W*Math.cos(K),T=C+W*Math.sin(K);N===0?G.moveTo(J,T):G.lineTo(J,T)}G.closePath(),z&&(G.fillStyle=z,G.fill()),z&&E&&(G.strokeStyle=E,G.lineWidth=1,G.stroke())}for(const G of p)try{if(!G.q&&G.q!==0||!G.r&&G.r!==0){console.error(" ERROR: Invalid tile coordinates:",G);continue}const q=G.biomeId;if(!q){console.error(" ERROR: No biomeId found in tile:",G);continue}const C=b*(3/2*G.q),W=b*(Math.sqrt(3)/2*G.q+Math.sqrt(3)*G.r),z=2,E=z*b*1.5,N=z*S,K=C-x+E+M,J=W-I+N+M,T=K+b,O=J+b,H=await Y(q,G.tileNumber);if(H){y.save(),y.beginPath();for(let se=0;se<6;se++){const re=Math.PI/3*se,be=T+b*Math.cos(re),me=O+b*Math.sin(re);se===0?y.moveTo(be,me):y.lineTo(be,me)}y.closePath(),y.clip(),y.translate(T,O);const ee=Math.PI/3,B=G.rotationDegrees?G.rotationDegrees*Math.PI/180:0,ne=ee+B;y.rotate(ne),y.translate(-T,-O);const Q=b*1.8;y.drawImage(H,T-Q/2,O-Q/2,Q,Q),y.restore(),j(y,T,O,b,null,"#333")}else{const ee=u(q);j(y,T,O,b,ee,"#333")}if(y.__showLabels){y.fillStyle="#000",y.font="600 9px Arial",y.textAlign="center",y.textBaseline="middle";const ee=q?q.split("_")[0].toUpperCase():"UNK",B=G.tileNumber||"?",ne=G.rotationDegrees&&G.rotationDegrees!==0?` (${G.rotationDegrees})`:"",Q=`${ee}-${B}${ne}`,re=y.measureText(Q).width,be=12;y.fillStyle="rgba(255, 255, 255, 0.7)",y.fillRect(T-re/2-2,O-be/2-1,re+4,be+2),y.fillStyle="#000",y.fillText(Q,T,O)}}catch(q){console.error("Error drawing tile:",G,q)}}async function d(y,p,f,b,M){var q;const S=b*Math.sqrt(3);let x=1/0,I=1/0;f.layerData.forEach(C=>{C.forEach(W=>{const z=b*(1.5*W.q),E=b*(Math.sqrt(3)/2*W.q+Math.sqrt(3)*W.r);x=Math.min(x,z),I=Math.min(I,E)})});const V=2,Y=V*b*1.5,j=V*S,G=(C,W,z,E,N)=>{y.beginPath();for(let K=0;K<6;K++){const J=Math.PI/3*K,T=C+z*Math.cos(J),O=W+z*Math.sin(J);K===0?y.moveTo(T,O):y.lineTo(T,O)}y.closePath(),y.fillStyle=E,y.fill(),y.strokeStyle=N,y.lineWidth=1,y.stroke()};for(const C of p){const W=b*(1.5*C.q),z=b*(Math.sqrt(3)/2*C.q+Math.sqrt(3)*C.r),E=W-x+Y+M,N=z-I+j+M,K=E+b,J=N+b,T=u(C.biomeId);if(G(K,J,b,T,"#333"),y.__showLabels){const O=((q=(C.biomeId||"").split("_")[0])==null?void 0:q.toUpperCase())||"UNK",H=C.tileNumber||"?";y.fillStyle="#000",y.font="600 9px Arial",y.textAlign="center",y.textBaseline="middle",y.fillText(`${O}-${H}`,K,J)}}}function u(y){if(!y||typeof y!="string")return console.warn(" getBiomeColor: Invalid biomeId:",y),"#999999";const p={gs:"#4CAF50",ar:"#87CEEB",ds:"#DEB887",bl:"#8B4513",cb:"#708090",cv:"#696969",dg:"#2F4F4F",bk:"#8B7355"},f=y.split("_")[0];return p[f]||"#999999"}function h(y){return{gs_grass:{gridTexture:"textures/grid-Grassland---plain-grass.png",gridSize:{cols:5,rows:10}},gs_tracks_streams:{gridTexture:"textures/grid-Grassland---Tracks-and-Streams.png",gridSize:{cols:5,rows:10}},gs_forest_flora:{gridTexture:"textures/grid-Grassland-Forest-and-Flora.png",gridSize:{cols:5,rows:10}},bl_earth:{gridTexture:"textures/grid-Barrenland-set---dirt.png",gridSize:{cols:5,rows:10}},bl_tracks_streams:{gridTexture:"textures/grid-Barrenland-tracks-and-streams.png",gridSize:{cols:5,rows:10}},bl_wasteland_forest:{gridTexture:"textures/grid-Barrenland-Forest-and-Rocks.png",gridSize:{cols:5,rows:10}},mt_stone:{gridTexture:"textures/grid-Mountains---Stone.png",gridSize:{cols:5,rows:10}},mt_streams_forest:{gridTexture:"textures/grid-Mountains---Streams-and-Forests.png",gridSize:{cols:5,rows:10}},oc_water:{gridTexture:"textures/grid-Oceanic---Water.png",gridSize:{cols:5,rows:10}},oc_coastal:{gridTexture:"textures/grid-Oceanic---Coastal.png",gridSize:{cols:5,rows:10}},oc_tropical_island:{gridTexture:"textures/grid-Oceanic---Tropical-Island-and-Shallows.png",gridSize:{cols:5,rows:10}},ds_sand:{gridTexture:"textures/grid-Desert-set---Sand.png",gridSize:{cols:5,rows:10}},ds_tracks_ridgelines:{gridTexture:"textures/grid-Desert-Tracks-and-Ridgelines.png",gridSize:{cols:5,rows:10}},ds_ruins_oases:{gridTexture:"textures/grid-Desert-set---Oases-and-Ruins.png",gridSize:{cols:5,rows:10}},ar_snow:{gridTexture:"textures/grid-Arctic---Snow.png",gridSize:{cols:5,rows:10}},ar_frozen_forest:{gridTexture:"textures/grid-Arctic---Frozen-Streams-and-Forests.png",gridSize:{cols:5,rows:10}},ar_ice_rocks:{gridTexture:"textures/grid-Arctic---Rocks-and-Ice.png",gridSize:{cols:5,rows:10}},vo_basalt:{gridTexture:"textures/grid-Volcano---Basalt.png",gridSize:{cols:5,rows:10}},vo_volcanic_crater:{gridTexture:"textures/grid-Volcano---Lava-Lake.png",gridSize:{cols:5,rows:10}},vo_lava_flows:{gridTexture:"textures/grid-Volcano---Lava-flow.png",gridSize:{cols:5,rows:10}},ms_marsh:{gridTexture:"textures/grid-Marshland---Marsh.png",gridSize:{cols:5,rows:10}},ms_swamp_streams:{gridTexture:"textures/grid-Marshland---Swamp-and-Causeways.png",gridSize:{cols:5,rows:10}},ms_fetid_forest:{gridTexture:"textures/grid-Marshland---Fetid-Forest.png",gridSize:{cols:5,rows:10}},tv_walls:{gridTexture:"textures/grid-Tavern-Walls.png",gridSize:{cols:5,rows:10}},tv_floors:{gridTexture:"textures/grid-Tavern-floor.png",gridSize:{cols:5,rows:10}},cv_walls:{gridTexture:"textures/grid-Cavern-walls.png",gridSize:{cols:5,rows:10}},cv_floors:{gridTexture:"textures/grid-Cavern-floors.png",gridSize:{cols:5,rows:10}},st_road:{gridTexture:"textures/grid-Streets---Road.png",gridSize:{cols:5,rows:10}},st_market:{gridTexture:"textures/grid-Streets---Market.png",gridSize:{cols:5,rows:10}},dg_walls:{gridTexture:"textures/grid-Dungeons---Walls.png",gridSize:{cols:5,rows:10}},dg_floors:{gridTexture:"textures/grid-Dungeons---Floors.png",gridSize:{cols:5,rows:10}},sh_cursed_earth:{gridTexture:"textures/grid-Shadowlands---Cursed-Earth.png",gridSize:{cols:5,rows:10}},sh_dead_forest:{gridTexture:"textures/grid-Shadowlands---Dead-Forest.png",gridSize:{cols:5,rows:10}},sh_twisted_roads_and_ruins:{gridTexture:"textures/grid-Shadowlands---Twisted-Roads-and-Ruins.png",gridSize:{cols:5,rows:10}},mc_concrete:{gridTexture:"textures/grid-Modern-city---Concrete.png",gridSize:{cols:5,rows:10}},mc_streets:{gridTexture:"textures/grid-Modern-city---Streets.png",gridSize:{cols:5,rows:10}},mc_pavement:{gridTexture:"textures/grid-Modern-city---Pavement.png",gridSize:{cols:5,rows:10}},cb_walls:{gridTexture:"textures/grid-Castle-buildings---Walls.png",gridSize:{cols:5,rows:10}},cb_floors:{gridTexture:"textures/grid-Castle-buildings---Floors.png",gridSize:{cols:5,rows:10}},bk_brown:{gridTexture:"textures/grid-Grassland---plain-grass.png",gridSize:{cols:5,rows:10}},bk_gray:{gridTexture:"textures/grid-Grassland---plain-grass.png",gridSize:{cols:5,rows:10}}}[y]||null}async function m(y,p,f){return new Promise(b=>{const M=new Image;M.onload=()=>{const S=document.createElement("canvas"),x=S.getContext("2d"),{cols:I,rows:V}=f.gridSize,Y=M.width/I,j=M.height/V;S.width=Y,S.height=j;const G=p-1,q=G%I,C=Math.floor(G/I);x.drawImage(M,q*Y,C*j,Y,j,0,0,Y,j);const W=new Image;W.onload=()=>b(W),W.onerror=()=>b(null),W.src=S.toDataURL()},M.onerror=()=>b(null),M.src=y})}function _(y,p){const f=document.createElement("div");f.className="tiles-list";const b=document.createElement("details");b.open=!1,b.className="tiles-accordion";const M=document.createElement("summary"),S=new Set(y.map(Y=>Y.biomeId).filter(Boolean));M.innerHTML=`<i class="fas fa-list"></i> Tiles List (Layer ${p+1})  ${y.length} tiles, ${S.size} biomes <span class="coords-hint"> Q = columns, R = rows</span>`,b.appendChild(M),M.addEventListener("click",()=>{setTimeout(()=>{try{b.open&&f.querySelectorAll(".biome-accordion").forEach(j=>{j.open=!0})}catch{}},0)});const x=document.createElement("div");x.className="tiles-list-toolbar";const I=new Map;y.forEach(Y=>{const j=Y.biomeId;j&&(I.has(j)||I.set(j,[]),I.get(j).push(Y))});const V=document.createElement("div");return V.className="tiles-list-content",I.forEach((Y,j)=>{const G=e.find(E=>E.id===j),q=G?G.name:j,C=document.createElement("details");C.className="biome-accordion",C.open=!1;const W=document.createElement("summary");W.innerHTML=`<strong>${q}</strong> <span class="biome-count">(${Y.length})</span>`,C.appendChild(W);const z=document.createElement("div");z.className="biome-section",z.innerHTML=`
        <div class="biome-tiles">
          ${Y.map(E=>{var T;const N=E.tileNumber||"?",K=E.rotationDegrees&&E.rotationDegrees!==0?`<span class="rot"> ${E.rotationDegrees}</span>`:"";return`<span class="tile-tag"><span class="tile-num">${((T=(j||"").split("_")[0])==null?void 0:T.toUpperCase())||"UNK"}-${N}</span><span class="coords">Q: ${E.q}  R: ${E.r}</span>${K}</span>`}).join("")}
        </div>
      `,C.appendChild(z),V.appendChild(C)}),b.appendChild(V),f.appendChild(b),f}function v(){const y=document.createElement("div");y.className="instructions-overlay";const p=document.createElement("div");p.className="instructions-container";const f=document.createElement("button");return f.className="instructions-close",f.type="button",f.setAttribute("aria-label","Close instructions"),f.innerHTML='<i class="fas fa-times"></i>',f.addEventListener("click",b=>{b.preventDefault(),document.body.removeChild(y)}),p.appendChild(f),y.appendChild(p),document.body.appendChild(y),y.addEventListener("click",b=>{b.target===y&&document.body.removeChild(y)}),window.closeInstructions=()=>{document.body.removeChild(y)},window.printInstructions=()=>{window.print()},window.downloadAllLayerImages=async()=>{const b=document.querySelector(".instructions-container");if(!b)return;const M=b.querySelectorAll("canvas.layer-canvas");if(!M.length){alert("No layers to save.");return}const S=document.getElementById("map-name-input-toolbar"),x=((S==null?void 0:S.value)||"map").trim().replace(/[^a-z0-9-_]+/gi,"_").toLowerCase();let I=1;for(const V of M){const Y=`${x||"map"}_layer-${I}.png`;if(V.toBlob)await new Promise(j=>{V.toBlob(G=>{const q=URL.createObjectURL(G),C=document.createElement("a");C.href=q,C.download=Y,document.body.appendChild(C),C.click(),C.remove(),URL.revokeObjectURL(q),j()},"image/png")});else{const j=V.toDataURL("image/png"),G=document.createElement("a");G.href=j,G.download=Y,document.body.appendChild(G),G.click(),G.remove()}I++,await new Promise(j=>setTimeout(j,60))}},window.downloadInstructionsAsPDF=()=>window.print(),window.expandAllInstructionLists=()=>{try{p.querySelectorAll(".tiles-accordion, .biome-accordion").forEach(b=>{b.open=!0})}catch{}},window.collapseAllInstructionLists=()=>{try{p.querySelectorAll(".biome-accordion").forEach(b=>{b.open=!1}),p.querySelectorAll(".tiles-accordion").forEach(b=>{b.open=!1})}catch{}},{overlay:y,container:p}}return{generateLayerInstructions:n}}function hx(){typeof document>"u"||document.addEventListener("DOMContentLoaded",()=>{const r="data-instructions-enhanced";function e(s){s.querySelectorAll("details").forEach(a=>{a.open=!0})}function t(s){s.querySelectorAll(".tiles-list, .tiles-accordion").forEach(o=>{if(o.hasAttribute(r))return;const l=o.querySelector(":scope > summary")||o.querySelector(":scope .tiles-accordion > summary");if((l||o).querySelector(".tiles-list-toolbar")){o.setAttribute(r,"1");return}const d=document.createElement("div");d.className="tiles-list-toolbar";const u=document.createElement("button");u.className="btn btn-secondary btn-compact",u.type="button",u.title="Expand all tiles lists across all layers",u.innerHTML='<i class="fas fa-angle-double-down"></i> <span>Expand all (all layers)</span>',u.addEventListener("click",h=>{h.preventDefault();const m=document.querySelector(".instructions-container")||document;e(m)}),d.appendChild(u),l?l.appendChild(d):o.insertBefore(d,o.firstChild),o.setAttribute(r,"1")})}function n(){const s=document.querySelector(".instructions-container");if(!s)return;s.hasAttribute(r)||s.setAttribute(r,"1"),t(s),s.querySelectorAll(".instructions-actions button, .instructions-actions a").forEach(o=>{if(o.dataset.wiredAny==="1")return;const l=(o.textContent||o.title||"").toLowerCase(),c=o.hasAttribute("onclick"),d=o.hasAttribute("href"),u=l.includes("print")||l.includes("pdf")&&!l.includes("expand");!c&&u&&(o.addEventListener("click",h=>{d||(h.preventDefault(),window.print())}),o.dataset.wiredAny="1")})}n(),new MutationObserver(()=>n()).observe(document.body,{childList:!0,subtree:!0})})}class fx extends Zn{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new yx(t)}),this.register(function(t){return new vx(t)}),this.register(function(t){return new xx(t)}),this.register(function(t){return new _x(t)}),this.register(function(t){return new mx(t)}),this.register(function(t){return new bx(t)})}load(e,t,n,i){const s=this;let a;this.resourcePath!==""?a=this.resourcePath:this.path!==""?a=this.path:a=xs.extractUrlBase(e),this.manager.itemStart(e);const o=function(c){i?i(c):console.error(c),s.manager.itemError(e),s.manager.itemEnd(e)},l=new ol(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{s.parse(c,a,function(d){t(d),s.manager.itemEnd(e)},o)}catch(d){o(d)}},n,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,i){let s;const a={},o={};if(typeof e=="string")s=e;else if(xs.decodeText(new Uint8Array(e,0,4))===$u){try{a[ut.KHR_BINARY_GLTF]=new wx(e)}catch(u){i&&i(u);return}s=a[ut.KHR_BINARY_GLTF].content}else s=xs.decodeText(new Uint8Array(e));const l=JSON.parse(s);if(l.asset===void 0||l.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new Px(l,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let d=0;d<this.pluginCallbacks.length;d++){const u=this.pluginCallbacks[d](c);o[u.name]=u,a[u.name]=!0}if(l.extensionsUsed)for(let d=0;d<l.extensionsUsed.length;++d){const u=l.extensionsUsed[d],h=l.extensionsRequired||[];switch(u){case ut.KHR_MATERIALS_UNLIT:a[u]=new gx;break;case ut.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:a[u]=new Tx;break;case ut.KHR_DRACO_MESH_COMPRESSION:a[u]=new Mx(l,this.dracoLoader);break;case ut.KHR_TEXTURE_TRANSFORM:a[u]=new Sx;break;case ut.KHR_MESH_QUANTIZATION:a[u]=new Ex;break;default:h.indexOf(u)>=0&&o[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}c.setExtensions(a),c.setPlugins(o),c.parse(n,i)}}function px(){let r={};return{get:function(e){return r[e]},add:function(e,t){r[e]=t},remove:function(e){delete r[e]},removeAll:function(){r={}}}}const ut={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class mx{constructor(e){this.parser=e,this.name=ut.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,i=t.length;n<i;n++){const s=t[n];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let i=t.cache.get(n);if(i)return i;const s=t.json,l=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let c;const d=new ke(16777215);l.color!==void 0&&d.fromArray(l.color);const u=l.range!==void 0?l.range:0;switch(l.type){case"directional":c=new Ca(d),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new La(d),c.distance=u;break;case"spot":c=new Pu(d),c.distance=u,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,l.intensity!==void 0&&(c.intensity=l.intensity),c.name=t.createUniqueName(l.name||"light_"+e),i=Promise.resolve(c),t.cache.add(n,i),i}createNodeAttachment(e){const t=this,n=this.parser,s=n.json.nodes[e],o=(s.extensions&&s.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(l){return n._getNodeRef(t.cache,o,l)})}}class gx{constructor(){this.name=ut.KHR_MATERIALS_UNLIT}getMaterialType(){return wn}extendParams(e,t,n){const i=[];e.color=new ke(1,1,1),e.opacity=1;const s=t.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const a=s.baseColorFactor;e.color.fromArray(a),e.opacity=a[3]}s.baseColorTexture!==void 0&&i.push(n.assignTexture(e,"map",s.baseColorTexture))}return Promise.all(i)}}class yx{constructor(e){this.parser=e,this.name=ut.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:al}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];if(a.clearcoatFactor!==void 0&&(t.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&s.push(n.assignTexture(t,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&s.push(n.assignTexture(t,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(s.push(n.assignTexture(t,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const o=a.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Ae(o,-o)}return Promise.all(s)}}class _x{constructor(e){this.parser=e,this.name=ut.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:al}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return a.transmissionFactor!==void 0&&(t.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&s.push(n.assignTexture(t,"transmissionMap",a.transmissionTexture)),Promise.all(s)}}class vx{constructor(e){this.parser=e,this.name=ut.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,i=n.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const s=i.extensions[this.name],a=n.images[s.source],o=t.options.ktx2Loader;if(!o){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,a,o)}}class xx{constructor(e){this.parser=e,this.name=ut.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,i=n.json,s=i.textures[e];if(!s.extensions||!s.extensions[t])return null;const a=s.extensions[t],o=i.images[a.source];let l=n.textureLoader;if(o.uri){const c=n.options.manager.getHandler(o.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return n.loadTextureImage(e,o,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class bx{constructor(e){this.name=ut.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const i=n.extensions[this.name],s=this.parser.getDependency("buffer",i.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([s,a.ready]).then(function(o){const l=i.byteOffset||0,c=i.byteLength||0,d=i.count,u=i.byteStride,h=new ArrayBuffer(d*u),m=new Uint8Array(o[0],l,c);return a.decodeGltfBuffer(new Uint8Array(h),d,u,m,i.mode,i.filter),h})}else return null}}const $u="glTF",Js=12,xd={JSON:1313821514,BIN:5130562};class wx{constructor(e){this.name=ut.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Js);if(this.header={magic:xs.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==$u)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Js,i=new DataView(e,Js);let s=0;for(;s<n;){const a=i.getUint32(s,!0);s+=4;const o=i.getUint32(s,!0);if(s+=4,o===xd.JSON){const l=new Uint8Array(e,Js+s,a);this.content=xs.decodeText(l)}else if(o===xd.BIN){const l=Js+s;this.body=e.slice(l,l+a)}s+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Mx{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=ut.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,i=this.dracoLoader,s=e.extensions[this.name].bufferView,a=e.extensions[this.name].attributes,o={},l={},c={};for(const d in a){const u=Wo[d]||d.toLowerCase();o[u]=a[d]}for(const d in e.attributes){const u=Wo[d]||d.toLowerCase();if(a[d]!==void 0){const h=n.accessors[e.attributes[d]],m=vr[h.componentType];c[u]=m,l[u]=h.normalized===!0}}return t.getDependency("bufferView",s).then(function(d){return new Promise(function(u){i.decodeDracoFile(d,function(h){for(const m in h.attributes){const _=h.attributes[m],v=l[m];v!==void 0&&(_.normalized=v)}u(h)},o,c)})})}}class Sx{constructor(){this.name=ut.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return e=e.clone(),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),t.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),e.needsUpdate=!0,e}}class Vo extends Mn{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),n=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),i=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	texelSpecular = sRGBToLinear( texelSpecular );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),s=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),a=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.specularRoughness += geometryRoughness;","material.specularRoughness = min( material.specularRoughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),o={specular:{value:new ke().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=o,this.onBeforeCompile=function(l){for(const c in o)l.uniforms[c]=o[c];l.fragmentShader=l.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",n).replace("#include <roughnessmap_fragment>",i).replace("#include <metalnessmap_fragment>",s).replace("#include <lights_physical_fragment>",a)},Object.defineProperties(this,{specular:{get:function(){return o.specular.value},set:function(l){o.specular.value=l}},specularMap:{get:function(){return o.specularMap.value},set:function(l){o.specularMap.value=l,l?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return o.glossiness.value},set:function(l){o.glossiness.value=l}},glossinessMap:{get:function(){return o.glossinessMap.value},set:function(l){o.glossinessMap.value=l,l?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(e){return super.copy(e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class Tx{constructor(){this.name=ut.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return Vo}extendParams(e,t,n){const i=t.extensions[this.name];e.color=new ke(1,1,1),e.opacity=1;const s=[];if(Array.isArray(i.diffuseFactor)){const a=i.diffuseFactor;e.color.fromArray(a),e.opacity=a[3]}if(i.diffuseTexture!==void 0&&s.push(n.assignTexture(e,"map",i.diffuseTexture)),e.emissive=new ke(0,0,0),e.glossiness=i.glossinessFactor!==void 0?i.glossinessFactor:1,e.specular=new ke(1,1,1),Array.isArray(i.specularFactor)&&e.specular.fromArray(i.specularFactor),i.specularGlossinessTexture!==void 0){const a=i.specularGlossinessTexture;s.push(n.assignTexture(e,"glossinessMap",a)),s.push(n.assignTexture(e,"specularMap",a))}return Promise.all(s)}createMaterial(e){const t=new Vo(e);return t.fog=!0,t.color=e.color,t.map=e.map===void 0?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=e.aoMap===void 0?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=1,t.emissiveMap=e.emissiveMap===void 0?null:e.emissiveMap,t.bumpMap=e.bumpMap===void 0?null:e.bumpMap,t.bumpScale=1,t.normalMap=e.normalMap===void 0?null:e.normalMap,t.normalMapType=Ni,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=e.specularMap===void 0?null:e.specularMap,t.specular=e.specular,t.glossinessMap=e.glossinessMap===void 0?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=e.envMap===void 0?null:e.envMap,t.envMapIntensity=1,t.refractionRatio=.98,t}}class Ex{constructor(){this.name=ut.KHR_MESH_QUANTIZATION}}class Ls extends Yn{constructor(e,t,n,i){super(e,t,n,i)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=e*i*3+i;for(let a=0;a!==i;a++)t[a]=n[s+a];return t}}Ls.prototype.beforeStart_=Ls.prototype.copySampleValue_;Ls.prototype.afterEnd_=Ls.prototype.copySampleValue_;Ls.prototype.interpolate_=function(r,e,t,n){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=a*2,l=a*3,c=n-e,d=(t-e)/c,u=d*d,h=u*d,m=r*l,_=m-l,v=-2*h+3*u,y=h-u,p=1-v,f=y-u+d;for(let b=0;b!==a;b++){const M=s[_+b+a],S=s[_+b+o]*c,x=s[m+b+a],I=s[m+b]*c;i[b]=p*M+f*S+v*x+y*I}return i};const Wn={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},vr={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},bd={9728:Ft,9729:nn,9984:Do,9985:zd,9986:No,9987:br},wd={33071:tn,33648:da,10497:_i},Md={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Wo={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},ci={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Ax={CUBICSPLINE:void 0,LINEAR:Ss,STEP:ur},Co={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Sd(r,e){return typeof r!="string"||r===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(r)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(r)||/^data:.*,.*$/i.test(r)||/^blob:.*$/i.test(r)?r:e+r)}function Lx(r){return r.DefaultMaterial===void 0&&(r.DefaultMaterial=new Mn({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:xr})),r.DefaultMaterial}function Qs(r,e,t){for(const n in t.extensions)r[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function Ci(r,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(r.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Rx(r,e,t){let n=!1,i=!1;for(let o=0,l=e.length;o<l;o++){const c=e[o];if(c.POSITION!==void 0&&(n=!0),c.NORMAL!==void 0&&(i=!0),n&&i)break}if(!n&&!i)return Promise.resolve(r);const s=[],a=[];for(let o=0,l=e.length;o<l;o++){const c=e[o];if(n){const d=c.POSITION!==void 0?t.getDependency("accessor",c.POSITION):r.attributes.position;s.push(d)}if(i){const d=c.NORMAL!==void 0?t.getDependency("accessor",c.NORMAL):r.attributes.normal;a.push(d)}}return Promise.all([Promise.all(s),Promise.all(a)]).then(function(o){const l=o[0],c=o[1];return n&&(r.morphAttributes.position=l),i&&(r.morphAttributes.normal=c),r.morphTargetsRelative=!0,r})}function Cx(r,e){if(r.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)r.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(r.morphTargetInfluences.length===t.length){r.morphTargetDictionary={};for(let n=0,i=t.length;n<i;n++)r.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Ix(r){const e=r.extensions&&r.extensions[ut.KHR_DRACO_MESH_COMPRESSION];let t;return e?t="draco:"+e.bufferView+":"+e.indices+":"+Td(e.attributes):t=r.indices+":"+Td(r.attributes)+":"+r.mode,t}function Td(r){let e="";const t=Object.keys(r).sort();for(let n=0,i=t.length;n<i;n++)e+=t[n]+":"+r[t[n]]+";";return e}function qo(r){switch(r){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class Px{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new px,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.nodeNamesUsed={},typeof createImageBitmap<"u"&&/Firefox/.test(navigator.userAgent)===!1?this.textureLoader=new ku(this.options.manager):this.textureLoader=new ll(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new ol(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,i=this.json,s=this.extensions;this.cache.removeAll(),this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(a){const o={scene:a[0][i.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:i.asset,parser:n,userData:{}};Qs(s,o,i),Ci(o,i),Promise.all(n._invokeAll(function(l){return l.afterRoot&&l.afterRoot(o)})).then(function(){e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let i=0,s=t.length;i<s;i++){const a=t[i].joints;for(let o=0,l=a.length;o<l;o++)e[a[o]].isBone=!0}for(let i=0,s=e.length;i<s;i++){const a=e[i];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(n[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const i=n.clone();return i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const i=e(t[n]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let i=0;i<t.length;i++){const s=e(t[i]);s&&n.push(s)}return n}getDependency(e,t){const n=e+":"+t;let i=this.cache.get(n);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this.loadNode(t);break;case"mesh":i=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this.loadAnimation(t);break;case"camera":i=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(n,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(i.map(function(s,a){return n.getDependency(e,a)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[ut.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(s,a){n.load(Sd(t.uri,i.path),s,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const i=t.byteLength||0,s=t.byteOffset||0;return n.slice(s,s+i)})}loadAccessor(e){const t=this,n=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0)return Promise.resolve(null);const s=[];return i.bufferView!==void 0?s.push(this.getDependency("bufferView",i.bufferView)):s.push(null),i.sparse!==void 0&&(s.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(s).then(function(a){const o=a[0],l=Md[i.type],c=vr[i.componentType],d=c.BYTES_PER_ELEMENT,u=d*l,h=i.byteOffset||0,m=i.bufferView!==void 0?n.bufferViews[i.bufferView].byteStride:void 0,_=i.normalized===!0;let v,y;if(m&&m!==u){const p=Math.floor(h/m),f="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+p+":"+i.count;let b=t.cache.get(f);b||(v=new c(o,p*m,i.count*m/d),b=new bi(v,m/d),t.cache.add(f,b)),y=new Es(b,l,h%m/d,_)}else o===null?v=new c(i.count*l):v=new c(o,h,i.count*l),y=new Tt(v,l,_);if(i.sparse!==void 0){const p=Md.SCALAR,f=vr[i.sparse.indices.componentType],b=i.sparse.indices.byteOffset||0,M=i.sparse.values.byteOffset||0,S=new f(a[1],b,i.sparse.count*p),x=new c(a[2],M,i.sparse.count*l);o!==null&&(y=new Tt(y.array.slice(),y.itemSize,y.normalized));for(let I=0,V=S.length;I<V;I++){const Y=S[I];if(y.setX(Y,x[I*l]),l>=2&&y.setY(Y,x[I*l+1]),l>=3&&y.setZ(Y,x[I*l+2]),l>=4&&y.setW(Y,x[I*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return y})}loadTexture(e){const t=this.json,n=this.options,i=t.textures[e],s=t.images[i.source];let a=this.textureLoader;if(s.uri){const o=n.manager.getHandler(s.uri);o!==null&&(a=o)}return this.loadTextureImage(e,s,a)}loadTextureImage(e,t,n){const i=this,s=this.json,a=this.options,o=s.textures[e],l=self.URL||self.webkitURL;let c=t.uri,d=!1,u=!0;if(t.mimeType==="image/jpeg"&&(u=!1),t.bufferView!==void 0)c=i.getDependency("bufferView",t.bufferView).then(function(h){if(t.mimeType==="image/png"){const _=new DataView(h,25,1).getUint8(0,!1);u=_===6||_===4||_===3}d=!0;const m=new Blob([h],{type:t.mimeType});return c=l.createObjectURL(m),c});else if(t.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");return Promise.resolve(c).then(function(h){return new Promise(function(m,_){let v=m;n.isImageBitmapLoader===!0&&(v=function(y){m(new _u(y))}),n.load(Sd(h,a.path),v,void 0,_)})}).then(function(h){d===!0&&l.revokeObjectURL(c),h.flipY=!1,o.name&&(h.name=o.name),u||(h.format=hi);const _=(s.samplers||{})[o.sampler]||{};return h.magFilter=bd[_.magFilter]||nn,h.minFilter=bd[_.minFilter]||br,h.wrapS=wd[_.wrapS]||_i,h.wrapT=wd[_.wrapT]||_i,i.associations.set(h,{type:"textures",index:e}),h})}assignTexture(e,t,n){const i=this;return this.getDependency("texture",n.index).then(function(s){if(n.texCoord!==void 0&&n.texCoord!=0&&!(t==="aoMap"&&n.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+t+" not yet supported."),i.extensions[ut.KHR_TEXTURE_TRANSFORM]){const a=n.extensions!==void 0?n.extensions[ut.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const o=i.associations.get(s);s=i.extensions[ut.KHR_TEXTURE_TRANSFORM].extendTexture(s,a),i.associations.set(s,o)}}e[t]=s})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const i=t.attributes.tangent!==void 0,s=t.attributes.color!==void 0,a=t.attributes.normal===void 0,o=e.isSkinnedMesh===!0,l=Object.keys(t.morphAttributes).length>0,c=l&&t.morphAttributes.normal!==void 0;if(e.isPoints){const d="PointsMaterial:"+n.uuid;let u=this.cache.get(d);u||(u=new rl,Ct.prototype.copy.call(u,n),u.color.copy(n.color),u.map=n.map,u.sizeAttenuation=!1,this.cache.add(d,u)),n=u}else if(e.isLine){const d="LineBasicMaterial:"+n.uuid;let u=this.cache.get(d);u||(u=new Oi,Ct.prototype.copy.call(u,n),u.color.copy(n.color),this.cache.add(d,u)),n=u}if(i||s||a||o||l){let d="ClonedMaterial:"+n.uuid+":";n.isGLTFSpecularGlossinessMaterial&&(d+="specular-glossiness:"),o&&(d+="skinning:"),i&&(d+="vertex-tangents:"),s&&(d+="vertex-colors:"),a&&(d+="flat-shading:"),l&&(d+="morph-targets:"),c&&(d+="morph-normals:");let u=this.cache.get(d);u||(u=n.clone(),o&&(u.skinning=!0),s&&(u.vertexColors=!0),a&&(u.flatShading=!0),l&&(u.morphTargets=!0),c&&(u.morphNormals=!0),i&&(u.vertexTangents=!0,u.normalScale&&(u.normalScale.y*=-1),u.clearcoatNormalScale&&(u.clearcoatNormalScale.y*=-1)),this.cache.add(d,u),this.associations.set(u,this.associations.get(n))),n=u}n.aoMap&&t.attributes.uv2===void 0&&t.attributes.uv!==void 0&&t.setAttribute("uv2",t.attributes.uv),e.material=n}getMaterialType(){return Mn}loadMaterial(e){const t=this,n=this.json,i=this.extensions,s=n.materials[e];let a;const o={},l=s.extensions||{},c=[];if(l[ut.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const u=i[ut.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];a=u.getMaterialType(),c.push(u.extendParams(o,s,t))}else if(l[ut.KHR_MATERIALS_UNLIT]){const u=i[ut.KHR_MATERIALS_UNLIT];a=u.getMaterialType(),c.push(u.extendParams(o,s,t))}else{const u=s.pbrMetallicRoughness||{};if(o.color=new ke(1,1,1),o.opacity=1,Array.isArray(u.baseColorFactor)){const h=u.baseColorFactor;o.color.fromArray(h),o.opacity=h[3]}u.baseColorTexture!==void 0&&c.push(t.assignTexture(o,"map",u.baseColorTexture)),o.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,o.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(o,"metalnessMap",u.metallicRoughnessTexture)),c.push(t.assignTexture(o,"roughnessMap",u.metallicRoughnessTexture))),a=this._invokeOne(function(h){return h.getMaterialType&&h.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(h){return h.extendMaterialParams&&h.extendMaterialParams(e,o)})))}s.doubleSided===!0&&(o.side=yi);const d=s.alphaMode||Co.OPAQUE;return d===Co.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,d===Co.MASK&&(o.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&a!==wn&&(c.push(t.assignTexture(o,"normalMap",s.normalTexture)),o.normalScale=new Ae(1,-1),s.normalTexture.scale!==void 0&&o.normalScale.set(s.normalTexture.scale,-s.normalTexture.scale)),s.occlusionTexture!==void 0&&a!==wn&&(c.push(t.assignTexture(o,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&a!==wn&&(o.emissive=new ke().fromArray(s.emissiveFactor)),s.emissiveTexture!==void 0&&a!==wn&&c.push(t.assignTexture(o,"emissiveMap",s.emissiveTexture)),Promise.all(c).then(function(){let u;return a===Vo?u=i[ut.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o):u=new a(o),s.name&&(u.name=s.name),u.map&&(u.map.encoding=jn),u.emissiveMap&&(u.emissiveMap.encoding=jn),Ci(u,s),t.associations.set(u,{type:"materials",index:e}),s.extensions&&Qs(i,u,s),u})}createUniqueName(e){const t=ft.sanitizeNodeName(e||"");let n=t;for(let i=1;this.nodeNamesUsed[n];++i)n=t+"_"+i;return this.nodeNamesUsed[n]=!0,n}loadGeometries(e){const t=this,n=this.extensions,i=this.primitiveCache;function s(o){return n[ut.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(l){return Ed(l,o,t)})}const a=[];for(let o=0,l=e.length;o<l;o++){const c=e[o],d=Ix(c),u=i[d];if(u)a.push(u.promise);else{let h;c.extensions&&c.extensions[ut.KHR_DRACO_MESH_COMPRESSION]?h=s(c):h=Ed(new pt,c,t),i[d]={primitive:c,promise:h},a.push(h)}}return Promise.all(a)}loadMesh(e){const t=this,n=this.json,i=this.extensions,s=n.meshes[e],a=s.primitives,o=[];for(let l=0,c=a.length;l<c;l++){const d=a[l].material===void 0?Lx(this.cache):this.getDependency("material",a[l].material);o.push(d)}return o.push(t.loadGeometries(a)),Promise.all(o).then(function(l){const c=l.slice(0,l.length-1),d=l[l.length-1],u=[];for(let m=0,_=d.length;m<_;m++){const v=d[m],y=a[m];let p;const f=c[m];if(y.mode===Wn.TRIANGLES||y.mode===Wn.TRIANGLE_STRIP||y.mode===Wn.TRIANGLE_FAN||y.mode===void 0)p=s.isSkinnedMesh===!0?new nl(v,f):new dt(v,f),p.isSkinnedMesh===!0&&!p.geometry.attributes.skinWeight.normalized&&p.normalizeSkinWeights(),y.mode===Wn.TRIANGLE_STRIP?p.geometry=Ad(p.geometry,vp):y.mode===Wn.TRIANGLE_FAN&&(p.geometry=Ad(p.geometry,Hd));else if(y.mode===Wn.LINES)p=new wa(v,f);else if(y.mode===Wn.LINE_STRIP)p=new Mr(v,f);else if(y.mode===Wn.LINE_LOOP)p=new gu(v,f);else if(y.mode===Wn.POINTS)p=new yu(v,f);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+y.mode);Object.keys(p.geometry.morphAttributes).length>0&&Cx(p,s),p.name=t.createUniqueName(s.name||"mesh_"+e),Ci(p,s),y.extensions&&Qs(i,p,y),t.assignFinalMaterial(p),u.push(p)}if(u.length===1)return u[0];const h=new $n;for(let m=0,_=u.length;m<_;m++)h.add(u[m]);return h})}loadCamera(e){let t;const n=this.json.cameras[e],i=n[n.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new $t(tr.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):n.type==="orthographic"&&(t=new Ra(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),Ci(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n={joints:t.joints};return t.inverseBindMatrices===void 0?Promise.resolve(n):this.getDependency("accessor",t.inverseBindMatrices).then(function(i){return n.inverseBindMatrices=i,n})}loadAnimation(e){const n=this.json.animations[e],i=[],s=[],a=[],o=[],l=[];for(let c=0,d=n.channels.length;c<d;c++){const u=n.channels[c],h=n.samplers[u.sampler],m=u.target,_=m.node!==void 0?m.node:m.id,v=n.parameters!==void 0?n.parameters[h.input]:h.input,y=n.parameters!==void 0?n.parameters[h.output]:h.output;i.push(this.getDependency("node",_)),s.push(this.getDependency("accessor",v)),a.push(this.getDependency("accessor",y)),o.push(h),l.push(m)}return Promise.all([Promise.all(i),Promise.all(s),Promise.all(a),Promise.all(o),Promise.all(l)]).then(function(c){const d=c[0],u=c[1],h=c[2],m=c[3],_=c[4],v=[];for(let p=0,f=d.length;p<f;p++){const b=d[p],M=u[p],S=h[p],x=m[p],I=_[p];if(b===void 0)continue;b.updateMatrix(),b.matrixAutoUpdate=!0;let V;switch(ci[I.path]){case ci.weights:V=yr;break;case ci.rotation:V=Ps;break;case ci.position:case ci.scale:default:V=_r;break}const Y=b.name?b.name:b.uuid,j=x.interpolation!==void 0?Ax[x.interpolation]:Ss,G=[];ci[I.path]===ci.weights?b.traverse(function(C){C.isMesh===!0&&C.morphTargetInfluences&&G.push(C.name?C.name:C.uuid)}):G.push(Y);let q=S.array;if(S.normalized){const C=qo(q.constructor),W=new Float32Array(q.length);for(let z=0,E=q.length;z<E;z++)W[z]=q[z]*C;q=W}for(let C=0,W=G.length;C<W;C++){const z=new V(G[C]+"."+ci[I.path],M.array,q,j);x.interpolation==="CUBICSPLINE"&&(z.createInterpolant=function(N){return new Ls(this.times,this.values,this.getValueSize()/3,N)},z.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),v.push(z)}}const y=n.name?n.name:"animation_"+e;return new Uo(y,void 0,v)})}createNodeMesh(e){const t=this.json,n=this,i=t.nodes[e];return i.mesh===void 0?null:n.getDependency("mesh",i.mesh).then(function(s){const a=n._getNodeRef(n.meshCache,i.mesh,s);return i.weights!==void 0&&a.traverse(function(o){if(o.isMesh)for(let l=0,c=i.weights.length;l<c;l++)o.morphTargetInfluences[l]=i.weights[l]}),a})}loadNode(e){const t=this.json,n=this.extensions,i=this,s=t.nodes[e],a=s.name?i.createUniqueName(s.name):"";return function(){const o=[],l=i._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&o.push(l),s.camera!==void 0&&o.push(i.getDependency("camera",s.camera).then(function(c){return i._getNodeRef(i.cameraCache,s.camera,c)})),i._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){o.push(c)}),Promise.all(o)}().then(function(o){let l;if(s.isBone===!0?l=new il:o.length>1?l=new $n:o.length===1?l=o[0]:l=new ht,l!==o[0])for(let c=0,d=o.length;c<d;c++)l.add(o[c]);if(s.name&&(l.userData.name=s.name,l.name=a),Ci(l,s),s.extensions&&Qs(n,l,s),s.matrix!==void 0){const c=new Ve;c.fromArray(s.matrix),l.applyMatrix4(c)}else s.translation!==void 0&&l.position.fromArray(s.translation),s.rotation!==void 0&&l.quaternion.fromArray(s.rotation),s.scale!==void 0&&l.scale.fromArray(s.scale);return i.associations.set(l,{type:"nodes",index:e}),l})}loadScene(e){const t=this.json,n=this.extensions,i=this.json.scenes[e],s=this,a=new $n;i.name&&(a.name=s.createUniqueName(i.name)),Ci(a,i),i.extensions&&Qs(n,a,i);const o=i.nodes||[],l=[];for(let c=0,d=o.length;c<d;c++)l.push(Xu(o[c],a,t,s));return Promise.all(l).then(function(){return a})}}function Xu(r,e,t,n){const i=t.nodes[r];return n.getDependency("node",r).then(function(s){if(i.skin===void 0)return s;let a;return n.getDependency("skin",i.skin).then(function(o){a=o;const l=[];for(let c=0,d=a.joints.length;c<d;c++)l.push(n.getDependency("node",a.joints[c]));return Promise.all(l)}).then(function(o){return s.traverse(function(l){if(!l.isMesh)return;const c=[],d=[];for(let u=0,h=o.length;u<h;u++){const m=o[u];if(m){c.push(m);const _=new Ve;a.inverseBindMatrices!==void 0&&_.fromArray(a.inverseBindMatrices.array,u*16),d.push(_)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',a.joints[u])}l.bind(new sl(c,d),l.matrixWorld)}),s})}).then(function(s){e.add(s);const a=[];if(i.children){const o=i.children;for(let l=0,c=o.length;l<c;l++){const d=o[l];a.push(Xu(d,s,t,n))}}return Promise.all(a)})}function Dx(r,e,t){const n=e.attributes,i=new on;if(n.POSITION!==void 0){const o=t.json.accessors[n.POSITION],l=o.min,c=o.max;if(l!==void 0&&c!==void 0){if(i.set(new P(l[0],l[1],l[2]),new P(c[0],c[1],c[2])),o.normalized){const d=qo(vr[o.componentType]);i.min.multiplyScalar(d),i.max.multiplyScalar(d)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=e.targets;if(s!==void 0){const o=new P,l=new P;for(let c=0,d=s.length;c<d;c++){const u=s[c];if(u.POSITION!==void 0){const h=t.json.accessors[u.POSITION],m=h.min,_=h.max;if(m!==void 0&&_!==void 0){if(l.setX(Math.max(Math.abs(m[0]),Math.abs(_[0]))),l.setY(Math.max(Math.abs(m[1]),Math.abs(_[1]))),l.setZ(Math.max(Math.abs(m[2]),Math.abs(_[2]))),h.normalized){const v=qo(vr[h.componentType]);l.multiplyScalar(v)}o.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(o)}r.boundingBox=i;const a=new Fi;i.getCenter(a.center),a.radius=i.min.distanceTo(i.max)/2,r.boundingSphere=a}function Ed(r,e,t){const n=e.attributes,i=[];function s(a,o){return t.getDependency("accessor",a).then(function(l){r.setAttribute(o,l)})}for(const a in n){const o=Wo[a]||a.toLowerCase();o in r.attributes||i.push(s(n[a],o))}if(e.indices!==void 0&&!r.index){const a=t.getDependency("accessor",e.indices).then(function(o){r.setIndex(o)});i.push(a)}return Ci(r,e),Dx(r,e,t),Promise.all(i).then(function(){return e.targets!==void 0?Rx(r,e.targets,t):r})}function Ad(r,e){let t=r.getIndex();if(t===null){const a=[],o=r.getAttribute("position");if(o!==void 0){for(let l=0;l<o.count;l++)a.push(l);r.setIndex(a),t=r.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),r}const n=t.count-2,i=[];if(e===Hd)for(let a=1;a<=n;a++)i.push(t.getX(0)),i.push(t.getX(a)),i.push(t.getX(a+1));else for(let a=0;a<n;a++)a%2===0?(i.push(t.getX(a)),i.push(t.getX(a+1)),i.push(t.getX(a+2))):(i.push(t.getX(a+2)),i.push(t.getX(a+1)),i.push(t.getX(a)));i.length/3!==n&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=r.clone();return s.setIndex(i),s}function Nx({url:r}){return new Promise((e,t)=>{new fx().load(r,i=>e(i.scene),void 0,i=>t(i))})}function Fx({model:r,lightingEnabled:e}){return r?(r.traverse(t=>{t.isMesh&&(t.castShadow=!!e,t.receiveShadow=!0)}),r):null}function Bx({baseModel:r,scene:e,createGhostMaterials:t,lightingEnabled:n,tileScale:i,baseRotationX:s,baseRotationY:a,currentRotation:o=0}){if(!r||!e||typeof t!="function")return null;const l=r.clone(),c=t();let d=0;return l.traverse(u=>{u.isMesh&&(u.castShadow=!1,u.receiveShadow=!!n,u.material=c[d]||c[0],u.material.needsUpdate=!0,d++)}),typeof i=="number"&&l.scale.set(i,i,i),l.rotation.x=s||0,l.rotation.y=(a||0)+o,l.visible=!1,e.add(l),l}const fn=Kn("app:persistence");function kx(r){const{getPlacementMode:e,setPlacementMode:t,packCounts:n,standaloneBiomeSetCounts:i,tileInstanceLimits:s,perBiomeDenominator:a,environmentPacks:o,ensureBiomeInitialized:l,preloadBiomeTexture:c,getHexTileModel:d,scene:u,interactableObjects:h,createTileMaterials:m,applyMaterialsToTileObject:_,hexSize:v,tileHeight:y,baseRotationX:p,baseRotationY:f,tileScale:b,placedTiles:M,updateHeaderStats:S,updateRightPanelStats:x,getUIController:I,clearMap:V,onTilesLoaded:Y}=r;function j(z){fn.log(" Saving map:",z);const E=(e==null?void 0:e())??"limited",N={version:"1.0",name:z,createdAt:new Date().toISOString(),placementMode:E,packCounts:Object.fromEntries(n),standaloneBiomeSetCounts:Object.fromEntries(i),tiles:Array.from(M.entries()).map(([ee,B])=>{const ne=ee.match(/q:(-?\d+),r:(-?\d+),y:(-?\d+)/);return ne?{key:ee,q:Number.parseInt(ne[1],10),r:Number.parseInt(ne[2],10),y:Number.parseInt(ne[3],10),biomeId:B.instanceId?B.instanceId.split("_").slice(0,-1).join("_"):B.name,tileNumber:B.instanceId?Number.parseInt(B.instanceId.split("_").slice(-1)[0],10):1,rotationDegrees:B.rotationDegrees||0,instanceId:B.instanceId}:null}).filter(Boolean)};fn.log(" Map data prepared:",N);const K=JSON.stringify(N,null,2),J=new Blob([K],{type:"application/json"}),T=URL.createObjectURL(J),O=document.createElement("a");O.href=T,O.download=`${z.replace(/[^a-z0-9]/gi,"_").toLowerCase()}.lsm`,document.body.appendChild(O),O.click(),document.body.removeChild(O),URL.revokeObjectURL(T),fn.log(" Map saved successfully");const H=document.getElementById("save-status");H&&(H.textContent=`Saved ${z}.`,window.setTimeout(()=>{H.textContent=""},3e3))}function G(){var N;const z=document.getElementById("map-name-input-toolbar"),E=((N=z==null?void 0:z.value)==null?void 0:N.trim())||"Unnamed Map";j(E),fn.log(" Map saved from toolbar")}function q(z){W(z),fn.log(" Map loaded from toolbar")}function C(){fn.log(" Fixing existing biome IDs...");let z=0;M.forEach((E,N)=>{if(!(E!=null&&E.instanceId))return;const K=E.instanceId.split("_").slice(0,-1).join("_");E.name&&E.name!==K&&(E.name=K,z+=1,fn.log(` Fixed biome ID for tile at ${N}: ${E.name}`))}),z>0&&(fn.log(` Fixed ${z} biome IDs`),x==null||x())}function W(z){var O;const E=z==null?void 0:z.target,N=(O=E==null?void 0:E.files)==null?void 0:O[0];if(!N)return;fn.log(" Loading map from file:",N.name);const K=M.size>0,J=n.size>0||i.size>0;if(K||J){const H=`Loading a new map will clear your current map and all selected environment packs/biome sets.

Current map status:
 Placed tiles: ${M.size}
 Selected packs: ${n.size}
 Selected standalone biome sets: ${i.size}

Do you want to continue?`;if(!window.confirm(H)){E.value="";return}}const T=new FileReader;T.onload=H=>{var ee,B,ne,Q,se;try{const re=JSON.parse(((ee=H.target)==null?void 0:ee.result)??"{}");if(!re.version||!re.name||!re.tiles)throw new Error("Invalid map file format");fn.log(" Parsed map data:",re),re.version!=="1.0"&&console.warn(" Map file version mismatch. Expected 1.0, got:",re.version),V({skipConfirm:!0}),n.clear(),i.clear(),re.packCounts&&Object.entries(re.packCounts).forEach(([de,D])=>{n.set(de,Number.parseInt(String(D),10))});const be=re.standaloneBiomeSetCounts||re.biomeAddonCounts;be&&Object.entries(be).forEach(([de,D])=>{i.set(de,Number.parseInt(String(D),10))}),re.placementMode&&t&&(t(re.placementMode),document.querySelectorAll('input[name="buildMode"]').forEach(D=>{D.checked=D.value===re.placementMode})),((e==null?void 0:e())??"limited")==="limited"&&(s.clear(),a.clear(),o.forEach(de=>{(n.get(de.id)||0)>0&&de.components&&de.components.forEach(L=>{l(L.setId)})}),i.forEach((de,D)=>{de>0&&l(D)}));try{const de=new Set(re.tiles.map(ce=>ce.biomeId).filter(Boolean)),D=performance.now();de.forEach(ce=>c==null?void 0:c(ce));const L=performance.now();fn.log(` Preload dispatch took ${(L-D).toFixed(1)}ms`)}catch(de){console.warn(" Texture preload skipped:",de)}const me=d();let Ne=0;re.tiles.forEach(de=>{try{if(!me){console.warn(" Hex tile model not loaded yet, skipping tile placement");return}const D={q:de.q,r:de.r},L=de.y,ce=`q:${D.q},r:${D.r},y:${L}`,oe=de.biomeId,Te=de.tileNumber||1,Be=de.rotationDegrees||0,qe=me.clone();qe.userData={isTile:!0,tileKey:ce,instanceId:de.instanceId||`${oe}_${Te}`,biomeId:oe};const X=m(oe,Te);_(qe,X);const U=v*Math.sqrt(3)*(D.q+D.r/2),_e=L*y,Se=v*1.5*D.r;if(qe.position.set(U,_e,Se),qe.rotation.x=p,qe.rotation.y=f+Be*Math.PI/180,qe.scale.set(b,b,b),u.add(qe),h.push(qe),M.set(ce,{name:oe,biomeId:oe,tileNumber:Te,object:qe,instanceId:de.instanceId,yLevel:L,rotation:{x:qe.rotation.x,y:qe.rotation.y,z:qe.rotation.z},rotationDegrees:Be}),((e==null?void 0:e())??"limited")==="limited"&&de.instanceId){const De=s.get(de.instanceId)||0;De>0&&s.set(de.instanceId,De-1)}Ne+=1}catch(D){console.error(" Error loading tile:",de,D)}});const ue=document.getElementById("map-name-input"),le=document.getElementById("map-name-input-toolbar");ue&&(ue.value=re.name),le&&(le.value=re.name),S==null||S(),x==null||x();const ae=I==null?void 0:I();(B=ae==null?void 0:ae.renderEnvironmentPacks)==null||B.call(ae),(ne=ae==null?void 0:ae.renderBiomeSets)==null||ne.call(ae),(Q=ae==null?void 0:ae.refreshBiomeGridUI)==null||Q.call(ae),(se=ae==null?void 0:ae.updateTileSelection)==null||se.call(ae),Y==null||Y({totalTiles:Ne}),fn.log(` Map "${re.name}" loaded successfully with ${Ne} tiles`);const Le=re.standaloneBiomeSetCounts||re.biomeAddonCounts||{};alert(`Map "${re.name}" loaded successfully!

Loaded:
 ${Ne} tiles
 ${Object.keys(re.packCounts||{}).length} environment packs
 ${Object.keys(Le).length} standalone biome sets`)}catch(re){console.error(" Error loading map file:",re),alert(`Error loading map file: ${re.message}

Please check that the file is a valid Lorescape map file (.lsm).`)}finally{E.value=""}},T.readAsText(N)}return{saveMapWithName:j,saveMapToFileToolbar:G,loadMapFromFile:W,loadMapFromFileToolbar:q,fixExistingBiomeIds:C}}function Ox(r){const{maxUndoHistory:e,getPlacementMode:t,getHexTileModel:n,scene:i,interactableObjects:s,placedTiles:a,tileInstanceLimits:o,perBiomeDenominator:l,getBiomeTotalSets:c,createTileMaterials:d,applyMaterialsToTileObject:u,tileScale:h,updateHeaderStats:m,updateRightPanelStats:_,getUIController:v,onTilesMutated:y}=r,p=N=>{if(!N)return 0;const K=N.match(/y:(-?\d+)/);if(!K)return 0;const J=Number.parseInt(K[1],10);return Number.isNaN(J)?0:J},f=N=>{if(typeof y=="function")try{y(N)}catch(K){console.warn("onTilesMutated callback failed",K)}},b=[],M=[];function S(N){b.push({...N,timestamp:Date.now()}),b.length>e&&b.shift(),M.length=0,W()}function x(){if(b.length===0)return;const N=b.pop();switch(N.type){case"place":V(N);break;case"remove":Y(N);break;case"clear":j(N);break}M.push(N),W()}function I(){if(M.length===0)return;const N=M.pop();switch(N.type){case"place":G(N);break;case"remove":q(N);break;case"clear":C();break}b.push(N),W()}function V(N){var J,T;const K=a.get(N.tileKey);if(K&&K.object){i.remove(K.object);const O=s.indexOf(K.object);if(O>-1&&s.splice(O,1),t()==="limited"&&N.instanceId){const H=o.get(N.instanceId)||0;o.set(N.instanceId,H+1)}a.delete(N.tileKey),(T=(J=v==null?void 0:v())==null?void 0:J.refreshBiomeGridUI)==null||T.call(J),m(),_(),f({type:"remove",tileKey:N.tileKey})}}function Y(N){var O,H;if(!N.selectedTileInfo)return;const K=n();if(!K)return;const J=K.clone();J.userData={isTile:!0,tileKey:N.tileKey,instanceId:N.instanceId,biomeId:N.selectedTileInfo.biomeId};const T=d(N.selectedTileInfo.biomeId,N.selectedTileInfo.tileNumber);if(u(J,T),J.position.set(N.position.x,N.position.y,N.position.z),J.rotation.set(N.rotation.x,N.rotation.y,N.rotation.z),J.scale.set(h,h,h),i.add(J),s.push(J),a.set(N.tileKey,{name:N.selectedTileInfo.name,biomeId:N.selectedTileInfo.biomeId,tileNumber:N.selectedTileInfo.tileNumber,object:J,instanceId:N.instanceId,yLevel:p(N.tileKey),rotation:{x:N.rotation.x,y:N.rotation.y,z:N.rotation.z},rotationDegrees:(()=>{const B=(N.rotation.y*180/Math.PI%360+360)%360;let ne=0;return B>270&&B<=330?ne=60:B>210&&B<=270?ne=120:B>150&&B<=210?ne=180:B>90&&B<=150?ne=240:B>30&&B<=90&&(ne=300),ne})()}),t()==="limited"&&N.instanceId){const ee=o.get(N.instanceId)||0;ee>0&&o.set(N.instanceId,ee-1)}(H=(O=v==null?void 0:v())==null?void 0:O.refreshBiomeGridUI)==null||H.call(O),m(),_(),f({type:"add",tileKey:N.tileKey})}function j(N){var J,T;const K=n();K&&(N.savedTiles.forEach(O=>{const H=K.clone();H.userData={isTile:!0,tileKey:O.tileKey,instanceId:O.instanceId,biomeId:O.biomeId};const ee=d(O.biomeId,O.tileNumber);u(H,ee),H.position.set(O.position.x,O.position.y,O.position.z),H.rotation.set(O.rotation.x,O.rotation.y,O.rotation.z),H.scale.set(h,h,h),i.add(H),s.push(H),a.set(O.tileKey,{name:O.name,biomeId:O.biomeId,tileNumber:O.tileNumber,object:H,instanceId:O.instanceId,yLevel:p(O.tileKey),rotation:{x:O.rotation.x,y:O.rotation.y,z:O.rotation.z},rotationDegrees:(()=>{const ne=(O.rotation.y*180/Math.PI%360+360)%360;let Q=0;return ne>270&&ne<=330?Q=60:ne>210&&ne<=270?Q=120:ne>150&&ne<=210?Q=180:ne>90&&ne<=150?Q=240:ne>30&&ne<=90&&(Q=300),Q})()})}),t()==="limited"&&N.savedLimits.forEach((O,H)=>{o.set(H,O)}),(T=(J=v==null?void 0:v())==null?void 0:J.refreshBiomeGridUI)==null||T.call(J),m(),_(),f({type:"refresh"}))}function G(N){var O,H;const K=n();if(!K)return;const J=K.clone();J.userData={isTile:!0,tileKey:N.tileKey,instanceId:N.instanceId,biomeId:N.selectedTileInfo.biomeId};const T=d(N.selectedTileInfo.biomeId,N.selectedTileInfo.tileNumber);if(u(J,T),J.position.set(N.position.x,N.position.y,N.position.z),J.rotation.set(N.rotation.x,N.rotation.y,N.rotation.z),J.scale.set(h,h,h),i.add(J),s.push(J),a.set(N.tileKey,{name:N.selectedTileInfo.name,biomeId:N.selectedTileInfo.biomeId,tileNumber:N.selectedTileInfo.tileNumber,object:J,instanceId:N.instanceId,yLevel:p(N.tileKey),rotation:{x:N.rotation.x,y:N.rotation.y,z:N.rotation.z},rotationDegrees:(()=>{const B=(N.rotation.y*180/Math.PI%360+360)%360;let ne=0;return B>270&&B<=330?ne=60:B>210&&B<=270?ne=120:B>150&&B<=210?ne=180:B>90&&B<=150?ne=240:B>30&&B<=90&&(ne=300),ne})()}),t()==="limited"&&N.instanceId){const ee=o.get(N.instanceId)||0;ee>0&&o.set(N.instanceId,ee-1)}(H=(O=v==null?void 0:v())==null?void 0:O.refreshBiomeGridUI)==null||H.call(O),m(),_(),f({type:"add",tileKey:N.tileKey})}function q(N){var J,T,O;const K=a.get(N.tileKey);if(K&&K.object){i.remove(K.object);const H=s.indexOf(K.object);if(H>-1&&s.splice(H,1),t()==="limited"&&N.instanceId){const ee=(J=N.selectedTileInfo)==null?void 0:J.biomeId,B=l.get(ee)||c(ee),ne=o.get(N.instanceId)||0;ne<B&&o.set(N.instanceId,ne+1)}a.delete(N.tileKey),(O=(T=v==null?void 0:v())==null?void 0:T.refreshBiomeGridUI)==null||O.call(T),m(),_(),f({type:"remove",tileKey:N.tileKey})}}function C(){var N,K;a.forEach(J=>{if(J.object){i.remove(J.object);const T=s.indexOf(J.object);T>-1&&s.splice(T,1)}}),a.clear(),(K=(N=v==null?void 0:v())==null?void 0:N.refreshBiomeGridUI)==null||K.call(N),m(),_(),f({type:"clear"})}function W(){const N=document.getElementById("undo-action"),K=document.getElementById("redo-action"),J=document.getElementById("undo-action-toolbar"),T=document.getElementById("redo-action-toolbar");N&&(N.disabled=b.length===0,N.title=b.length===0?"Nothing to undo":`Undo (${b.length} actions)`),K&&(K.disabled=M.length===0,K.title=M.length===0?"Nothing to redo":`Redo (${M.length} actions)`),J&&(J.disabled=b.length===0,J.title=b.length===0?"Nothing to undo":`Undo (${b.length} actions)`),T&&(T.disabled=M.length===0,T.title=M.length===0?"Nothing to redo":`Redo (${M.length} actions)`)}function z(){return b.length}function E(){return M.length}return{addToUndoStack:S,undo:x,redo:I,updateUndoRedoButtons:W,getUndoCount:z,getRedoCount:E}}const zx=Kn("app:shortcuts");function Ux(r){const{windowRef:e,documentRef:t,undo:n,redo:i,removeTileAtHex:s,getLastHexCoords:a,getGhostTile:o,getCurrentRotation:l,setCurrentRotation:c,baseRotationY:d,createGhostMaterials:u,getSelectedTileInfo:h,refreshGhostTile:m,updateUndoRedoButtons:_,generateBuildInstructions:v,clearMap:y,getCurrentYLevel:p,setCurrentYLevel:f,setManualLevelOverride:b,updateLevelIndicator:M,saveMapToFile:S,loadMapFromFile:x,saveMapToFileToolbar:I,loadMapFromFileToolbar:V,confirmFn:Y=me=>e.confirm(me),toggleDebugOverlay:j,isFirstPersonActive:G=()=>!1,handleCameraPresetSelection:q=null,shiftViewLayer:C=null,setActiveViewLayer:W=null,captureCurrentView:z=null}=r;if(!e||!t)return;e.addEventListener("keydown",me=>{if((me.ctrlKey||me.metaKey)&&!me.altKey){if(me.key==="z"&&!me.shiftKey){me.preventDefault(),n();return}if(me.key==="y"||me.key==="z"&&me.shiftKey){me.preventDefault(),i();return}}const Ne=me.target&&me.target.tagName?me.target.tagName.toLowerCase():"",ue=me.target&&(me.target.isContentEditable||Ne==="input"||Ne==="textarea"||Ne==="select");if(me.key.toLowerCase()==="d"&&(me.ctrlKey||me.metaKey)&&me.altKey){me.preventDefault(),j();return}if(ue||me.ctrlKey||me.metaKey||me.altKey||G())return;const ae=me.key.toLowerCase();if(!(G()&&ae!=="f"))switch(ae){case"delete":case"backspace":{const de=a();de&&de.q!==void 0&&de.r!==void 0&&s(de);break}case"r":{const de=o();if(de){let D=l();D=(D-Math.PI/3)%(2*Math.PI),D<0&&(D+=2*Math.PI),c(D),de.rotation.y=d+D,zx.log(` Rotated ghost tile to ${D} radians (${(D*180/Math.PI).toFixed(0)}) - CLOCKWISE`);try{const L=u(h());let ce=0;de.traverse(oe=>{oe.isMesh&&(oe.material=L[ce]||L[0],ce++)})}catch{}}break}case"c":Y("Are you sure you want to clear the entire map? This action cannot be undone.")&&y();break;case"pageup":me.preventDefault(),f(p()+1),b(!0),M(),m();break;case"pagedown":me.preventDefault(),p()>0&&f(p()-1),b(!0),M(),m();break;case"1":q&&(me.preventDefault(),q("default"));break;case"2":q&&(me.preventDefault(),q("top"));break;case"3":q&&(me.preventDefault(),q("front"));break;case"4":q&&(me.preventDefault(),q("side"));break;case"5":q&&(me.preventDefault(),q("isometric"));break;case"f":q&&(me.preventDefault(),q("first-person"));break;case"q":C&&(me.preventDefault(),C(-1));break;case"e":C&&(me.preventDefault(),C(1));break;case"a":W&&(me.preventDefault(),W(null));break;case"p":z&&(me.preventDefault(),z());break}});const E=t.getElementById("undo-action"),N=t.getElementById("redo-action"),K=t.getElementById("export-map"),J=t.getElementById("clear-map"),T=t.getElementById("save-map"),O=t.getElementById("load-map"),H=t.getElementById("map-file-input"),ee=t.getElementById("undo-action-toolbar"),B=t.getElementById("redo-action-toolbar"),ne=t.getElementById("export-map-toolbar"),Q=t.getElementById("clear-map-toolbar"),se=t.getElementById("save-map-toolbar"),re=t.getElementById("load-map-toolbar"),be=t.getElementById("map-file-input-toolbar");E==null||E.addEventListener("click",n),N==null||N.addEventListener("click",i),K==null||K.addEventListener("click",v),J==null||J.addEventListener("click",()=>{Y("Are you sure you want to clear the entire map? This action cannot be undone.")&&y()}),T==null||T.addEventListener("click",S),O==null||O.addEventListener("click",()=>H==null?void 0:H.click()),H==null||H.addEventListener("change",x),ee==null||ee.addEventListener("click",n),B==null||B.addEventListener("click",i),ne==null||ne.addEventListener("click",v),Q==null||Q.addEventListener("click",()=>{Y("Are you sure you want to clear the entire map? This action cannot be undone.")&&y()}),se==null||se.addEventListener("click",I),re==null||re.addEventListener("click",()=>be==null?void 0:be.click()),be==null||be.addEventListener("change",V),_()}function Hx(r){const{windowRef:e,documentRef:t,getSelectedTileInfo:n,getLastHexCoords:i,getActiveTab:s,getSearchQuery:a,getAnalyticsSummary:o,getPlacedTileCount:l,getUndoCount:c,getRedoCount:d,getPlacementMode:u,getCurrentYLevel:h}=r;let m=null,_=!1,v=null;function y(){var x;if(m)return m;if(!t)return null;const M="lorescape-debug-overlay-style";if(!t.getElementById(M)){const I=t.createElement("style");I.id=M,I.textContent=`
        .debug-overlay {
          position: fixed;
          top: 88px;
          right: 24px;
          min-width: 280px;
          max-width: 340px;
          z-index: 9999;
          background: rgba(17, 24, 39, 0.92);
          color: #f9fafb;
          border-radius: 10px;
          box-shadow: 0 16px 32px rgba(0, 0, 0, 0.45);
          backdrop-filter: blur(8px);
          font-family: 'Inter', 'Segoe UI', sans-serif;
          font-size: 13px;
          line-height: 1.5;
          display: none;
          flex-direction: column;
          border: 1px solid rgba(148, 163, 184, 0.3);
        }
        .debug-overlay__header {
          padding: 12px 16px 10px;
          font-size: 14px;
          font-weight: 600;
          letter-spacing: 0.01em;
          text-transform: uppercase;
          color: #38bdf8;
          display: flex;
          align-items: center;
          gap: 8px;
        }
        .debug-overlay__header .badge {
          background: rgba(56, 189, 248, 0.15);
          color: #e0f2fe;
          padding: 2px 8px;
          border-radius: 12px;
          font-size: 11px;
          font-weight: 500;
          letter-spacing: 0.08em;
        }
        .debug-overlay__content {
          padding: 0 16px 14px;
          display: grid;
          grid-template-columns: 1fr;
          gap: 8px;
        }
        .debug-overlay__row {
          display: flex;
          align-items: baseline;
          justify-content: space-between;
          gap: 12px;
          border-bottom: 1px solid rgba(148, 163, 184, 0.12);
          padding-bottom: 6px;
        }
        .debug-overlay__row:last-child {
          border-bottom: none;
          padding-bottom: 0;
        }
        .debug-overlay__label {
          font-size: 12px;
          letter-spacing: 0.02em;
          text-transform: uppercase;
          color: #94a3b8;
        }
        .debug-overlay__value {
          font-variant-numeric: tabular-nums;
          font-weight: 600;
          color: #f8fafc;
        }
        .debug-overlay__footer {
          padding: 10px 16px 12px;
          border-top: 1px solid rgba(148, 163, 184, 0.12);
          display: flex;
          justify-content: space-between;
          gap: 12px;
          font-size: 11px;
          color: #cbd5f5;
          letter-spacing: 0.02em;
        }
        .debug-overlay__footer span {
          display: inline-flex;
          align-items: center;
          gap: 6px;
        }
        .debug-overlay__footer i {
          color: #38bdf8;
        }
      `,t.head.appendChild(I)}const S=t.createElement("div");return S.className="debug-overlay",S.setAttribute("role","status"),S.setAttribute("aria-live","polite"),S.innerHTML=`
      <div class="debug-overlay__header">
        <span><i class="fas fa-bug"></i> Debug HUD</span>
        <span class="badge">Ctrl+Alt+D</span>
      </div>
      <div class="debug-overlay__content"></div>
      <div class="debug-overlay__footer">
        <span><i class="fas fa-microchip"></i>Runtime</span>
        <span><i class="fas fa-vector-square"></i>Scene</span>
      </div>
    `,S.addEventListener("click",()=>{var Y;const I=S.innerText,V=(e==null?void 0:e.navigator)??(typeof navigator<"u"?navigator:null);(Y=V==null?void 0:V.clipboard)==null||Y.writeText(I).catch(()=>{})}),(x=t.body)==null||x.appendChild(S),m=S,S}function p(){const M=n==null?void 0:n(),S=(M==null?void 0:M.name)||(M==null?void 0:M.biomeId)||"None",x=M?`${M.biomeId||""}  #${M.tileNumber??""}`:"",I=i==null?void 0:i(),V=I&&I.q!==void 0&&I.r!==void 0?`Q${I.q}  R${I.r}`:"",Y=(s==null?void 0:s())||"packs",j=(a==null?void 0:a())??"",G=(o==null?void 0:o())??null;return[{label:"Placed tiles",value:(l==null?void 0:l())??0},{label:"Undo / Redo",value:`${(c==null?void 0:c())??0} / ${(d==null?void 0:d())??0}`},{label:"Placement mode",value:(u==null?void 0:u())==="limited"?"Limited":"Free"},{label:"Active tab",value:Y},{label:"Selected tile",value:S},{label:"Tile details",value:x},{label:"Last hex focus",value:V},{label:"Y level",value:(h==null?void 0:h())??0},{label:"Search query",value:j||""},G?{label:"Analytics",value:G}:null].filter(Boolean)}function f(){if(!_)return;const M=y();if(!M)return;const S=M.querySelector(".debug-overlay__content");if(!S)return;const x=p();S.innerHTML=x.map(({label:I,value:V})=>`
        <div class="debug-overlay__row">
          <div class="debug-overlay__label">${I}</div>
          <div class="debug-overlay__value">${V}</div>
        </div>
      `).join("")}function b(M){var I,V,Y,j,G,q;const S=y();if(!S)return;_=typeof M=="boolean"?M:!_,_?(S.style.display="flex",f(),v&&((V=(I=e??window)==null?void 0:I.clearInterval)==null||V.call(I,v)),v=((j=(Y=e??window)==null?void 0:Y.setInterval)==null?void 0:j.call(Y,f,750))??null):(S.style.display="none",v&&((q=(G=e??window)==null?void 0:G.clearInterval)==null||q.call(G,v),v=null))}return{toggleDebugOverlay:b,updateDebugOverlayContent:f,isDebugOverlayVisible:()=>_}}const Gx={Grass:5025616,Forest:3046706,Streams:240116,Tracks:10322808,Earth:7951688,Rock:6381921,Water:166097,Sand:16761095,Snow:16777215,Stone:10395294,Coastal:48340,Walls:10395294,Floors:12364452,Basalt:4342338,Lava:16007990,Swamp:6323595,Marsh:7951688,Cursed:6765239,Concrete:10395294,Side:7697781,Large:6381921,Castle:9479342,Blank:12434877},Vx={advancedLighting:"lorescape:advancedLighting"},Wx={gridSize:20,hexSize:1,tileHeight:.5,tileScale:1,baseRotationX:0,baseRotationY:0,hexRadius:1},qx=8937795,$x={clickThreshold:200,dragThreshold:5},Xx=50,jx="images/grids/placeholder-grid-biome-set.png",He=Kn("app");hx();He.log(" Data loaded:");He.log("environmentPacks:",Xn.length,"items");He.log("biomeSets:",Pi.length,"items");const Yx=()=>{He.log(" DOM Content Loaded - Starting initialization...");let r="limited";const e=()=>r,t=w=>{r=w},n=$0({getPlacementMode:e}),{packCounts:i,standaloneBiomeSetCounts:s,perBiomeDenominator:a,tileInstanceLimits:o,placedTiles:l,setUpdateCallbacks:c,setPackCount:d,setStandaloneBiomeSetCount:u,removeTile:h,getBiomeTotalSets:m,ensureBiomeInitialized:_,getTotalFromPacks:v}=n,y=Gx,p=qx,f=Vx.advancedLighting,{gridSize:b,hexSize:M,tileHeight:S,tileScale:x,baseRotationX:I,baseRotationY:V,hexRadius:Y}=Wx,{clickThreshold:j,dragThreshold:G}=$x,q=jx;let C=null;const W=()=>{var w;return((w=C==null?void 0:C.isEnabled)==null?void 0:w.call(C))??!1};let z=1,E=null,N=null,K=null,J=null,T=null,O=0,H=0,ee=null,B={q:0,r:0},ne=!1,Q=null;const se={container:null,status:null,upButton:null,downButton:null,allButton:null,captureButton:null,messageTimeout:null};let re="default",be="default";const me={front:1,side:1},Ne=new m0,ue={animationId:null},le=new P,ae=new P,Le=new P,de=new P,D=new P,L=new P,ce=new ki(0,0,0,"YXZ"),oe=new P,Te=new P,Be=new P,qe=new P,X=new P,U={minX:0,maxX:0,minZ:0,maxZ:0,center:new P(0,0,0)};let _e=!1;const Se=w=>1-Math.pow(1-w,3),De=b*M,ve=M*.85,We=M*1.25,it=Math.max(M*6,De*.25),rt=Math.max(M*7.5,De*.3),vt=M*.6,mt=M*.9,It=1.9,jt=Math.max(10,De*.9),yn=new P(0,1,0),wi=new P(0,0,-1),zi=Math.max(.45,M*.55),Yt=S*.75,Mi=It*.95,Si=It*1.25,Ui=w=>.5-.5*Math.cos(Math.PI*w),Jn=.15,Pe={active:!1,pointerLocked:!1,suppressUnlockHandler:!1,yaw:0,pitch:0,moveForward:!1,moveBackward:!1,moveLeft:!1,moveRight:!1,moveUp:!1,moveDown:!1,sprint:!1,baseSpeed:Math.max(10,De*.75),sprintMultiplier:1.6,sensitivity:.0025,minHeight:.6};let On=[],Qn=null;const ln=new P,g=new P,A=new P,R=new P,F=new P,te=new P,he=new P,ie=new _s,ge=new _s,Ee=new P,Me=new P,Oe=new P(0,1,0);let Fe=!1,Ue=0,Je={x:0,y:0};const je=document.getElementById("map-container"),{scene:Ke,camera:we,renderer:ze,controls:Ce,resizeRenderer:tt,getMaxAnisotropy:Ge}=ax({container:je,backgroundColor:5660781});Ce.enableDamping=!0,z=Ge();const st=new ke(16777215),kt=.3,Et=1.1,Zt=new ke(16773590),At=new P(9.5,17,8.2),Mt=new Fu(st.clone(),kt);Ke.add(Mt);const Qe=new Ca(Zt.clone(),Et);Qe.position.copy(At),Ke.add(Qe);const $e=Mt.intensity,Ot=Qe.intensity,Gt=Qe.position.clone(),cn=Qe.color.clone(),Sn=Mt.color.clone();let Vt=null,at=null,_t=null;function ju(w){const $={gs_grass:"Grass",gs_tracks_streams:"Streams",gs_forest_flora:"Forest",bl_earth:"Earth",bl_tracks_streams:"Tracks",bl_wasteland_forest:"Forest",mt_stone:"Stone",mt_streams_forest:"Forest",oc_water:"Water",oc_coastal:"Coastal",oc_tropical_island:"Forest",ds_sand:"Sand",ds_tracks_ridgelines:"Tracks",ds_ruins_oases:"Stone",ar_snow:"Snow",ar_frozen_forest:"Forest",ar_ice_rocks:"Stone",vo_basalt:"Basalt",vo_volcanic_crater:"Basalt",vo_lava_flows:"Lava",ms_marsh:"Marsh",ms_swamp_streams:"Swamp",ms_fetid_forest:"Forest",tv_walls:"Walls",tv_floors:"Floors",cv_walls:"Walls",cv_floors:"Floors",st_road:"Stone",st_market:"Stone",dg_walls:"Walls",dg_floors:"Floors",sh_cursed_earth:"Cursed",sh_dead_forest:"Forest",sh_twisted_roads_and_ruins:"Stone",mc_concrete:"Concrete",mc_streets:"Stone",mc_pavement:"Stone",cb_walls:"Walls",cb_floors:"Floors",bk_brown:"Blank",bk_gray:"Blank"}[w]||"Blank";return y[$]||p}function xl(w){return{gs_grass:{gridTexture:"textures/grid-Grassland---plain-grass.png",gridSize:{cols:5,rows:10}},gs_tracks_streams:{gridTexture:"textures/grid-Grassland---Tracks-and-Streams.png",gridSize:{cols:5,rows:10}},gs_forest_flora:{gridTexture:"textures/grid-Grassland-Forest-and-Flora.png",gridSize:{cols:5,rows:10}},bl_earth:{gridTexture:"textures/grid-Barrenland-set---dirt.png",gridSize:{cols:5,rows:10}},bl_tracks_streams:{gridTexture:"textures/grid-Barrenland-tracks-and-streams.png",gridSize:{cols:5,rows:10}},bl_wasteland_forest:{gridTexture:"textures/grid-Barrenland-Forest-and-Rocks.png",gridSize:{cols:5,rows:10}},mt_stone:{gridTexture:"textures/grid-Mountains---Stone.png",gridSize:{cols:5,rows:10}},mt_streams_forest:{gridTexture:"textures/grid-Mountains---Streams-and-Forests.png",gridSize:{cols:5,rows:10}},oc_water:{gridTexture:"textures/grid-Oceanic---Water.png",gridSize:{cols:5,rows:10}},oc_coastal:{gridTexture:"textures/grid-Oceanic---Coastal.png",gridSize:{cols:5,rows:10}},oc_tropical_island:{gridTexture:"textures/grid-Oceanic---Tropical-Island-and-Shallows.png",gridSize:{cols:5,rows:10}},ds_sand:{gridTexture:"textures/grid-Desert-set---Sand.png",gridSize:{cols:5,rows:10}},ds_tracks_ridgelines:{gridTexture:"textures/grid-Desert-Tracks-and-Ridgelines.png",gridSize:{cols:5,rows:10}},ds_ruins_oases:{gridTexture:"textures/grid-Desert-set---Oases-and-Ruins.png",gridSize:{cols:5,rows:10}},ar_snow:{gridTexture:"textures/grid-Arctic---Snow.png",gridSize:{cols:5,rows:10}},ar_frozen_forest:{gridTexture:"textures/grid-Arctic---Frozen-Streams-and-Forests.png",gridSize:{cols:5,rows:10}},ar_ice_rocks:{gridTexture:"textures/grid-Arctic---Rocks-and-Ice.png",gridSize:{cols:5,rows:10}},vo_basalt:{gridTexture:"textures/grid-Volcano---Basalt.png",gridSize:{cols:5,rows:10}},vo_volcanic_crater:{gridTexture:"textures/grid-Volcano---Lava-Lake.png",gridSize:{cols:5,rows:10}},vo_lava_flows:{gridTexture:"textures/grid-Volcano---Lava-flow.png",gridSize:{cols:5,rows:10}},ms_marsh:{gridTexture:"textures/grid-Marshland---Marsh.png",gridSize:{cols:5,rows:10}},ms_swamp_streams:{gridTexture:"textures/grid-Marshland---Swamp-and-Causeways.png",gridSize:{cols:5,rows:10}},ms_fetid_forest:{gridTexture:"textures/grid-Marshland---Fetid-Forest.png",gridSize:{cols:5,rows:10}},tv_walls:{gridTexture:"textures/grid-Tavern-Walls.png",gridSize:{cols:5,rows:10}},tv_floors:{gridTexture:"textures/grid-Tavern-floor.png",gridSize:{cols:5,rows:10}},cv_walls:{gridTexture:"textures/grid-Cavern-walls.png",gridSize:{cols:5,rows:10}},cv_floors:{gridTexture:"textures/grid-Cavern-floors.png",gridSize:{cols:5,rows:10}},st_road:{gridTexture:"textures/grid-Streets---Road.png",gridSize:{cols:5,rows:10}},st_market:{gridTexture:"textures/grid-Streets---Market.png",gridSize:{cols:5,rows:10}},dg_walls:{gridTexture:"textures/grid-Dungeons---Walls.png",gridSize:{cols:5,rows:10}},dg_floors:{gridTexture:"textures/grid-Dungeons---Floors.png",gridSize:{cols:5,rows:10}},sh_cursed_earth:{gridTexture:"textures/grid-Shadowlands---Cursed-Earth.png",gridSize:{cols:5,rows:10}},sh_dead_forest:{gridTexture:"textures/grid-Shadowlands---Dead-Forest.png",gridSize:{cols:5,rows:10}},sh_twisted_roads_and_ruins:{gridTexture:"textures/grid-Shadowlands---Twisted-Roads-and-Ruins.png",gridSize:{cols:5,rows:10}},mc_concrete:{gridTexture:"textures/grid-Modern-city---Concrete.png",gridSize:{cols:5,rows:10}},mc_streets:{gridTexture:"textures/grid-Modern-city---Streets.png",gridSize:{cols:5,rows:10}},mc_pavement:{gridTexture:"textures/grid-Modern-city---Pavement.png",gridSize:{cols:5,rows:10}},cb_walls:{gridTexture:"textures/grid-Castle-buildings---Walls.png",gridSize:{cols:5,rows:10}},cb_floors:{gridTexture:"textures/grid-Castle-buildings---Floors.png",gridSize:{cols:5,rows:10}},bk_brown:{gridTexture:"textures/grid-Grassland---plain-grass.png",gridSize:{cols:5,rows:10}},bk_gray:{gridTexture:"textures/grid-Grassland---plain-grass.png",gridSize:{cols:5,rows:10}}}[w]||null}const Yu=j0({scene:Ke,getAdvancedLightingEnabled:W,maxSupportedAnisotropy:z,basePlasticColorHex:p,getTileColor:ju,getSelectedTileInfo:()=>E,getGhostTile:()=>at,getGridTexturePath:xl}),{createTileMaterials:Sr,applyMaterialsToTileObject:Tr,createGhostMaterials:Ia,refreshGhostMaterials:bl,preloadBiomeTexture:Zu,setupGhostOpacityControls:Ku,getGhostOpacities:Ju,getCollisionMaterials:Qu,clearCache:eh}=Yu;C=Z0({scene:Ke,renderer:ze,ambientLight:Mt,dirLight:Qe,baseAmbientIntensity:$e,baseAmbientColor:Sn,baseDirIntensity:Ot,baseDirColor:cn,baseDirPosition:Gt,storageKey:f,placedTiles:l,getHexTileModel:()=>Vt,createTileMaterials:Sr,applyMaterialsToTileObject:Tr,refreshGhostMaterials:bl,clearMaterialCache:eh});const Qt=[],Ns=kx({getPlacementMode:e,setPlacementMode:t,packCounts:i,standaloneBiomeSetCounts:s,tileInstanceLimits:o,perBiomeDenominator:a,environmentPacks:Xn,ensureBiomeInitialized:_,preloadBiomeTexture:Zu,getHexTileModel:()=>Vt,scene:Ke,interactableObjects:Qt,createTileMaterials:Sr,applyMaterialsToTileObject:Tr,hexSize:M,tileHeight:S,baseRotationX:I,baseRotationY:V,tileScale:x,placedTiles:l,updateHeaderStats:Ln,updateRightPanelStats:Rn,getUIController:()=>T,clearMap:Hl,onTilesLoaded:()=>{Q=null,ne=!1,Tn(),En(),An()}}),th=Ox({maxUndoHistory:Xx,getPlacementMode:e,getHexTileModel:()=>Vt,scene:Ke,interactableObjects:Qt,placedTiles:l,tileInstanceLimits:o,perBiomeDenominator:a,getBiomeTotalSets:m,createTileMaterials:Sr,applyMaterialsToTileObject:Tr,tileScale:x,updateHeaderStats:Ln,updateRightPanelStats:Rn,getUIController:()=>T,onTilesMutated:({type:w})=>{w==="clear"&&(Q=null,ne=!1),Tn(),En(),An()}}),{addToUndoStack:Pa,undo:nh,redo:ih,updateUndoRedoButtons:Da,getUndoCount:sh,getRedoCount:rh}=th,{toggleDebugOverlay:wl}=Hx({windowRef:typeof window<"u"?window:null,documentRef:typeof document<"u"?document:null,getSelectedTileInfo:()=>E,getLastHexCoords:()=>B,getActiveTab:()=>{var w;return(w=T==null?void 0:T.getActiveTab)==null?void 0:w.call(T)},getSearchQuery:()=>{var w;return(w=T==null?void 0:T.getSearchQuery)==null?void 0:w.call(T)},getAnalyticsSummary:()=>{var w;return((w=J==null?void 0:J.getQuickSummary)==null?void 0:w.call(J))??null},getPlacedTileCount:()=>l.size,getUndoCount:sh,getRedoCount:rh,getPlacementMode:e,getCurrentYLevel:()=>H});typeof window<"u"&&(window.toggleDebugOverlay=wl);function Ml(){O=0,at&&(at.rotation.y=V+O,at.rotation.z=0)}function Fs(w,k,$){if(!_e||!w)return!1;const Z=U.minX-k,fe=U.maxX+k,xe=U.minZ-$,ye=U.maxZ+$,pe=Math.min(Math.max(w.x,Z),fe),Re=Math.min(Math.max(w.z,xe),ye),Xe=pe!==w.x||Re!==w.z;return Xe&&(w.x=pe,w.z=Re),Xe}function Ti(w,k,$=0){const Z=b+$;return Math.abs(w)<=Z&&Math.abs(k)<=Z&&Math.abs(-w-k)<=Z}function Na(w){const k=(Math.sqrt(3)/3*w.x-.3333333333333333*w.z)/M,$=2/3*w.z/M;return{q:k,r:$}}function Fa(w,k){const $=-w-k;let Z=Math.round(w),fe=Math.round(k),xe=Math.round($);const ye=Math.abs(Z-w),pe=Math.abs(fe-k),Re=Math.abs(xe-$);return ye>pe&&ye>Re?Z=-fe-xe:pe>Re?fe=-Z-xe:xe=-Z-fe,{q:Z,r:fe}}function Sl(w,k){return[{q:w+1,r:k-1},{q:w+1,r:k},{q:w,r:k+1},{q:w-1,r:k+1},{q:w-1,r:k},{q:w,r:k-1}]}function Tl(w,k){if(!Ti(w,k))return 0;const $=Sl(w,k);let Z=0;$.forEach(xe=>{for(let ye=0;ye<=50;ye++)l.has(`q:${xe.q},r:${xe.r},y:${ye}`)&&(Z=Math.max(Z,ye))});let fe=-1;for(let xe=0;xe<=50;xe++)l.has(`q:${w},r:${k},y:${xe}`)&&(fe=Math.max(fe,xe));return Math.max(Z,fe>=0?fe+1:0)}function ah(w,k,$){if(!Ti(w,k))return 0;const Z=[];for(let pe=0;pe<=50;pe++)l.has(`q:${w},r:${k},y:${pe}`)&&Z.push(pe);if(Z.length===0){for(let pe=0;pe<=50;pe++)if(Hi(w,k,pe))return pe;return 0}const fe=Math.round($/S);let xe=-1,ye=51;for(const pe of Z)pe<=fe&&pe>xe&&(xe=pe),pe>fe&&pe<ye&&(ye=pe);if(fe>=Math.max(...Z))return Math.max(...Z)+1;if(fe<=Math.min(...Z)){for(let pe=0;pe<=Math.min(...Z);pe++)if(Hi(w,k,pe))return pe}if(xe>=0){for(let pe=xe+1;pe<ye;pe++)if(Hi(w,k,pe))return pe}return Math.max(...Z)+1}function oh(w){const k=ze.domElement.getBoundingClientRect(),$=new Ae((w.clientX-k.left)/k.width*2-1,-((w.clientY-k.top)/k.height)*2+1),Z=new ld;return Z.setFromCamera($,we),Z.intersectObjects(Qt,!0)}function lh(w,k){if(!Ti(w,k))return 0;let $=!1;for(let Z=0;Z<=50;Z++)if(l.has(`q:${w},r:${k},y:${Z}`)){$=!0;break}if($){for(let Z=50;Z>=0;Z--)if(l.has(`q:${w},r:${k},y:${Z}`))return Z+1}for(let Z=0;Z<=50;Z++)if(Hi(w,k,Z))return Z;return 0}function Hi(w,k,$){if(!Ti(w,k))return!1;const Z=`q:${w},r:${k},y:${$}`;if(l.has(Z))return!1;if($===0)return!0;const fe=`q:${w},r:${k},y:${$-1}`;if(l.has(fe))return!0;const xe=Sl(w,k);for(const ye of xe)if(l.has(`q:${ye.q},r:${ye.r},y:${$}`))return!0;return!1}function ch(){Nx({url:"models/hex_tile.gltf"}).then(w=>{var $;const k=W();Vt=Fx({model:w,lightingEnabled:k}),El(),k&&bl(),($=C==null?void 0:C.refreshForLightingMode)==null||$.call(C)}).catch(w=>{console.error("GLTF load error",w),alert("Failed to load 3D model.")})}function El(){Vt&&(at&&at.parent&&at.parent.remove(at),at=Bx({baseModel:Vt,scene:Ke,createGhostMaterials:Ia,lightingEnabled:W(),tileScale:x,baseRotationX:I,baseRotationY:V,currentRotation:O}))}function dh(){if(Vt){if(!at){El();return}An()}}function uh(){var pe;const w=new $n,k=new Oi({color:16777215,opacity:.2,transparent:!0});let $=1/0,Z=-1/0,fe=1/0,xe=-1/0;for(let Re=-b;Re<=b;Re++)for(let Xe=-b;Xe<=b;Xe++){if(Math.abs(Re+Xe)>b)continue;const Ye=M*Math.sqrt(3)*(Re+Xe/2),ot=M*1.5*Xe;$=Math.min($,Ye-M),Z=Math.max(Z,Ye+M),fe=Math.min(fe,ot-M),xe=Math.max(xe,ot+M);const Ze=[];for(let et=0;et<7;et++){const ct=Math.PI/3*et+Math.PI/6;Ze.push(new P(Ye+M*Math.cos(ct),0,ot+M*Math.sin(ct)))}const lt=new pt().setFromPoints(Ze);w.add(new Mr(lt,k))}if(Ke.add(w),Number.isFinite($)&&Number.isFinite(Z)&&Number.isFinite(fe)&&Number.isFinite(xe)){U.minX=$,U.maxX=Z,U.minZ=fe,U.maxZ=xe;const Re=($+Z)*.5,Xe=(fe+xe)*.5;U.center.set(Re,0,Xe),_e=!0}else _e=!1;const ye=new dt(new tl(b*4,b*4),new wn({visible:!1}));ye.rotation.x=-Math.PI/2,ye.userData.isGround=!0,ye.receiveShadow=W(),Ke.add(ye),(pe=C==null?void 0:C.setGroundPlaneReference)==null||pe.call(C,ye),Qt.push(ye)}function hh(){je.addEventListener("pointerdown",Ah),je.addEventListener("pointerup",Lh),je.addEventListener("pointermove",Vl),je.addEventListener("contextmenu",w=>w.preventDefault())}function Ba(){oe.set(1/0,1/0,1/0),Te.set(-1/0,-1/0,-1/0);let w=!1;if(l.forEach(et=>{const ct=et==null?void 0:et.object;if(!ct)return;w=!0,X.copy(ct.position),oe.min(X),Te.max(X);const dn=ct.position.y+S;dn>Te.y&&(Te.y=dn),ct.position.y<oe.y&&(oe.y=ct.position.y)}),!w){let et=Math.max(De*.55,M*8),ct=0,dn=0;if(_e){const zs=(U.maxX-U.minX)*.5,Us=(U.maxZ-U.minZ)*.5,Wh=Math.sqrt(zs*zs+Us*Us);et=Math.max(Wh,zs,Us,M*6),ct=U.center.x,dn=U.center.z}const Vi=Math.max(ve,We),en=et+Vi,un=Math.max(S*6,en*.6),Wt=new P(ct,S*.5,dn),Wa=new P(ct,un*.5,dn);return{hasTiles:!1,radius:en,planeRadius:et,verticalExtent:un,minY:0,maxY:un,target:Wt,center:Wa}}const k=M*1.8;oe.x-=k,oe.z-=k,Te.x+=k,Te.z+=k,oe.y=Math.min(oe.y,0),Te.y+=S*1.5;const $=(oe.x+Te.x)*.5,Z=(oe.z+Te.z)*.5,fe=(oe.y+Te.y)*.5;Be.set($,fe,Z);const xe=Math.max(Te.y-oe.y,S*2),ye=Math.max(Te.x-oe.x,M*2),pe=Math.max(Te.z-oe.z,M*2),Re=Math.max(ye,pe)*.5,Xe=oe.y+xe*.55,Ye=Math.max(oe.y,Math.min(Te.y-S*.6,Xe)),ot=new P($,Ye,Z);qe.set($,fe,Z);let Ze=0;return l.forEach(et=>{const ct=et==null?void 0:et.object;ct&&(X.set(ct.position.x,ct.position.y+S*.5,ct.position.z),X.sub(qe),Ze=Math.max(Ze,X.lengthSq()))}),{hasTiles:!0,radius:Math.max(Math.sqrt(Ze)+Math.max(M,S)*1.2,Re,xe*.5),planeRadius:Re,verticalExtent:xe,minY:oe.y,maxY:Te.y,target:ot,center:Be.clone()}}function Er(w,k,$,{margin:Z=1.15,minDistance:fe=12}={}){const xe=Math.max(w,M*1.2),ye=k*.5,pe=xe/Math.sin(Math.max(.1,Math.min(Math.PI/2-.01,ye))),Re=2*Math.atan(Math.tan(ye)*$),Xe=xe/Math.sin(Math.max(.1,Math.min(Math.PI/2-.01,Re*.5)));return Math.max(pe,Xe,fe)*Z}function Gi(){if(!_e)return;if(Pe.active){Fs(we.position,vt,mt);return}let w=!1;const k=Ce.target.x,$=Ce.target.z;if(Fs(Ce.target,ve,We)){const Z=Ce.target.x-k,fe=Ce.target.z-$;we.position.x+=Z,we.position.z+=fe,w=!0}Fs(we.position,it,rt)&&(w=!0),w&&Ce.enabled&&Ce.update()}function Ar(w,k,{elevationDeg:$,azimuthDeg:Z}){const fe=tr.degToRad($),xe=tr.degToRad(Z),ye=Math.max(1e-4,Math.min(Math.PI-1e-4,Math.PI/2-fe)),pe=xe,Re=new _s(k,ye,pe);return new P().setFromSpherical(Re).add(w)}function Al(w){const k=Ba(),$=ze==null?void 0:ze.domElement,Z=($==null?void 0:$.clientWidth)||window.innerWidth||1,fe=($==null?void 0:$.clientHeight)||window.innerHeight||1,xe=Math.max(Z/fe,.1),ye=tr.degToRad(we.fov);switch(w){case"default":{const pe=Er(k.radius,ye,xe,{margin:.98,minDistance:8});return{position:Ar(k.target,pe,{elevationDeg:32,azimuthDeg:0}),target:k.target.clone(),up:yn,duration:.65}}case"top":{const pe=Math.max(k.planeRadius,M*2),Re=Math.max(k.verticalExtent*.6,S*4),Xe=Math.max(pe/Math.tan(Math.max(.35,ye*.5))*1.05,pe*1.1)+Re;return{position:new P(k.target.x+1e-4,k.target.y+Xe,k.target.z+1e-4),target:k.target.clone(),up:wi,duration:.7}}case"front":{const pe=me.front>=0?0:180,Re=Er(k.radius,ye,xe,{margin:1.25,minDistance:12});return{position:Ar(k.target,Re,{elevationDeg:24,azimuthDeg:pe}),target:k.target.clone(),up:yn,duration:.6}}case"side":{const pe=me.side>=0?90:-90,Re=Er(k.radius,ye,xe,{margin:1.25,minDistance:12});return{position:Ar(k.target,Re,{elevationDeg:24,azimuthDeg:pe}),target:k.target.clone(),up:yn,duration:.6}}case"isometric":{const pe=Er(k.radius,ye,xe,{margin:1.15,minDistance:12});return{position:Ar(k.target,pe,{elevationDeg:58,azimuthDeg:45}),target:k.target.clone(),up:yn,duration:.65}}default:return He.warn(`Unknown camera preset requested: ${w}`),null}}function Ll(w,{immediate:k=!1,duration:$}={}){if(!w)return;const{position:Z,target:fe,up:xe=new P(0,1,0)}=w,ye=typeof $=="number"?$:w.duration??.65;if(ue.animationId!==null&&(cancelAnimationFrame(ue.animationId),ue.animationId=null),k||ye<=0){we.position.copy(Z),Ce.target.copy(fe),we.up.copy(xe),Gi(),Ce.update();return}le.copy(we.position),ae.copy(Ce.target),Le.copy(we.up);const pe=Z.clone(),Re=fe.clone(),Xe=xe.clone();let Ye=null;const ot=Ze=>{Ye===null&&(Ye=Ze);const lt=(Ze-Ye)/1e3,et=Math.min(Math.max(lt/ye,0),1),ct=Se(et);D.lerpVectors(le,pe,ct),de.lerpVectors(ae,Re,ct),L.lerpVectors(Le,Xe,ct),we.position.copy(D),Ce.target.copy(de),we.up.copy(L),Ce.update(),Gi(),et<1?ue.animationId=requestAnimationFrame(ot):(ue.animationId=null,Ce.update(),Gi())};ue.animationId=requestAnimationFrame(ot)}function Rl(w,{duration:k}={}){var ct,dn;if(!w)return;const $=k??w.duration??.75;if($<=0){Ll(w,{immediate:!0});return}ue.animationId!==null&&(cancelAnimationFrame(ue.animationId),ue.animationId=null);const Z=we.position.clone(),fe=Ce.target.clone(),xe=we.up.clone(),ye=w.position.clone(),pe=w.target.clone(),Re=((dn=(ct=w.up)==null?void 0:ct.clone)==null?void 0:dn.call(ct))??yn.clone();ie.setFromVector3(Z.clone().sub(fe)),ge.setFromVector3(ye.clone().sub(pe));let Xe=ge.theta-ie.theta;for(;Xe>Math.PI;)Xe-=Math.PI*2;for(;Xe<-Math.PI;)Xe+=Math.PI*2;let Ye=ge.phi-ie.phi;for(;Ye>Math.PI;)Ye-=Math.PI*2;for(;Ye<-Math.PI;)Ye+=Math.PI*2;const ot=ie.radius,Ze=ge.radius;let lt=null;const et=Vi=>{lt===null&&(lt=Vi);const en=(Vi-lt)/1e3,un=Math.min(Math.max(en/$,0),1),Wt=Ui(un),Wa=tr.lerp(ot,Ze,Wt),zs=ie.theta+Xe*Wt,Us=ie.phi+Ye*Wt;Ee.copy(fe).lerp(pe,Wt),Me.copy(xe).lerp(Re,Wt),he.setFromSpherical(new _s(Wa,Us,zs)),we.position.copy(Ee).add(he),Ce.target.copy(Ee),we.up.copy(Me),Ce.update(),Gi(),un<1?ue.animationId=requestAnimationFrame(et):(ue.animationId=null,Ce.update(),Gi())};ue.animationId=requestAnimationFrame(et)}function Bs(){On.length&&(On.forEach(w=>{var Z;const k=(Z=w.dataset)==null?void 0:Z.cameraPreset;if(!k)return;const $=Pe.active?k==="first-person":k===re;w.classList.toggle("active",$),w.setAttribute("aria-pressed",$?"true":"false")}),Qn&&Qn.classList.toggle("hidden",!Pe.active))}function Lr(w,k={}){const{immediate:$=!1,duration:Z,skipButtonSync:fe=!1,animation:xe="default"}=k,ye=Al(w);ye&&(xe==="orbit"?Rl(ye,{duration:Z}):Ll(ye,{immediate:$,duration:Z}),re=w,be=w,fe||Bs())}function Cl(w){const k=Al(w);if(!k)return;const $=(k.duration??.75)*1.2;Rl(k,{duration:$}),re=w,be=w,Bs()}function fh(w=Ba()){const k=Math.max(w.planeRadius*.7,jt),$=Math.max(w.minY+It,It),Z=new P(w.target.x,$,w.target.z+k);return Fs(Z,vt,mt),Z}function Il(){const w=document.pointerLockElement===ze.domElement;if(Pe.pointerLocked=w,!w){if(Pe.suppressUnlockHandler){Pe.suppressUnlockHandler=!1;return}if(Pe.active){const k=be||"default";Rr({skipPointerUnlock:!0}),Lr(k)}}}function Pl(w){if(!Pe.active||!Pe.pointerLocked)return;const k=w.movementX||0,$=w.movementY||0;Pe.yaw-=k*Pe.sensitivity,Pe.pitch-=$*Pe.sensitivity;const Z=Math.PI/2-.05;Pe.pitch=Math.max(-Z,Math.min(Z,Pe.pitch)),ce.set(Pe.pitch,Pe.yaw,0),we.quaternion.setFromEuler(ce)}function Dl(w){if(Pe.active)switch(w.code){case"KeyW":case"ArrowUp":Pe.moveForward=!0,w.preventDefault();break;case"KeyS":case"ArrowDown":Pe.moveBackward=!0,w.preventDefault();break;case"KeyA":case"ArrowLeft":Pe.moveLeft=!0,w.preventDefault();break;case"KeyD":case"ArrowRight":Pe.moveRight=!0,w.preventDefault();break;case"Space":Pe.moveUp=!0,w.preventDefault();break;case"ControlLeft":case"ControlRight":Pe.moveDown=!0,w.preventDefault();break;case"ShiftLeft":case"ShiftRight":Pe.sprint=!0;break}}function Nl(w){if(Pe.active)switch(w.code){case"KeyW":case"ArrowUp":Pe.moveForward=!1;break;case"KeyS":case"ArrowDown":Pe.moveBackward=!1;break;case"KeyA":case"ArrowLeft":Pe.moveLeft=!1;break;case"KeyD":case"ArrowRight":Pe.moveRight=!1;break;case"Space":Pe.moveUp=!1;break;case"ControlLeft":case"ControlRight":Pe.moveDown=!1;break;case"ShiftLeft":case"ShiftRight":Pe.sprint=!1;break}}function Fl(w){const k=w.y-Mi,$=w.y+Yt,Z=zi,fe=M*.95+Z,xe=fe*fe;l.forEach(ye=>{const pe=ye==null?void 0:ye.object;if(!pe)return;const Re=pe.position.y-S*.3,Xe=pe.position.y+S*1.2;if(k>Xe+Si||$<Re-Si)return;const Ye=w.x-pe.position.x,ot=w.z-pe.position.z,Ze=Ye*Ye+ot*ot;if(Ze>=xe)return;const lt=Math.sqrt(Ze)||1e-4,et=fe-lt;te.set(Ye/lt,0,ot/lt).multiplyScalar(et),w.add(te)})}function ph(w){if(!Pe.active)return;const k=Pe.sprint?Pe.sprintMultiplier:1,$=Pe.baseSpeed*k,Z=$*w,fe=$*.65*w;R.set(0,0,-1).applyQuaternion(we.quaternion),R.y=0,R.lengthSq()>1e-4&&R.normalize(),F.copy(R).cross(Oe),F.lengthSq()>1e-4?F.normalize():F.set(1,0,0),ln.set(0,0,0),Pe.moveForward&&ln.add(R),Pe.moveBackward&&ln.sub(R),Pe.moveRight&&ln.add(F),Pe.moveLeft&&ln.sub(F),ln.lengthSq()>0&&(ln.normalize().multiplyScalar(Z),g.copy(ln),A.copy(we.position).add(g),Fl(A),we.position.copy(A));let xe=0;Pe.moveUp&&(xe+=fe),Pe.moveDown&&(xe-=fe),xe!==0&&(we.position.y+=xe,Fl(we.position)),we.position.y=Math.max(Pe.minHeight,we.position.y),Fs(we.position,vt,mt)}function Rr({skipPointerUnlock:w=!1}={}){var k,$;Pe.active&&(Pe.active=!1,Pe.moveForward=!1,Pe.moveBackward=!1,Pe.moveLeft=!1,Pe.moveRight=!1,Pe.moveUp=!1,Pe.moveDown=!1,Pe.sprint=!1,Pe.pointerLocked=!1,re=be||"default",Ce.enabled=!0,(k=document.body)==null||k.classList.remove("camera-first-person"),document.removeEventListener("pointerlockchange",Il),document.removeEventListener("mousemove",Pl),window.removeEventListener("keydown",Dl,!0),window.removeEventListener("keyup",Nl,!0),!w&&document.pointerLockElement===ze.domElement&&(Pe.suppressUnlockHandler=!0,($=document.exitPointerLock)==null||$.call(document)),Ce.update(),Bs())}function mh(){var Z,fe,xe;if(Pe.active)return;be=re||be||"default",Pe.active=!0,Pe.pointerLocked=!1,re="first-person";const w=Ba();Pe.baseSpeed=Math.max(8,w.planeRadius*.9),Pe.minHeight=Math.max(w.minY+.4,.35);const k=fh(w);we.position.copy(k);const $=w.target.clone();$.y=Math.max(w.minY+S*.5,w.minY+S),we.lookAt($),ce.setFromQuaternion(we.quaternion,"YXZ"),Pe.pitch=ce.x,Pe.yaw=ce.y,Ce.enabled=!1,(Z=document.body)==null||Z.classList.add("camera-first-person"),Bs(),ee=null,document.addEventListener("pointerlockchange",Il),document.addEventListener("mousemove",Pl),window.addEventListener("keydown",Dl,!0),window.addEventListener("keyup",Nl,!0),(xe=(fe=ze.domElement).requestPointerLock)==null||xe.call(fe)}function Bl(w){if(w==="first-person"){Pe.active?(Rr(),Lr(be||"default")):mh();return}if(Pe.active&&Rr(),w==="front"){if(re==="front"){me.front*=-1,Cl("front");return}me.front=1}else if(w==="side"){if(re==="side"){me.side*=-1,Cl("side");return}me.side=1}Lr(w)}function gh(){const w=document.getElementById("camera-toolbar");if(!w){He.warn("Camera toolbar element not found");return}On=Array.from(w.querySelectorAll("[data-camera-preset]")),Qn=document.getElementById("first-person-hint"),On.forEach(k=>{k.setAttribute("aria-pressed","false"),k.addEventListener("click",()=>{var Z;const $=(Z=k.dataset)==null?void 0:Z.cameraPreset;$&&Bl($)})}),Bs()}function kl(w,k){if((k==null?void 0:k.yLevel)!==void 0&&k.yLevel!==null)return k.yLevel;const $=w.match(/y:(-?\d+)/);if(!$)return 0;const Z=Number.parseInt($[1],10);return Number.isNaN(Z)?0:Z}function Ol(w,k){if(!w)return w;let $=w;$.userData||($.userData={}),$.userData.layerFilterBaseOpacity===void 0&&($=$.clone(),$.userData||($.userData={}),$.userData.layerFilterBaseOpacity=$.opacity??1,$.userData.layerFilterOriginalDepthWrite=$.depthWrite,$.userData.layerFilterOriginalTransparent=$.transparent);const Z=$.userData.layerFilterBaseOpacity??1;if(k==="dim"){const fe=Math.max(Jn,Z*Jn);$.opacity=fe,$.transparent=!0,$.depthWrite=!1}else{$.opacity=Z;const fe=$.userData.layerFilterOriginalTransparent??Z<1;$.transparent=fe||$.opacity<.999,$.userData.layerFilterOriginalDepthWrite!==void 0&&($.depthWrite=$.userData.layerFilterOriginalDepthWrite)}return $.needsUpdate=!0,$}function yh(w,k){w.isMesh&&(Array.isArray(w.material)?w.material=w.material.map($=>Ol($,k)):w.material&&(w.material=Ol(w.material,k)))}function _h(w,k){w&&(w.visible=!0,w.traverse($=>yh($,k)))}function ka(){if(l.size===0)return[];const w=new Set;return l.forEach((k,$)=>{w.add(kl($,k))}),Array.from(w).sort((k,$)=>k-$)}function Oa(w,k=2e3){const{status:$}=se;$&&(se.messageTimeout&&(window.clearTimeout(se.messageTimeout),se.messageTimeout=null),$.textContent=w,$.classList.add("view-status--flash"),se.messageTimeout=window.setTimeout(()=>{$.classList.remove("view-status--flash"),se.messageTimeout=null,ks()},k))}function vh(){const w=new Date,k=Re=>String(Re).padStart(2,"0"),$=w.getFullYear(),Z=k(w.getMonth()+1),fe=k(w.getDate()),xe=k(w.getHours()),ye=k(w.getMinutes()),pe=k(w.getSeconds());return`lorescape-view-${$}${Z}${fe}-${xe}${ye}${pe}.png`}function zl(){if(!(ze!=null&&ze.domElement)){He.warn(" Renderer canvas not available for capture"),Oa("Capture unavailable");return}const w=(at==null?void 0:at.visible)??null,k=(_t==null?void 0:_t.visible)??null,$=()=>{at&&w!==null&&(at.visible=w),_t&&k!==null&&(_t.visible=k)};at&&(at.visible=!1),_t&&(_t.visible=!1);let Z=null,fe=null;try{ze.render(Ke,we),Z=ze.domElement.toDataURL("image/png")}catch(pe){fe=pe,He.error(" Failed to capture canvas image",pe)}finally{$();try{ze.render(Ke,we)}catch(pe){He.warn(" Re-render after capture failed",pe)}}if(fe||!Z){!fe&&!Z&&He.error(" Canvas capture returned empty data URL"),Oa("Capture failed");return}const xe=vh(),ye=document.createElement("a");ye.href=Z,ye.download=xe,ye.rel="noopener",document.body.appendChild(ye),ye.click(),document.body.removeChild(ye),He.log(` Saved snapshot as ${xe}`),Oa("Snapshot saved")}function ks({layers:w}={}){const k=se.container;if(!k)return;const $=w??ka(),{status:Z,upButton:fe,downButton:xe,allButton:ye}=se;if(Z&&($.length===0?Z.textContent="No layers":Q===null?Z.textContent="All layers":Z.textContent=`Layer ${Q+1}`),ye&&(ye.disabled=Q===null,ye.classList.toggle("is-active",Q===null)),k.classList.toggle("view-toolbar--isolated",Q!==null&&$.length>0),fe){let pe=!0;if($.length>0)if(Q===null)pe=!$.some(Re=>Re>H);else{const Re=$.indexOf(Q);pe=Re===-1||Re===$.length-1}fe.disabled=pe}if(xe){let pe=!0;$.length>0&&(Q===null?pe=!$.some(Re=>Re<=H):pe=$.indexOf(Q)<=0),xe.disabled=pe}}function Tn(w=null){const k=w??ka();if(k.length===0)Q=null;else if(Q!==null&&!k.includes(Q)){let $=null;for(let Z=k.length-1;Z>=0;Z-=1)if(k[Z]<Q){$=k[Z];break}$===null&&($=k.find(Z=>Z>Q)??k[0]),Q=$??null,Q!==null&&(H=Q,ne=!0,En())}l.forEach(($,Z)=>{const fe=$==null?void 0:$.object;if(!fe)return;const xe=kl(Z,$);_h(fe,Q===null||xe===Q?"full":"dim")}),ks({layers:k})}function za(w,{syncView:k=!0}={}){const $=Math.max(0,Math.floor(w));H=$,k&&Q!==null?(Q=$,ne=!0,Tn()):ks()}function Cr(w){if(w==null){if(Q===null)return;Q=null,ne=!1,Tn(),En(),An();return}const k=Math.max(0,Math.floor(w));Q!==k&&(Q=k,H=k,ne=!0,En(),Tn(),An())}function Ua(w){const k=ka();if(k.length===0){Cr(null);return}const $=w>=0?1:-1;let Z=null;if(Q===null)if($>0)Z=k.find(fe=>fe>H)??null;else{for(let fe=k.length-1;fe>=0;fe-=1)if(k[fe]<=H){Z=k[fe];break}Z==null&&(Z=k[0])}else{const fe=k.indexOf(Q);if(fe!==-1){const xe=fe+$;xe>=0&&xe<k.length&&(Z=k[xe])}else $>0?Z=k[0]:Z=k[k.length-1]}Z!=null&&Cr(Z)}function xh(){var k,$,Z,fe;const w=document.getElementById("view-toolbar");if(!w){He.warn("View toolbar element not found");return}se.container=w,se.status=w.querySelector("#view-status"),se.upButton=w.querySelector('[data-layer-action="up"]'),se.downButton=w.querySelector('[data-layer-action="down"]'),se.allButton=w.querySelector('[data-layer-action="all"]'),se.captureButton=w.querySelector("#view-capture-btn"),(k=se.upButton)==null||k.addEventListener("click",()=>Ua(1)),($=se.downButton)==null||$.addEventListener("click",()=>Ua(-1)),(Z=se.allButton)==null||Z.addEventListener("click",()=>Cr(null)),(fe=se.captureButton)==null||fe.addEventListener("click",zl),ks()}function bh(){const w=document.getElementById("overlay-control-stack");if(!w)return;const k=Array.from(w.querySelectorAll(".control-pill")),$=w.querySelector("#overlay-control-collapse"),Z=w.querySelector("#overlay-control-expanded"),fe=document.getElementById("camera-toolbar"),xe=document.getElementById("view-toolbar");w.classList.add("is-collapsed");const ye={camera:()=>fe==null?void 0:fe.querySelector(".camera-btn"),view:()=>xe==null?void 0:xe.querySelector(".view-btn")},pe=Ze=>{w.dataset.expanded=Ze?"true":"false",Z==null||Z.setAttribute("aria-hidden",Ze?"false":"true"),Ze||k.forEach(lt=>{lt.classList.remove("is-active"),lt.setAttribute("aria-expanded","false")})},Re=Ze=>{(Ze==="camera"||Ze==="view")&&(fe&&(fe.style.display="flex"),xe&&(xe.style.display="flex")),w.dataset.openSection=Ze,k.forEach(lt=>{lt.classList.toggle("is-active",!0),lt.setAttribute("aria-expanded",w.classList.contains("is-collapsed")?"false":"true")})},Xe=Ze=>{window.setTimeout(()=>{var et;const lt=(et=ye[Ze])==null?void 0:et.call(ye);lt==null||lt.focus()},80)},Ye=(Ze="camera")=>{w.classList.remove("is-collapsed"),Re(Ze),pe(!0),Xe(Ze)},ot=()=>{w.classList.add("is-collapsed"),pe(!1),w.removeAttribute("data-open-section"),fe&&(fe.style.display="none"),xe&&(xe.style.display="none"),window.setTimeout(()=>{var Ze;(Ze=k[0])==null||Ze.focus()},60)};k.forEach(Ze=>{const lt=Ze.dataset.section||"camera";Ze.addEventListener("click",()=>{w.classList.contains("is-collapsed")?Ye(lt):ot()})}),$==null||$.addEventListener("click",ot),w.addEventListener("keydown",Ze=>{Ze.key==="Escape"&&!w.classList.contains("is-collapsed")&&(Ze.preventDefault(),ot())}),fe&&(fe.style.display="none"),xe&&(xe.style.display="none"),pe(!1)}function Ul(){requestAnimationFrame(Ul);const w=Ne.getDelta();Pe.active?ph(w):Ce.update(),Gi(),ze.render(Ke,we)}function En(){const w=document.getElementById("level-indicator");if(w){let k=`Level: ${H+1}`;Q!==null&&Q!==H&&(k+=`  View ${Q+1}`),w.textContent=k}ks()}function An(){ee&&at&&Vt&&Vl(ee)}function wh(){var w;l.forEach(k=>{if(k.object){Ke.remove(k.object);const $=Qt.indexOf(k.object);$>-1&&Qt.splice($,1)}}),l.clear(),Q=null,ne=!1,Tn(),En(),An(),r==="limited"&&(o.clear(),Xn.forEach(k=>{(i.get(k.id)||0)>0&&k.components&&k.components.forEach(Z=>{_(Z.setId)})}),s.forEach((k,$)=>{k>0&&_($)}),He.log(" Reset all tile instance limits after map clear")),Ln(),Rn(),(w=T==null?void 0:T.refreshBiomeGridUI)==null||w.call(T)}function Hl(w={}){const{skipConfirm:k=!1,recordUndo:$=!0}=w;if(l.size===0||!k&&!confirm("Are you sure you want to clear the entire map? This action can be undone with Ctrl+Z."))return;let Z=null;if($){const fe=[],xe=new Map;l.forEach((ye,pe)=>{var Xe;if(!(ye!=null&&ye.object))return;const Re=ye.instanceId?Number.parseInt(ye.instanceId.split("_").pop(),10):1;fe.push({tileKey:pe,name:ye.name,instanceId:ye.instanceId,biomeId:ye.object.userData.biomeId,tileNumber:Re,type:(Xe=ye.name)==null?void 0:Xe.split(" ")[0],position:{x:ye.object.position.x,y:ye.object.position.y,z:ye.object.position.z},rotation:{x:ye.object.rotation.x,y:ye.object.rotation.y,z:ye.object.rotation.z}})}),r==="limited"&&o.forEach((ye,pe)=>{xe.set(pe,ye)}),Z={type:"clear",savedTiles:fe,savedLimits:xe}}wh(),Z&&Pa(Z)}function Mh(){var $;const w=document.getElementById("map-name-input"),k=(($=w==null?void 0:w.value)==null?void 0:$.trim())||"Unnamed Map";Ns.saveMapWithName(k),He.log(" Map saved from right panel")}function Sh(w){Ns.loadMapFromFile(w)}function Gl(){Ns.saveMapToFileToolbar()}function Th(w){Ns.loadMapFromFileToolbar(w)}function Eh(){Ns.fixExistingBiomeIds()}function Ah(w){if(Pe.active){Ue=0;return}Ue=Date.now(),Je={x:w.clientX,y:w.clientY},Fe=!1}function Lh(w){if(Pe.active)return;w.preventDefault();const k=Date.now()-Ue,$=Math.hypot(w.clientX-Je.x,w.clientY-Je.y);k<j&&$<G&&!Fe&&(He.log("Canvas click detected"),Dh(w)),Fe=!1}function Vl(w){if(Pe.active||!Vt||!at)return;Ue>0&&Math.hypot(w.clientX-Je.x,w.clientY-Je.y)>G&&(Fe=!0),ee=w;const k=oh(w);if(k.length===0){at.visible=!1,_t&&(_t.visible=!1);return}let $=k[0],Z=$.object;for(;Z.parent&&!Z.userData.isGround&&!Z.userData.isTile;)Z=Z.parent;let fe=$.point;Z.userData.isTile&&(fe=Z.position);const{q:xe,r:ye}=Na(fe),{q:pe,r:Re}=Fa(xe,ye);if(!Ti(pe,Re)){at.visible=!1,_t&&(_t.visible=!1);return}if((B.q!==pe||B.r!==Re)&&(B={q:pe,r:Re},Q===null&&(ne=!1)),ne)Q!==null&&H!==Q&&(za(Q,{syncView:!1}),En());else{const en=ah(pe,Re,$.point.y);en!==H&&(za(en,{syncView:!1}),En())}const Xe=Tl(pe,Re),Ye=Math.min(H,Xe),ot=M*Math.sqrt(3)*(pe+Re/2),Ze=M*1.5*Re,lt=Ye*S;at.position.set(ot,lt,Ze),at.rotation.y=V+O,at.rotation.x=I,at.scale.set(x,x,x),at.visible=!0,_t&&(_t.position.set(ot,.01,Ze),_t.visible=!0);const et=Hi(pe,Re,Ye),ct=`q:${pe},r:${Re},y:${Ye}`,dn=l.has(ct),Vi=W();if(et&&!dn&&N){const en=Ia();let un=0;at.traverse(Wt=>{Wt.isMesh&&(Wt.material=en[un]||en[0],un++)})}else{const en=Qu();let un=0;at.traverse(Wt=>{Wt.isMesh&&(Wt.material=en[un]||en[0],Wt.material.needsUpdate=!0,Wt.castShadow=!1,Wt.receiveShadow=Vi,un++)})}}function Ha(w,k={block:"center"}){const $=document.getElementById("left-panel");if($&&($.classList.remove("collapsed"),$.classList.add("open"),He.log(" Left panel opened")),w){try{w.scrollIntoView({behavior:"smooth",block:k.block||"center"})}catch{w.scrollIntoView()}document.activeElement&&document.activeElement!==w&&(He.log(` Removing focus from: ${document.activeElement.tagName}.${document.activeElement.className}`),document.activeElement.blur()),typeof w.focus=="function"&&(w.focus(),He.log(` Focus set to: ${w.tagName}.${w.className}`),window.setTimeout(()=>{document.activeElement!==w?(He.log(" Focus lost, re-attempting..."),w.focus(),document.activeElement===w?He.log(" Focus successfully re-set"):He.log(" Focus re-attempt failed. Active element is: "+document.activeElement.tagName)):He.log(" Focus confirmed stable")},100))}}function Rh(){for(const w of i.values())if((w||0)>0)return!0;return!1}function Ch(){return He.log(" === STARTING focusEnvironmentPacksList ==="),T&&typeof T.switchToTab=="function"?(He.log(" Switching to packs tab..."),T.switchToTab("packs")):He.log(" uiController or switchToTab not available"),window.setTimeout(()=>{He.log(" Searching for pack elements...");const w=document.querySelector("#tab-packs #packs-grid .card .card-left .card-image");if(w){He.log(" Found first pack image!"),Ha(w);return}else He.log(" First pack image NOT found");const k=Array.from(document.querySelectorAll(".tab-btn")).find($=>$.dataset.tab==="packs");k?(He.log(" Found packs tab button (fallback)"),Ha(k)):He.log(" Could not find any element to focus!")},200),!0}function Ih(){He.log(" === STARTING focusBiomeDropdown ===");const w=document.getElementById("biome-select");if(w){He.log(" Found biome select element");const k=document.activeElement===w;return He.log(` Dropdown already focused: ${k}`),Ha(w,{block:"nearest"}),k?He.log(" Dropdown already open, skipping re-open animation"):window.setTimeout(()=>{try{if(typeof w.showPicker=="function")w.showPicker(),He.log(" Dropdown opened with showPicker()");else{const $=new MouseEvent("mousedown",{bubbles:!0,cancelable:!0,view:window});w.dispatchEvent($),He.log(" Dropdown opened with mousedown event")}}catch($){He.log(" Could not auto-open dropdown: "+$.message)}},100),!0}return He.log(" Biome select element not found"),!1}function Ph(){var Z;if(!Rh())return Ch();const w=document.getElementById("biome-select"),k=(Z=T==null?void 0:T.getActiveBiomeForGrid)==null?void 0:Z.call(T);return!!(w&&w.value)||!!k?!1:Ih()}function Dh(w){if(He.log(" Map clicked"),!N||!E||!Vt){Ph()||He.log(" No tile selected - please select a tile first");return}const k=ze.domElement.getBoundingClientRect(),$=new Ae((w.clientX-k.left)/k.width*2-1,-((w.clientY-k.top)/k.height)*2+1),Z=new ld;Z.setFromCamera($,we);const fe=Z.intersectObjects(Qt,!0);if(fe.length===0)return;let xe=fe[0],ye=xe.object;for(;ye.parent&&!ye.userData.isGround&&!ye.userData.isTile;)ye=ye.parent;if(w.button===0){let pe=xe.point;ye.userData.isTile&&(pe=ye.position);const{q:Re,r:Xe}=Na(pe),{q:Ye,r:ot}=Fa(Re,Xe);if(!Ti(Ye,ot)){He.log(" Cannot place tiles outside the map boundary");return}const Ze=Tl(Ye,ot),lt=Math.min(H,Ze);if(!Hi(Ye,ot,lt))return;const et=`q:${Ye},r:${ot},y:${lt}`;if(l.has(et))return;Nh({q:Ye,r:ot},lt)}else if(w.button===2&&ye.userData.isTile){const pe=ye.userData.tileKey;if(pe)Fh(pe);else{const{q:Re,r:Xe}=Na(ye.position),{q:Ye,r:ot}=Fa(Re,Xe),Ze=Math.round(ye.position.y/S);Ga({q:Ye,r:ot},Ze)}}}function Nh(w,k=H){var ot,Ze,lt;if(!N){He.log(" No tile selected");return}if(!Ti(w.q,w.r)){He.log(` Cannot place tile outside the map boundary at q:${w.q}, r:${w.r}`);return}const $=`q:${w.q},r:${w.r},y:${k}`;if(l.has($)){He.log(` Position ${$} is already occupied`);return}if(r==="limited"&&(E!=null&&E.instanceId)){let et=o.get(E.instanceId);if(et==null&&(_(E.biomeId),et=o.get(E.instanceId)??0),et<=0&&(!(((ot=T==null?void 0:T.advanceToNextAvailableInstance)==null?void 0:ot.call(T,E.biomeId,E.instanceId))??!1)||(o.get(E.instanceId)??0)<=0))return}const Z=Vt.clone();Z.userData={isTile:!0,tileKey:$,instanceId:(E==null?void 0:E.instanceId)||null,biomeId:(E==null?void 0:E.biomeId)||null};const fe=Sr(E==null?void 0:E.biomeId,E==null?void 0:E.tileNumber);Tr(Z,fe);const xe=M*Math.sqrt(3)*(w.q+w.r/2),ye=k*S,pe=M*1.5*w.r;Z.position.set(xe,ye,pe),Z.rotation.x=I,Z.rotation.y=V+O,Z.scale.set(x,x,x),He.log(` Tile rotation: BASE_ROTATION_Y=${V}, currentRotation=${O}, final=${V+O}, placementMode=${r}`),Ke.add(Z),Qt.push(Z);const Re=(O*180/Math.PI%360+360)%360;let Xe=0;if(Re>270&&Re<=330?Xe=60:Re>210&&Re<=270?Xe=120:Re>150&&Re<=210?Xe=180:Re>90&&Re<=150?Xe=240:Re>30&&Re<=90&&(Xe=300),l.set($,{name:E.name,biomeId:(E==null?void 0:E.biomeId)||null,tileNumber:(E==null?void 0:E.tileNumber)||null,object:Z,instanceId:Z.userData.instanceId,yLevel:k,rotation:{x:Z.rotation.x,y:Z.rotation.y,z:Z.rotation.z},rotationDegrees:Xe}),r==="limited"&&(E!=null&&E.instanceId)){const et=o.get(E.instanceId)??0;if(et>0){o.set(E.instanceId,et-1),He.log(` Used tile ${E.instanceId}, remaining: ${et-1}`);const ct=o.get(E.instanceId)===0;(Ze=T==null?void 0:T.refreshBiomeGridUI)==null||Ze.call(T),ct&&((lt=T==null?void 0:T.advanceToNextAvailableInstance)==null||lt.call(T,E.biomeId,E.instanceId))}}Ln(),Rn();const Ye={type:"place",tileKey:$,selectedTileInfo:{...E},instanceId:E==null?void 0:E.instanceId,position:{x:Z.position.x,y:Z.position.y,z:Z.position.z},rotation:{x:Z.rotation.x,y:Z.rotation.y,z:Z.rotation.z}};Pa(Ye),B.q===w.q&&B.r===w.r&&(Q===null?(H=lh(w.q,w.r),ne=!1):(H=Q,ne=!0),En(),An()),O=0,at&&(at.rotation.y=V+O,He.log(" Reset rotation to 0 for next tile")),Tn(),He.log(` Placed tile ${E.instanceId} at ${$}`)}function Ga(w,k=null){var ye;if(k===null){for(let pe=50;pe>=0;pe--){const Re=`q:${w.q},r:${w.r},y:${pe}`;if(l.has(Re)){k=pe;break}}if(k===null){He.log(` No tile found at hex q:${w.q},r:${w.r}`);return}}const $=`q:${w.q},r:${w.r},y:${k}`,Z=l.get($);if(!Z){He.log(` No tile at position ${$}`);return}const fe=Qt.find(pe=>pe.userData.tileKey===$);let xe=!1;if(fe?(kh(fe),xe=!0):h(w,k),Bh($),r==="limited"&&Z.instanceId){const pe=a.get(Z.biomeId)||m(Z.biomeId),Re=o.get(Z.instanceId)||0;Re<pe?(o.set(Z.instanceId,Re+1),He.log(` Restored tile ${Z.instanceId}, now available: ${Re+1}/${pe}`)):He.log(` Tile ${Z.instanceId} already at maximum availability: ${Re}/${pe}`)}Ln(),Rn(),(ye=T==null?void 0:T.refreshBiomeGridUI)==null||ye.call(T),xe||(Tn(),An()),He.log(` Removed tile from ${$}`)}function Fh(w){if(!l.get(w)){He.log(` No tile found with key ${w}`);return}const $=w.split(","),Z=parseInt($[0].split(":")[1]),fe=parseInt($[1].split(":")[1]),xe=parseInt($[2].split(":")[1]);Ga({q:Z,r:fe},xe)}function Bh(w){const k=Qt.findIndex($=>$.userData.tileKey===w);if(k!==-1){const $=Qt[k];return Ke.remove($),Qt.splice(k,1),He.log(` Removed 3D tile from ${w}`),!0}else return He.log(` Could not find 3D tile with key ${w}`),!1}function Ln(){var w;(w=K==null?void 0:K.updateHeaderStats)==null||w.call(K)}function Rn(){var w;(w=K==null?void 0:K.updateRightPanelStats)==null||w.call(K)}function kh(w){var fe,xe,ye,pe;if(!w||!w.userData.isTile)return;const k={type:"remove",tileKey:w.userData.tileKey,instanceId:w.userData.instanceId,selectedTileInfo:{type:((xe=(fe=l.get(w.userData.tileKey))==null?void 0:fe.name)==null?void 0:xe.split(" ")[0])||"Unknown",name:((ye=l.get(w.userData.tileKey))==null?void 0:ye.name)||"Unknown",biomeId:w.userData.biomeId},position:{x:w.position.x,y:w.position.y,z:w.position.z},rotation:{x:w.rotation.x,y:w.rotation.y,z:w.rotation.z}};Pa(k);const $=w.userData.tileKey,Z=l.get($);if(Z&&Z.object){Ke.remove(Z.object);const Re=Qt.indexOf(Z.object);if(Re>-1&&Qt.splice(Re,1),r==="limited"&&w.userData.instanceId){const Xe=w.userData.biomeId,Ye=a.get(Xe)||m(Xe),ot=o.get(w.userData.instanceId)||0;ot<Ye&&o.set(w.userData.instanceId,ot+1)}l.delete($),(pe=T==null?void 0:T.refreshBiomeGridUI)==null||pe.call(T),Ln(),Rn(),Tn(),An()}}function Wl(){var $;K=ix({stateManager:n,biomeSets:Pi,environmentPacks:Xn,getPlacementMode:()=>r,onHeaderStatsUpdated:()=>{const Z=document.getElementById("export-map-toolbar");if(Z){const fe=l.size>0;Z.classList.toggle("is-outline",!fe)}},onRightPanelStatsUpdated:()=>{}}),J=K.initialize(),He.log(" Analytics system initialized"),T=sx({environmentPacks:Xn,biomeSets:Pi,packCounts:i,standaloneBiomeSetCounts:s,tileInstanceLimits:o,ensureBiomeInitialized:_,setPackCount:d,setStandaloneBiomeSetCount:u,getBiomeTotalSets:m,getTotalFromPacks:v,getPlacementMode:e,setPlacementMode:Z=>{var fe;t(Z),Ml(),Ln(),Rn(),(fe=T==null?void 0:T.refreshCurrentTab)==null||fe.call(T)},resetPlacementRotation:Ml,createOrUpdateGhostTile:dh,getSelectedTileInfo:()=>E,setSelectedTileInfo:Z=>{E=Z},setSelectedTile:Z=>{N=Z},updateHeaderStats:Ln,updateRightPanelStats:Rn,updateUndoRedoButtons:Da,getGhostOpacities:Ju,setupGhostOpacityControls:Ku,placeholderSprite:q,getGridTexturePath:xl});const w=new Bv(Y*.9,Y,32,1),k=new wn({color:16776960,side:yi});_t=new dt(w,k),_t.rotation.x=-Math.PI/2,_t.visible=!1,Ke.add(_t),Lr("default",{immediate:!0,skipButtonSync:!0}),Oh(),($=C==null?void 0:C.setupToggle)==null||$.call(C),Eh(),ch(),uh(),hh(),Ul()}typeof window<"u"&&(window.initApp=Wl);function Oh(){He.log(" Initializing new UI..."),T==null||T.initialize(),gh(),xh(),bh(),Ux({windowRef:window,documentRef:document,undo:nh,redo:ih,removeTileAtHex:Ga,getLastHexCoords:()=>B,getGhostTile:()=>at,getCurrentRotation:()=>O,setCurrentRotation:w=>{O=w},baseRotationY:V,createGhostMaterials:Ia,getSelectedTileInfo:()=>E,refreshGhostTile:An,updateUndoRedoButtons:Da,generateBuildInstructions:Gh,clearMap:Hl,getCurrentYLevel:()=>H,setCurrentYLevel:w=>{za(w)},setManualLevelOverride:w=>{ne=w},updateLevelIndicator:En,saveMapToFile:Mh,loadMapFromFile:Sh,saveMapToFileToolbar:Gl,loadMapFromFileToolbar:Th,confirmFn:w=>window.confirm(w),toggleDebugOverlay:wl,isFirstPersonActive:()=>Pe.active,handleCameraPresetSelection:Bl,shiftViewLayer:Ua,setActiveViewLayer:Cr,captureCurrentView:zl}),Ln(),Rn(),Da(),Tn(),He.log(" Modern interface fully initialized!")}window.addEventListener("resize",zh),window.addEventListener("pagehide",Uh,{once:!0});const Va=document.getElementById("map-name-input-toolbar");if(Va&&!Va.value){const w=localStorage.getItem("lorescape:mapName");Va.value=w||"Unnamed Map"}const ql=document.getElementById("map-name-input-toolbar");ql&&ql.addEventListener("input",w=>{localStorage.setItem("lorescape:mapName",w.target.value||"")}),window.addEventListener("keydown",w=>{if(w.key.toLowerCase()==="n"&&!w.ctrlKey&&!w.metaKey&&!w.altKey){const k=document.getElementById("map-name-input-toolbar");k&&(k.focus(),k.select(),w.preventDefault())}(w.ctrlKey||w.metaKey)&&w.key.toLowerCase()==="s"&&(w.preventDefault(),Gl())});function zh(){tt()}function Uh(){var w;Rr({skipPointerUnlock:!0}),(w=C==null?void 0:C.dispose)==null||w.call(C)}const Os=He.child("instructions"),Hh=ux({instructionsLog:Os,biomeSets:Pi,placedTiles:l});function Gh(){if(Os.log(" Generating build instructions..."),Os.log(" placedTiles size:",l.size),l.size===0){alert(" Cannot generate instructions - map is empty!");return}const w=Vh();if(Os.log(" Layer analysis result:",w),w.layers.length===0){alert(" Error analyzing map layers!");return}Os.log(` Found ${w.layers.length} layers`,w),Hh.generateLayerInstructions(w)}function Vh(){const w=new Map,k={minQ:1/0,maxQ:-1/0,minR:1/0,maxR:-1/0};if(l.forEach((Z,fe)=>{if(!Z){console.error(" ERROR: Tile is null/undefined");return}let xe=Z.hexCoords,ye=Z.yLevel;if(!xe){const Ye=fe.match(/q:(-?\d+),r:(-?\d+),y:(\d+)/);if(Ye)xe={q:parseInt(Ye[1],10),r:parseInt(Ye[2],10)},ye=parseInt(Ye[3],10);else{console.error(" ERROR: Cannot extract coordinates from key:",fe);return}}if(typeof ye>"u"){const Ye=fe.match(/q:(-?\d+),r:(-?\d+),y:(\d+)/);ye=Ye?parseInt(Ye[3],10):0}const pe=Z.instanceId??null,Re=Z.biomeId||(pe?pe.split("_").slice(0,-1).join("_"):null),Xe=typeof Z.tileNumber=="number"&&!Number.isNaN(Z.tileNumber)?Z.tileNumber:pe?parseInt(pe.split("_").pop()||"1",10):1;if(!Re){console.warn(" Skipping tile without biome information:",{key:fe,tile:Z});return}if(typeof xe.q>"u"||typeof xe.r>"u"){console.error(" ERROR: Invalid hexCoords:",xe);return}k.minQ=Math.min(k.minQ,xe.q),k.maxQ=Math.max(k.maxQ,xe.q),k.minR=Math.min(k.minR,xe.r),k.maxR=Math.max(k.maxR,xe.r),w.has(ye)||w.set(ye,[]),w.get(ye).push({q:xe.q,r:xe.r,yLevel:ye,biomeId:Re,tileNumber:Xe,key:fe,instanceId:pe,rotation:Z.rotation||{x:0,y:0,z:0},rotationDegrees:Z.rotationDegrees||0})}),w.size===0)return He.error(" ERROR: No valid tiles found!"),{layers:[],layerData:new Map,bounds:{},mapWidth:0,mapHeight:0};const $=Array.from(w.keys()).sort((Z,fe)=>Z-fe);return He.log(" Layer analysis summary",{layers:$,bounds:k,tileCount:l.size}),{layers:$,layerData:w,bounds:k,mapWidth:k.maxQ-k.minQ+1,mapHeight:k.maxR-k.minR+1}}window.switchToTab=w=>{var k;(k=T==null?void 0:T.switchToTab)==null||k.call(T,w)},c({updateHeaderStats:Ln,updateRightPanelStats:Rn}),Wl()};let Ld=!1;const Io=()=>{Ld||(Ld=!0,Yx())},Rd=()=>{typeof window<"u"&&"requestAnimationFrame"in window?window.requestAnimationFrame(()=>{"requestIdleCallback"in window?window.requestIdleCallback(Io,{timeout:120}):Io()}):Io()};document.readyState==="complete"||document.readyState==="interactive"?Rd():document.addEventListener("DOMContentLoaded",Rd,{once:!0});var Cd;const fs=(Cd=import.meta)==null?void 0:Cd.env;(fs!=null&&fs.DEV||fs!=null&&fs.PROD)&&jh(()=>Promise.resolve().then(()=>qh),void 0);
